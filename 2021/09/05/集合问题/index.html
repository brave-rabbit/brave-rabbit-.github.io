<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>集合问题 | Moon</title><meta name="keywords" content="集合"><meta name="author" content="Kris"><meta name="copyright" content="Kris"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="# ArrayList 和 LinkedList 有什么区别？ 首先，他们的底层数据结构不同，ArrayList 底层是基于数组实现的，LinkedList 底层是基于链表实现的 由于底层数据结构不同，他们所适用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加，查询、添加、删除的时间复杂度不同 另外 ArrayList 和 LinkedList 都实现了 L">
<meta property="og:type" content="article">
<meta property="og:title" content="集合问题">
<meta property="og:url" content="http://example.com/2021/09/05/%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="Moon">
<meta property="og:description" content="# ArrayList 和 LinkedList 有什么区别？ 首先，他们的底层数据结构不同，ArrayList 底层是基于数组实现的，LinkedList 底层是基于链表实现的 由于底层数据结构不同，他们所适用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加，查询、添加、删除的时间复杂度不同 另外 ArrayList 和 LinkedList 都实现了 L">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/6.png">
<meta property="article:published_time" content="2021-09-05T01:26:59.000Z">
<meta property="article:modified_time" content="2021-09-05T01:39:20.658Z">
<meta property="article:author" content="Kris">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/6.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/09/05/%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '集合问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-05 09:39:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/css/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiperstyle.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/me1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-quran"></i><span> 笔记</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 爱好</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-moon"></i><span> 链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/6.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Moon</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-quran"></i><span> 笔记</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-clock"></i><span> 时间线</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 爱好</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/picture/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 番剧</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw far fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-moon"></i><span> 链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">集合问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-05T01:26:59.000Z" title="发表于 2021-09-05 09:26:59">2021-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-05T01:39:20.658Z" title="更新于 2021-09-05 09:39:20">2021-09-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">50.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>193分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="集合问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2021/09/05/%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="arraylist和linkedlist有什么区别"><a class="markdownIt-Anchor" href="#arraylist和linkedlist有什么区别">#</a> ArrayList 和 LinkedList 有什么区别？</h2>
<p>首先，他们的底层数据结构不同，ArrayList 底层是基于数组实现的，LinkedList 底层是基于链表实现的<br>
由于底层数据结构不同，他们所适用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加，查询、添加、删除的时间复杂度不同<br>
另外 ArrayList 和 LinkedList 都实现了 List 接口，但是 LinkedList 还额外实现了 Deque 接口，所以 LinkedList 还可以当做队列来使用。</p>
<h2 id="arraylist的sublist修改是否影响list本身"><a class="markdownIt-Anchor" href="#arraylist的sublist修改是否影响list本身">#</a> ArrayList 的 sublist 修改是否影响 list 本身？</h2>
<p>方法实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// fromIndex: 集合开始的索引，toIndex:集合结束的索引，左开右闭</span><br><span class="line">public List&lt;E&gt; subList(int fromIndex， int toIndex) &#123;</span><br><span class="line">	// 边界校验</span><br><span class="line">	subListRangeCheck(fromIndex， toIndex， size);</span><br><span class="line">	// subList 返回是一个视图</span><br><span class="line">	return new SubList(this， 0， fromIndex， toIndex);</span><br><span class="line">&#125;</span><br><span class="line">// ArrayList 的内部类，这个类中单独定义了 set、get、size、add、remove 等方法</span><br><span class="line">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123;</span><br><span class="line">	private final AbstractList&lt;E&gt; parent; // parent的具体实现类是 ArrayList</span><br><span class="line">	private final int parentOffset;</span><br><span class="line">	private final int offset;</span><br><span class="line">	int size;</span><br><span class="line">	SubList(AbstractList&lt;E&gt; parent，int offset， int fromIndex， int toIndex) &#123;</span><br><span class="line">		this.parent = parent;</span><br><span class="line">		this.parentOffset = fromIndex;</span><br><span class="line">		this.offset = offset + fromIndex;</span><br><span class="line">		this.size = toIndex - fromIndex;</span><br><span class="line">		this.modCount = ArrayList.this.modCount;</span><br><span class="line">	&#125;</span><br><span class="line">	public E set(int index, E e) &#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          E oldValue = ArrayList.this.elementData(offset + index);</span><br><span class="line">          ArrayList.this.elementData[offset + index] = e;</span><br><span class="line">          return oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      public E get(int index) &#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          return ArrayList.this.elementData(offset + index);</span><br><span class="line">      &#125;</span><br><span class="line">      public int size() &#123;</span><br><span class="line">          checkForComodification();</span><br><span class="line">          return this.size;</span><br><span class="line">      &#125;</span><br><span class="line">      public void add(int index, E e) &#123;</span><br><span class="line">          rangeCheckForAdd(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">		// 添加直接调用父类的添加元素的方法</span><br><span class="line">          parent.add(parentOffset + index, e);</span><br><span class="line">		// subList 添加的元素后，会同步父集合的modCount 修改到 subList的modCount，</span><br><span class="line">          this.modCount = parent.modCount;</span><br><span class="line">          this.size++;</span><br><span class="line">      &#125;</span><br><span class="line">      public E remove(int index) &#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          E result = parent.remove(parentOffset + index);</span><br><span class="line">          this.modCount = parent.modCount;</span><br><span class="line">          this.size--;</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">	private void checkForComodification() &#123;</span><br><span class="line">          if (ArrayList.this.modCount != this.modCount)</span><br><span class="line">              throw new ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>ubList 可以做集合的任何操作</p>
</li>
<li>
<p>调用该方法后的生成的新的集合的操作都会对原集合有影响，在 subList 集合后面添加元素，添加的第一个元素的位置就是上述 toIndex 的值，而原始集合中 toIndex 的元素往后移动。其 add 方法调用过程：</p>
<p><code>add(element) --&gt; AbstractList.add(e) --&gt; SubList.add(index， e) --&gt; parent.add(index + parentOffset， e) --&gt; ArrayList.add(newIndex， e)</code></p>
</li>
<li>
<p>List 的 subList 方法并没有创建一个新的 List，而是使用了 原 List 的视图，这个视图使用内部类 SubList 表示；不能把 subList 方法返回的 List 强制转换成 ArrayList 等类，因为他 们之间没有继承关系；</p>
</li>
</ul>
<p>视图和原 List 的修改还需要注意几点，尤其是他们之间的相互影响：</p>
<ul>
<li>对 父 (sourceList) 子 (subList) List 做 的 非 结 构 性 修 改 (non-structural changes)，都会影响到彼此；</li>
<li>对 <code>子List</code>  做结构性修改，操作同样会反映到 <code>父List</code>  上；子 List 的 add 是直接调用父集合的 add 方法来添加的元素的：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void add(int index, E e) &#123;</span><br><span class="line">	rangeCheckForAdd(index);</span><br><span class="line">	checkForComodification();</span><br><span class="line">	parent.add(parentOffset + index, e);</span><br><span class="line">	this.modCount = parent.modCount;</span><br><span class="line">	this.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 <code>父List</code>  做结构性修改（增加、删除），均会导致 <code>子List</code>  的遍历、增加、删除抛出异常 ConcurrentModificationException；因为其迭代的时候会对比 <code>父List的modCount</code>  和 <code>子集合的modCount</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void checkForComodification() &#123;</span><br><span class="line">	// ArrayList.this.modCount 表示父List的 modCount，this.modCount表示 子List的modCount</span><br><span class="line">	if (ArrayList.this.modCount != this.modCount)</span><br><span class="line">		throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="synchronizedlist-vector有什么区别"><a class="markdownIt-Anchor" href="#synchronizedlist-vector有什么区别">#</a> SynchronizedList、Vector 有什么区别？</h2>
<ul>
<li>SynchronizedList 是 java.util.Collections 的静态内部类；Vector 是 java.util 包中的一个类；</li>
<li>使用 add 方法时，扩容机制不一样；</li>
<li>SynchronizedList 有很好的扩展和兼容功能，可以将所有的 List 的子类转成线程安全的类；</li>
<li>使用 SynchronizedList 的时候，进行遍历时需要手动进行同步处理；</li>
<li>SynchronizedList 可以指定锁的对象</li>
</ul>
<h2 id="arraysaslisttargs获得的list特点"><a class="markdownIt-Anchor" href="#arraysaslisttargs获得的list特点">#</a> Arrays.asList (T…args) 获得的 List 特点？</h2>
<ul>
<li>其返回的 List 是 Arrays 的一个内部类，是原来数组的视图，不支持增删操作；</li>
<li>如果需要对其进行操作的话，可以通过 ArrayList 的构造器将其转为 ArrayList；</li>
</ul>
<h2 id="iterator和listiterator区别"><a class="markdownIt-Anchor" href="#iterator和listiterator区别">#</a> Iterator 和 ListIterator 区别？</h2>
<ul>
<li>都是用于遍历集合的，Iterator 可以用于遍历 Set、List；ListIterator 只可用于 List；</li>
<li>ListIterator 实现的 Iterator 接口；</li>
<li>ListIterator 可向前和向后遍历；Iterator 只可向后遍历；</li>
</ul>
<h2 id="arraylist是怎么扩容的"><a class="markdownIt-Anchor" href="#arraylist是怎么扩容的">#</a> ArrayList 是怎么扩容的？</h2>
<p>ArrayList 内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList 不会进行缩容；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 新容量为旧容量的1.5倍</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        // 如果新容量发现比需要的容量还小，则以需要的容量为准</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        // 如果新容量已经超过最大容量了，则使用最大容量</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // 以新容量拷贝出来一个新数组</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arraylist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#arraylist插入-删除-查询元素的时间复杂度各是多少">#</a> ArrayList 插入、删除、查询元素的时间复杂度各是多少？</h2>
<p>ArrayList 支持随机访问，通过索引访问元素极快，时间复杂度为 O (1)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public E get(int index) &#123;</span><br><span class="line">        // 检查是否越界</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        // 返回数组index位置的元素</span><br><span class="line">        return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果根据比较对象的话时间复杂度就是 O (n)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 添加元素到尾部极快，平均时间复杂度为 O (1)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        // 检查是否需要扩容</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        // 把元素插入到最后一位</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为 O (n)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public void add(int index, E element) &#123;</span><br><span class="line">        // 检查是否越界</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        // 检查是否需要扩容</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        // 将index及其之后的元素往后挪一位，则index位置处就空出来了</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                         size - index);</span><br><span class="line">        // 将元素插入到index的位置</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        // 大小加</span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 从尾部删除元素极快，时间复杂度为 O (1)；</p>
<p>ArrayList 从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为 O (n)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public boolean remove(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                // 如果要删除的元素为null，则以null进行比较，使用==</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                // 如果要删除的元素不为null，则进行比较，使用equals()方法</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">        // 少了一个越界的检查</span><br><span class="line">        modCount++;</span><br><span class="line">        // 如果index不是最后一位，则将index之后的元素往前挪一位</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        // 将最后一个元素删除，帮助GC</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="怎么求两个集合的并集-交集-差集"><a class="markdownIt-Anchor" href="#怎么求两个集合的并集-交集-差集">#</a> 怎么求两个集合的并集、交集、差集？</h2>
<p>ArrayList 支持求并集，调用 addAll (Collection&lt;? extends E&gt; c) 方法即可；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        // 将集合c转为数组</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        // 检查是否需要扩容</span><br><span class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line">        // 将c中元素全部拷贝到数组的最后</span><br><span class="line">        System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">        // 大小增加c的大小</span><br><span class="line">        size += numNew;</span><br><span class="line">        // 如果c不为空就返回true，否则返回false</span><br><span class="line">        return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList 支持求交集，调用 retainAll (Collection&lt;? extends E&gt; c) 方法即可；<br>
ArrayList 支持求单向差集，调用 removeAll (Collection&lt;? extends E&gt; c) 方法即可；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">     * 批量删除元素</span><br><span class="line">     * complement为true表示删除c中不包含的元素</span><br><span class="line">     * complement为false表示删除c中包含的元素</span><br><span class="line">     */</span><br><span class="line">    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">        final Object[] elementData = this.elementData;</span><br><span class="line">        // 使用读写两个指针同时遍历数组</span><br><span class="line">        // 读指针每次自增1，写指针放入元素的时候才加1</span><br><span class="line">        // 这样不需要额外的空间，只需要在原有的数组上操作就可以了</span><br><span class="line">        int r = 0, w = 0;</span><br><span class="line">        boolean modified = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 遍历整个数组，如果c中包含该元素，则把该元素放到写指针的位置（以complement为准）</span><br><span class="line">            for (; r &lt; size; r++)</span><br><span class="line">                if (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 正常来说r最后是等于size的，除非c.contains()抛出了异常</span><br><span class="line">            if (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">             * 原有的:a:1 3 4</span><br><span class="line">             * 比较的:b:1 3 2</span><br><span class="line">             */</span><br><span class="line">            if (w != size) &#123;</span><br><span class="line">                // 将写指针之后的元素置为空，帮助GC</span><br><span class="line">                for (int i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = null;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                // 新大小等于写指针的位置（因为每写一次写指针就加1，所以新大小正好等于写指针的位置）</span><br><span class="line">                size = w;</span><br><span class="line">                modified = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="arraylist是怎么实现序列化和反序列化的"><a class="markdownIt-Anchor" href="#arraylist是怎么实现序列化和反序列化的">#</a> ArrayList 是怎么实现序列化和反序列化的？</h2>
<p>序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">       throws java.io.IOException&#123;</span><br><span class="line">       // 防止序列化期间被修改</span><br><span class="line">       int expectedModCount = modCount;</span><br><span class="line">       // 写出非transient非static属性（会写出size属性）</span><br><span class="line">       s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">       // 写出元素个数</span><br><span class="line">       s.writeInt(size);</span><br><span class="line"></span><br><span class="line">       // 依次写出元素</span><br><span class="line">       for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">           s.writeObject(elementData[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       // 如果有修改，抛出异常</span><br><span class="line">       if (modCount != expectedModCount) &#123;</span><br><span class="line">           throw new ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>反序列化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">       throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">       // 声明为空数组</span><br><span class="line">       elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">       // 读入非transient非static属性（会读取size属性）</span><br><span class="line">       s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">       // 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span><br><span class="line">       s.readInt(); // ignored</span><br><span class="line"></span><br><span class="line">       if (size &gt; 0) &#123;</span><br><span class="line">           // 计算容量</span><br><span class="line">           ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">           Object[] a = elementData;</span><br><span class="line">           //  // 依次读取元素到数组中</span><br><span class="line">           for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">               a[i] = s.readObject();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>查看 writeObject () 方法可知，先调用 s.defaultWriteObject () 方法，再把 size 写入到流中，再把元素一个一个的写入到流中。</p>
<p>一般地，只要实现了 Serializable 接口即可自动序列化，writeObject () 和 readObject () 是为了自己控制序列化的方式，这两个方法必须声明为 private，在 java.io.ObjectStreamClass#getPrivateMethod () 方法中通过反射获取到 writeObject () 这个方法。</p>
<p>在 ArrayList 的 writeObject () 方法中先调用了 s.defaultWriteObject () 方法，这个方法是写入非 static 非 transient 的属性，在 ArrayList 中也就是 size 属性。同样地，在 readObject () 方法中先调用了 s.defaultReadObject () 方法解析出了 size 属性。</p>
<p>elementData 定义为 transient 的优势，自己根据 size 序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p>
<h2 id="集合的方法toarray有什么问题"><a class="markdownIt-Anchor" href="#集合的方法toarray有什么问题">#</a> 集合的方法 toArray () 有什么问题？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ArrayTest &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           Father[] fathers = new Son[]&#123;&#125;;</span><br><span class="line">           // 打印结果为class [Lcom.coolcoding.code.Son;</span><br><span class="line">           System.out.println(fathers.getClass());</span><br><span class="line">   </span><br><span class="line">           List&lt;String&gt; strList = new MyList();</span><br><span class="line">           // 打印结果为class [Ljava.lang.String;</span><br><span class="line">           System.out.println(strList.toArray().getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   class Father &#123;&#125;</span><br><span class="line">   </span><br><span class="line">   class Son extends Father &#123;&#125;</span><br><span class="line">   </span><br><span class="line">   class MyList extends ArrayList&lt;String&gt; &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 子类重写父类的方法，返回值可以不一样</span><br><span class="line">        * 但这里只能用数组类型，换成Object就不行</span><br><span class="line">        * 应该算是java本身的bug</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public String[] toArray() &#123;</span><br><span class="line">           // 为了方便举例直接写死</span><br><span class="line">           return new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h2 id="什么是fail-fast"><a class="markdownIt-Anchor" href="#什么是fail-fast">#</a> 什么是 fail-fast？</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义">#</a> 定义</h3>
<p>“快速失败” 也就是 fail-fast，它是 Java 集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。</p>
<h3 id="例子"><a class="markdownIt-Anchor" href="#例子">#</a> 例子</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class FailFastTest &#123;</span><br><span class="line">        private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        private static class threadOne extends Thread&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line">                    int i = iterator.next();</span><br><span class="line">                    System.out.println(&quot;ThreadOne 遍历:&quot; + i);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">        private static class threadTwo extends Thread&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                int i = 0 ;</span><br><span class="line">                while(i &lt; 6)&#123;</span><br><span class="line">                    System.out.println(&quot;ThreadTwo run：&quot; + i);</span><br><span class="line">                    if(i == 3)&#123;</span><br><span class="line">                        list.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            for(int i = 0 ; i &lt; 10;i++)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            new threadOne().start();</span><br><span class="line">            new threadTwo().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817152045.png" alt="image-20210817152038167"></p>
<p>通过上面的示例和讲解，我初步知道 fail-fast 产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。</p>
<p>要了解 fail-fast 机制，我们首先要对 ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。</p>
<p>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出 ConcurrentModificationException 异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以 ArrayList 为例进一步分析 fail-fast 产生的原因。</p>
<h3 id="fail-fast解决办法"><a class="markdownIt-Anchor" href="#fail-fast解决办法">#</a> fail-fast 解决办法</h3>
<ul>
<li><strong>方案一：</strong> 在遍历过程中所有涉及到改变 modCount 值得地方全部加上 synchronized 或者直接使用 Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li>
<li><strong>方案二：</strong> 使用 CopyOnWriteArrayList 来替换 ArrayList。推荐使用该方案。</li>
</ul>
<h2 id="linkedlist是单链表还是双链表实现的"><a class="markdownIt-Anchor" href="#linkedlist是单链表还是双链表实现的">#</a> LinkedList 是单链表还是双链表实现的？</h2>
<p>LinkedList 是一个以双链表实现的 List；</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817152520.png" alt="image-20210817152520441"></p>
<h2 id="linkedlist除了作为list还有什么用处"><a class="markdownIt-Anchor" href="#linkedlist除了作为list还有什么用处">#</a> LinkedList 除了作为 List 还有什么用处？</h2>
<p>LinkedList 还是一个双端队列，具有队列、双端队列、栈的特性；</p>
<p>看一下它继承了哪些接口</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817152719.png" alt="image-20210817152719416"></p>
<h2 id="linkedlist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#linkedlist插入-删除-查询元素的时间复杂度各是多少">#</a> LinkedList 插入、删除、查询元素的时间复杂度各是多少？</h2>
<p>LinkedList 在队列首尾添加、删除元素非常高效，时间复杂度为 O (1)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 从队列首添加元素</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">        // 从队列首添加元素</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        // 创建新节点，新节点的next是首节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">        // 让新节点作为新的首节点</span><br><span class="line">        first = newNode;</span><br><span class="line">        // 判断是不是第一个添加的元素</span><br><span class="line">        // 如果是就把last也置为新节点</span><br><span class="line">        // 否则把原首节点的prev指针置为新节点</span><br><span class="line">        if (f == null)</span><br><span class="line">            last = newNode;</span><br><span class="line">        else</span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line">// 从队尾添加元素</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">        // 队列尾节点</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        // 创建新节点，新节点的prev是尾节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        // 让新节点成为新的尾节点</span><br><span class="line">        last = newNode;</span><br><span class="line">        // 判断是不是第一个添加的元素</span><br><span class="line">        // 如果是就把first也置为新节点</span><br><span class="line">        // 否则把原尾节点的next指针置为新节点</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"> // 删除首节点</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">        // 首节点的元素值</span><br><span class="line">        final E element = f.item;</span><br><span class="line">        // 首节点的next指针</span><br><span class="line">        final Node&lt;E&gt; next = f.next;</span><br><span class="line">        // 添加首节点的内容，协助GC</span><br><span class="line">        f.item = null;</span><br><span class="line">        f.next = null; // help GC</span><br><span class="line">        // 把首节点的next作为新的首节点</span><br><span class="line">        first = next;</span><br><span class="line">        // 如果只有一个元素，删除了，把last也置为空</span><br><span class="line">        // 否则把next的前置指针置为空</span><br><span class="line">        if (next == null)</span><br><span class="line">            last = null;</span><br><span class="line">        else</span><br><span class="line">            next.prev = null;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        size--;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return element;</span><br><span class="line">&#125;</span><br><span class="line">// 删除尾节点</span><br><span class="line"> private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">        // 尾节点的元素值</span><br><span class="line">        final E element = l.item;</span><br><span class="line">        // 尾节点的前置指针</span><br><span class="line">        final Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        // 清空尾节点的内容，协助GC</span><br><span class="line">        l.item = null;</span><br><span class="line">        l.prev = null; // help GC</span><br><span class="line">        // 让前置节点成为新的尾节点</span><br><span class="line">        last = prev;</span><br><span class="line">        // 如果只有一个元素，删除了把first置为空</span><br><span class="line">        // 否则把前置节点的next置为空</span><br><span class="line">        if (prev == null)</span><br><span class="line">            first = null;</span><br><span class="line">        else</span><br><span class="line">            prev.next = null;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        size--;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LinkedList 在中间添加、删除元素比较低效，时间复杂度为 O (n)；</p>
<p>中间添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 在节点succ之前添加元素</span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">        // succ是待添加节点的后继节点</span><br><span class="line">        // 找到待添加节点的前置节点</span><br><span class="line">        final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        // 在其前置节点和后继节点之间创建一个新节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        // 修改后继节点的前置指针指向新节点</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        // 判断前置节点是否为空</span><br><span class="line">        // 如果为空，说明是第一个添加的元素，修改first指针</span><br><span class="line">        // 否则修改前置节点的next为新节点</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        // 修改元素个数</span><br><span class="line">        size++;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 寻找index位置的节点</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        // 因为是双链表</span><br><span class="line">        // 所以根据index是在前半段还是后半段决定从前遍历还是从后遍历</span><br><span class="line">        // 这样index在后半段的时候可以少遍历一半的元素</span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">            // 如果是在前半段</span><br><span class="line">            // 就从前遍历</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果是在后半段</span><br><span class="line">            // 就从后遍历</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 在指定index位置处添加元素</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">        // 判断是否越界</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        // 如果index是在队列尾节点之后的一个位置</span><br><span class="line">        // 把新节点直接添加到尾节点之后</span><br><span class="line">        // 否则调用linkBefore()方法在中间添加节点</span><br><span class="line">        if (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        else</span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在中间删除或者删除指定节点 x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 删除指定节点x</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        // x的元素值</span><br><span class="line">        final E element = x.item;</span><br><span class="line">        // x的前置节点</span><br><span class="line">        final Node&lt;E&gt; next = x.next;</span><br><span class="line">        // x的后置节点</span><br><span class="line">        final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        // 如果前置节点为空</span><br><span class="line">        // 说明是首节点，让first指向x的后置节点</span><br><span class="line">        // 否则修改前置节点的next为x的后置节点</span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果后置节点为空</span><br><span class="line">        // 说明是尾节点，让last指向x的前置节点</span><br><span class="line">        // 否则修改后置节点的prev为x的前置节点</span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 清空x的元素值，协助GC</span><br><span class="line">        x.item = null;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        size--;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// remove的时候如果没有元素抛出异常</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        if (f == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// remove的时候如果没有元素抛出异常</span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        if (l == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// poll的时候如果没有元素返回null</span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// poll的时候如果没有元素返回null</span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        return (l == null) ? null : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除中间节点</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">        // 检查是否越界</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        // 删除指定index位置的节点</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="什么是随机访问"><a class="markdownIt-Anchor" href="#什么是随机访问">#</a> 什么是随机访问？</h2>
<p>java 集合类中元素的访问分为随机访问和顺序访问。随机访问一般是通过 index 下标访问，行为类似数组的访问。而顺序访问类似于链表的访问，通常为迭代器遍历。<br>
以 List 接口及其实例为例。ArrayList 是典型的随机访问型，而 LinkedList 则是顺序访问型。List 接口既定义了下标访问方法又定义了迭代器方法。所以其实例既可使用下标随机访问也可以使用迭代器进行遍历。但这两种方式的性能差异很明显。</p>
<p>随机访问是说你可以随意访问该数据结构中的任意一个节点，假设该数据结构有 10 个节点，你可以随意访问第 1 个到第 10 个节点。<br>
对于列表而言，如果其存在 10 个节点，如果你要访问第 5 个节点，你只能从列表的头或者尾，依次遍历相邻的每一个节点；</p>
<h4 id="randomaccess接口"><a class="markdownIt-Anchor" href="#randomaccess接口">#</a> RandomAccess 接口</h4>
<p>JDK 中的 RandomAccess 接口是一个标记接口，它并未定义方法。其目的是用于指示实现类具有随机访问特性，在遍历时使用下标访问较迭代器更快。如果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">for(int i = 0, n = list.size(); i &lt; n; i++)</span><br><span class="line">    list.get(i);</span><br></pre></td></tr></table></figure>
<p>的运行比</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">for(Interator i = list.iterator();i.hasNext();)</span><br><span class="line">    i.next();</span><br></pre></td></tr></table></figure>
<p>快，则应实现 RandomAccess 接口。</p>
<h2 id="哪些集合支持随机访问他们都有哪些共性"><a class="markdownIt-Anchor" href="#哪些集合支持随机访问他们都有哪些共性">#</a> 哪些集合支持随机访问？他们都有哪些共性？</h2>
<p>ArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。</p>
<h2 id="copyonwritearraylist是怎么保证并发安全的"><a class="markdownIt-Anchor" href="#copyonwritearraylist是怎么保证并发安全的">#</a> CopyOnWriteArrayList 是怎么保证并发安全的？</h2>
<p>CopyOnWriteArrayList 使用 ReentrantLock 重入锁加锁，保证线程安全；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/** 用于修改时加锁 */</span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** 真正存储元素的地方，只能通过getArray()/setArray()访问 */</span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>
<h2 id="copyonwritearraylist的实现采用了什么思想"><a class="markdownIt-Anchor" href="#copyonwritearraylist的实现采用了什么思想">#</a> CopyOnWriteArrayList 的实现采用了什么思想？</h2>
<p>CopyOnWriteArrayList 采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；它不存在扩容的概念，每次写操作都要复制一个副本，在副本的基础上修改后改变 Array 引用。CopyOnWriteArrayList 中写操作需要大面积复制数组，所以性能肯定很差。</p>
<h2 id="copyonwritearraylist是不是强一致性的"><a class="markdownIt-Anchor" href="#copyonwritearraylist是不是强一致性的">#</a> CopyOnWriteArrayList 是不是强一致性的？</h2>
<p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然 CopyOnWriteArrayList 能做到最终一致性，但是还是没法满足实时性一致性要求；</p>
<h2 id="copyonwritearraylistaddifabsente-e了解吗"><a class="markdownIt-Anchor" href="#copyonwritearraylistaddifabsente-e了解吗">#</a> CopyOnWriteArrayListaddIfAbsent (E e) 了解吗？</h2>
<p>添加一个元素如果这个元素不存在于集合中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean addIfAbsent(E e) &#123;</span><br><span class="line">        // 获取元素数组, 取名为快照</span><br><span class="line">        Object[] snapshot = getArray();</span><br><span class="line">        // 检查如果元素不存在,直接返回false</span><br><span class="line">        // 如果存在再调用addIfAbsent()方法添加元素</span><br><span class="line">        return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false :</span><br><span class="line">            addIfAbsent(e, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 重新获取旧数组</span><br><span class="line">            Object[] current = getArray();</span><br><span class="line">            int len = current.length;</span><br><span class="line">            // 如果快照与刚获取的数组不一致</span><br><span class="line">            // 说明有修改</span><br><span class="line">            if (snapshot != current) &#123;</span><br><span class="line">                // 重新检查元素是否在刚获取的数组里</span><br><span class="line">                int common = Math.min(snapshot.length, len);</span><br><span class="line">                for (int i = 0; i &lt; common; i++)</span><br><span class="line">                    // 到这个方法里面了, 说明元素不在快照里面</span><br><span class="line">                    if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                        return false;</span><br><span class="line">                if (indexOf(e, current, common, len) &gt;= 0)</span><br><span class="line">                        return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 拷贝一份n+1的数组</span><br><span class="line">            Object[] newElements = Arrays.copyOf(current, len + 1);</span><br><span class="line">            // 将元素放在最后一位</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>（1）检查这个元素是否存在于数组快照中；</p>
<p>（2）如果存在直接返回 false，如果不存在调用 addIfAbsent (E e, Object [] snapshot) 处理；</p>
<p>（3）加锁；</p>
<p>（4）如果当前数组不等于传入的快照，说明有修改，检查待添加的元素是否存在于当前数组中，如果存在直接返回 false;</p>
<p>（5）拷贝一个新数组，长度等于原数组长度加 1，并把原数组元素拷贝到新数组中；</p>
<p>（6）把新元素添加到数组最后一位；</p>
<p>（7）把新数组赋值给当前对象的 array 属性，覆盖原数组；</p>
<p>（8）解锁；</p>
<h2 id="copyonwritearraylist适用于什么样的场景"><a class="markdownIt-Anchor" href="#copyonwritearraylist适用于什么样的场景">#</a> CopyOnWriteArrayList 适用于什么样的场景？</h2>
<p>CopyOnWriteArrayList 采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合，比如缓存；不过这类慎用 ，因为谁也没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p>
<h2 id="copyonwritearraylist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#copyonwritearraylist插入-删除-查询元素的时间复杂度各是多少">#</a> CopyOnWriteArrayList 插入、删除、查询元素的时间复杂度各是多少？</h2>
<p>CopyOnWriteArrayList 的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是 O (n)，性能比较低下；</p>
<p>CopyOnWriteArrayList 的读操作支持随机访问，时间复杂度为 O (1)；</p>
<p>添加一个元素到末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取旧数组</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            int len = elements.length;</span><br><span class="line">            // 将旧数组元素拷贝到新数组中</span><br><span class="line">            // 新数组大小是旧数组大小加1</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">            // 将元素放在最后一位</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加一个元素在指定索引处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line">       // 加锁</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           // 获取旧数组</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           int len = elements.length;</span><br><span class="line">           // 检查是否越界, 可以等于len</span><br><span class="line">           if (index &gt; len || index &lt; 0)</span><br><span class="line">               throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">                                                   &quot;, Size: &quot;+len);</span><br><span class="line">           Object[] newElements;</span><br><span class="line">           int numMoved = len - index;</span><br><span class="line">           if (numMoved == 0)</span><br><span class="line">               // 如果插入的位置是最后一位</span><br><span class="line">               // 那么拷贝一个n+1的数组, 其前n个元素与旧数组一致</span><br><span class="line">               newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">           else &#123;</span><br><span class="line">               // 如果插入的位置不是最后一位</span><br><span class="line">               // 那么新建一个n+1的数组</span><br><span class="line">               newElements = new Object[len + 1];</span><br><span class="line">               // 拷贝旧数组前index的元素到新数组中</span><br><span class="line">               System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">               // 将index及其之后的元素往后挪一位拷贝到新数组中</span><br><span class="line">               // 这样正好index位置是空出来的</span><br><span class="line">               System.arraycopy(elements, index, newElements, index + 1,</span><br><span class="line">                                numMoved);</span><br><span class="line">           &#125;</span><br><span class="line">           // 将元素放置在index处</span><br><span class="line">           newElements[index] = element;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // 释放锁</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>删除指定索引位置的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line">       // 加锁</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           // 获取旧数组</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           int len = elements.length;</span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line">           int numMoved = len - index - 1;</span><br><span class="line">           if (numMoved == 0)</span><br><span class="line">               // 如果移除的是最后一位</span><br><span class="line">               // 那么直接拷贝一份n-1的新数组, 最后一位就自动删除了</span><br><span class="line">               setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">           else &#123;</span><br><span class="line">               // 如果移除的不是最后一位</span><br><span class="line">               // 那么新建一个n-1的新数组</span><br><span class="line">               Object[] newElements = new Object[len - 1];</span><br><span class="line">               // 将前index的元素拷贝到新数组中</span><br><span class="line">               System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">               // 将index后面(不包含)的元素往前挪一位</span><br><span class="line">               // 这样正好把index位置覆盖掉了, 相当于删除了</span><br><span class="line">               System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">               setArray(newElements);</span><br><span class="line">           &#125;</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // 释放锁</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>获取指定索引的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">        // 获取元素不需要加锁</span><br><span class="line">        // 直接返回index位置的元素</span><br><span class="line">        // 这里是没有做越界检查的, 因为数组本身会做越界检查</span><br><span class="line">        return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final Object[] getArray() &#123;</span><br><span class="line">        return array;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">        return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="copyonwritearraylist为什么没有size属性"><a class="markdownIt-Anchor" href="#copyonwritearraylist为什么没有size属性">#</a> CopyOnWriteArrayList 为什么没有 size 属性？</h2>
<p>因为每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要 size 属性了，数组的长度就是集合的大小，而不像 ArrayList 数组的长度实际是要大于集合的大小的。</p>
<p>比如，add (E e) 操作，先拷贝一份 n+1 个元素的数组，再把新元素放到新数组的最后一位，这时新数组的长度为 len+1 了，也就是集合的 size 了。</p>
<h2 id="比较古老的集合vector和stack有什么缺陷"><a class="markdownIt-Anchor" href="#比较古老的集合vector和stack有什么缺陷">#</a> 比较古老的集合 Vector 和 Stack 有什么缺陷？</h2>
<p>Vector：线程安全的动态数组</p>
<p>Stack：继承 Vector，基于动态数组实现的一个线程安全的栈；</p>
<p>Vector 与 ArrayList 基本是一致的，不同的是 Vector 是线程安全的，会在可能出现线程安全的方法前面加上 synchronized 关键字；</p>
<p>Vector：随机访问速度快，插入和移除性能较差 (数组的特点)；支持 null 元素；有顺序；元素可以重复；线程安全；</p>
<p>Stack：后进先出，实现了一些栈基本操作的方法（其实并不是只能后进先出，因为继承自 Vector，可以有很多操作，从某种意义上来讲，不是一个栈）；</p>
<p>所以基本上来说 vector 因为线程安全的实现方法比较粗暴效率较低。</p>
<h2 id="什么是散列表"><a class="markdownIt-Anchor" href="#什么是散列表">#</a> 什么是散列表？</h2>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>（Hash table，也叫哈希表），是根据关键码值 (Key value) 而直接进行访问的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">散列函数</a>，存放记录的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>叫做<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>。</p>
<p>给定表 M，存在函数 f (key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希 (Hash）表，函数 f (key) 为哈希 (Hash) 函数。</p>
<p><strong>hash 就是找到一种数据内容和数据存放地址之间的映射关系。</strong></p>
<h2 id="常见的散列函数"><a class="markdownIt-Anchor" href="#常见的散列函数">#</a> 常见的散列函数？</h2>
<ul>
<li>直接定址法：直接以关键字 k 或者 k 加上某个常数 (k+c) 作为哈希地址；</li>
<li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址；</li>
<li>除留余数法：用关键字 k 除以某个不大于哈希表长度 m 的数 p，将所得余数作为哈希表地址；</li>
<li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址；</li>
<li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求去中间几位作为哈希表地址；</li>
<li>伪随机数法：采用一个伪随机数作为哈希函数</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yyyljw/article/details/80903391">有兴趣的可以访问</a></p>
<h2 id="碰撞解决方案"><a class="markdownIt-Anchor" href="#碰撞解决方案">#</a> 碰撞解决方案？</h2>
<p>衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本无法彻底避免碰撞。</p>
<p>常见解决碰撞的方法有以下几种：</p>
<ul>
<li>开发定址法：就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入；</li>
<li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表尾部；</li>
<li>再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希地址，直到冲突不在产生为止；</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li>
</ul>
<h2 id="怎么实现一个散列表"><a class="markdownIt-Anchor" href="#怎么实现一个散列表">#</a> 怎么实现一个散列表？</h2>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1K54y147TB?p=211">推荐小码哥的恋上数据结构与算法</a></p>
<h2 id="java中hashmap实现方式的演进"><a class="markdownIt-Anchor" href="#java中hashmap实现方式的演进">#</a> java 中 HashMap 实现方式的演进？</h2>
<p>JDK1.7 中底层是数组 + 链表，JDK1.8 中底层是数组 + 链表 + 红黑树，加红黑树的目的是提高 HashMap 插入和查询整体效率 JDK1.7 中链表插入使用的是头插法，1.8 中链表插入使用的是尾插法，因为 1.8 中插入 key 和 value 时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法 JDK1.7 中哈希算法比较复杂，存在各种右移与异或运算，JDK1.8 中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供 HashMap 的整体效率，而 1.8 中新增了红黑树，所以可以适当的简化哈希算法，节省 CPU 资源。</p>
<h2 id="hashmap的容量有什么特点"><a class="markdownIt-Anchor" href="#hashmap的容量有什么特点">#</a> HashMap 的容量有什么特点？</h2>
<p>默认情况下，当我们设置 HashMap 的初始化容量时，实际上 HashMap 会采用第一个大于该数值的 2 的幂作为初始化容量。HashMap 默认容量为 16, 每次超过阀值时，按照两倍大小进行自动扩容，所以容量总是 2^N 次方。并且，底层的  <code>table</code>  数组是延迟初始化，在首次添加 key-value 键值对才进行初始化。在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为 2 的 n 次方 (一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="https://link.zhihu.com/?target=http://blog.csdn.net/liuqiyao_01/article/details/14475159"> http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）。HashMap 采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。</p>
<h2 id="hashmap如何确定哈希桶数组索引位置"><a class="markdownIt-Anchor" href="#hashmap如何确定哈希桶数组索引位置">#</a> HashMap 如何确定哈希桶数组索引位置？</h2>
<p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap 定位数组索引位置，直接决定了 hash 方法的离散性能。先看看源码的实现 (方法一 + 方法二):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">方法一：</span><br><span class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span><br><span class="line">     return h &amp; (length-1);  //第三步 取模运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 Hash 算法本质上就是三步：<strong>取 key 的 hashCode 值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象，只要它的 hashCode () 返回值相同，那么程序调用方法一所计算得到的 Hash 码值总是相同的。我们首先想到的就是把 hash 值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在 HashMap 中是这样做的：调用方法二来计算该对象应该保存在 table 数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1) 运算等价于对 length 取模，也就是 h% length，但是 &amp; 比 % 具有更高的效率。</p>
<p>在 JDK1.8 的实现中，优化了高位运算的算法，通过 hashCode () 的高 16 位异或低 16 位实现的：(h = k.hashCode ()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n 为 table 的长度。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817164145.png" alt="img"></p>
<h2 id="hashmap是怎么进行扩容的"><a class="markdownIt-Anchor" href="#hashmap是怎么进行扩容的">#</a> HashMap 是怎么进行扩容的？</h2>
<p>扩容 (resize) 就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下 resize 的源码，鉴于 JDK1.8 融入了红黑树，较复杂，为了便于理解我们仍然使用 JDK1.7 的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">void resize(int newCapacity) &#123;   //传入新的容量</span><br><span class="line">    Entry[] oldTable = table;    //引用扩容前的Entry数组</span><br><span class="line">   int oldCapacity = oldTable.length;         </span><br><span class="line">     if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //扩容前的数组大小如果已经达到最大(2^30)了</span><br><span class="line">        threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组</span><br><span class="line">    transfer(newTable);                         //！！将数据转移到新的Entry数组里</span><br><span class="line">     table = newTable;                           //HashMap的table属性引用新的Entry数组</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);//修改阈值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer () 方法将原有 Entry 数组的元素拷贝到新的 Entry 数组里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src = table;                   //src引用了旧的Entry数组</span><br><span class="line">     int newCapacity = newTable.length;</span><br><span class="line">    for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组</span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span><br><span class="line">            do &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置</span><br><span class="line">                 e.next = newTable[i]; //标记[1]</span><br><span class="line">                 newTable[i] = e;      //将元素放在数组上</span><br><span class="line">                 e = next;             //访问下一个Entry链上的元素</span><br><span class="line">             &#125; while (e != null);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newTable [i] 的引用赋给了 e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部 (如果发生了 hash 冲突的话），这一点和 Jdk1.8 有区别，下文详解。在旧数组中同一条 Entry 链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的 hash 算法就是简单的用 key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组 table 的 size=2， 所以 key = 3、7、5，put 顺序依次为 5、7、3。在 mod 2 以后都冲突在 table [1] 这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小 size 大于 table 的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165435.png" alt="img"></p>
<p>下面我们讲解下 JDK1.8 做了哪些优化。经过观测可以发现，我们使用的是 2 次幂的扩展 (指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165518.png" alt="img"></p>
<p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit (红色)，因此新的 index 就会发生这样的变化：</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165540.png" alt="img"></p>
<p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成 “原索引 + oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图：</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165555.png" alt="img"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。有一点注意区别，JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8 不会倒置。JDK1.8 扩容步骤为:</p>
<p>（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为 16，扩容门槛为 12；</p>
<p>（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的 2 的 n 次方；</p>
<p>（3）如果旧容量大于 0，则新容量等于旧容量的 2 倍，但不超过最大容量 2 的 30 次方，新扩容门槛为旧扩容门槛的 2 倍；</p>
<p>（4）创建一个新容量的桶；</p>
<p>（5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">final Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       // 旧数组</span><br><span class="line">       Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">       // 旧容量</span><br><span class="line">       int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">       // 旧扩容门槛</span><br><span class="line">       int oldThr = threshold;</span><br><span class="line">       int newCap, newThr = 0;</span><br><span class="line">       if (oldCap &gt; 0) &#123;</span><br><span class="line">           if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               // 如果旧容量达到了最大容量，则不再进行扩容</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               return oldTab;</span><br><span class="line">           &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               // 如果旧容量的两倍小于最大容量并且旧容量大于默认初始容量（16），则容量扩大为两部，扩容门槛也扩大为两倍</span><br><span class="line">               newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">       &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">           // 使用非默认构造方法创建的map，第一次插入元素会走到这里</span><br><span class="line">           // 如果旧容量为0且旧扩容门槛大于0，则把新容量赋值为旧门槛</span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">           // 调用默认构造方法创建的map，第一次插入元素会走到这里</span><br><span class="line">           // 如果旧容量旧扩容门槛都是0，说明还未初始化过，则初始化容量为默认容量，扩容门槛为默认容量*默认装载因子</span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       if (newThr == 0) &#123;</span><br><span class="line">           // 如果新扩容门槛为0，则计算为容量*装载因子，但不能超过最大容量</span><br><span class="line">           float ft = (float) newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ?</span><br><span class="line">                   (int) ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       // 赋值扩容门槛为新门槛</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       // 新建一个新容量的数组</span><br><span class="line">       @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="line">       Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap];</span><br><span class="line">       // 把桶赋值为新数组</span><br><span class="line">       table = newTab;</span><br><span class="line">       // 如果旧数组不为空，则搬移元素</span><br><span class="line">       if (oldTab != null) &#123;</span><br><span class="line">           // 遍历旧数组</span><br><span class="line">           for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K, V&gt; e;</span><br><span class="line">               // 如果桶中第一个元素不为空，赋值给e</span><br><span class="line">               if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                   // 清空旧桶，便于GC回收  </span><br><span class="line">                   oldTab[j] = null;</span><br><span class="line">                   // 如果这个桶中只有一个元素，则计算它在新桶中的位置并把它搬移到新桶中</span><br><span class="line">                   // 因为每次都扩容两倍，所以这里的第一个元素搬移到新桶的时候新桶肯定还没有元素</span><br><span class="line">                   if (e.next == null)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                   else if (e instanceof TreeNode)</span><br><span class="line">                       // 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span><br><span class="line">                       ((TreeNode&lt;K, V&gt;) e).split(this, newTab, j, oldCap);</span><br><span class="line">                   else &#123; // preserve order</span><br><span class="line">                       // 如果这个链表不止一个元素且不是一颗树</span><br><span class="line">                       // 则分化成两个链表插入到新的桶中去</span><br><span class="line">                       // 比如，假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span><br><span class="line">                       // 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span><br><span class="line">                       // 也就是分化成了两个链表</span><br><span class="line">                       Node&lt;K, V&gt; loHead = null, loTail = null;</span><br><span class="line">                       Node&lt;K, V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                       Node&lt;K, V&gt; next;</span><br><span class="line">                       do &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           // (e.hash &amp; oldCap) == 0的元素放在低位链表中</span><br><span class="line">                           // 比如，3 &amp; 4 == 0</span><br><span class="line">                           if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                               if (loTail == null)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               else</span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               // (e.hash &amp; oldCap) != 0的元素放在高位链表中</span><br><span class="line">                               // 比如，7 &amp; 4 != 0</span><br><span class="line">                               if (hiTail == null)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               else</span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; while ((e = next) != null);</span><br><span class="line">                       // 遍历完成分化成两个链表了</span><br><span class="line">                       // 低位链表在新桶中的位置与旧桶一样（即3和11还在三号桶中）</span><br><span class="line">                       if (loTail != null) &#123;</span><br><span class="line">                           loTail.next = null;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       // 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span><br><span class="line">                       if (hiTail != null) &#123;</span><br><span class="line">                           hiTail.next = null;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return newTab;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<h2 id="hashmap的put方法"><a class="markdownIt-Anchor" href="#hashmap的put方法">#</a> HashMap 的 put 方法？</h2>
<p>先说 HashMap 的 Put 方法的大体流程：<br>
1 根据 Key 通过哈希算法与与运算得出数组下标<br>
 2 如果数组下标位置元素为空，则将 key 和 value 封装为 Entry 对象（JDK1.7 中是 Entry 对象，JDK1.8 中是 Node 对象）并放入该位置<br>
 3 如果数组下标位置元素不为空，则要分情况讨论<br>
 a 如果是 JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成 Entry 对象，并使用头插法添加到当前位置的链表中<br>
 b 如果是 JDK1.8，则会先判断当前位置上的 Node 的类型，看是红黑树 Node，还是链表 Node<br>
ⅰ 如果是红黑树 Node，则将 key 和 value 封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前 key，如果存在则更新 value<br>
ⅱ 如果此位置上的 Node 对象是链表节点，则将 key 和 value 封装为一个链表 Node 并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前 key，如果存在则更新 value，当遍历完链表后，将新链表 Node 插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于等于 8，那么则会将该链表转成红黑树<br>
 ⅲ 将 key 和 value 封装为 Node 插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束 PUT 方法</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817162307.png" alt="HashMap的put方法过程"></p>
<p>代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        // 调用hash(key)计算出key的hash值</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        // 如果key为null，则hash值为0，否则调用key的hashCode()方法</span><br><span class="line">        // 并让高16位与整个hash异或，这样做是为了使计算出的hash更分散</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab;</span><br><span class="line">        Node&lt;K, V&gt; p;</span><br><span class="line">        int n, i;</span><br><span class="line">        // 如果桶的数量为0，则初始化</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            // 调用resize()初始化</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        // (n - 1) &amp; hash 计算元素在哪个桶中</span><br><span class="line">        // 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            // 新建一个节点放在桶中</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果桶中已经有元素存在了</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line">            // 如果桶中第一个元素的key与待插入元素的key相同，保存到e中用于后续修改value值</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                // 如果第一个元素是树节点，则调用树节点的putTreeVal插入元素</span><br><span class="line">                e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                // 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表最后插入一个新节点</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        // 如果插入新节点后链表长度大于8，则判断是否需要树化，因为第一个元素没有加到binCount中，所以这里-1</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果待插入的key在链表中找到了，则退出循环</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果找到了对应key的元素</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                // 记录下旧值</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                // 判断是否需要替换旧值</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    // 替换旧值为新值</span><br><span class="line">                    e.value = value;</span><br><span class="line">                // 在节点被访问后做点什么事，在LinkedHashMap中用到</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                // 返回旧值</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 到这里了说明没有找到元素</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        ++modCount;</span><br><span class="line">        // 元素数量加1，判断是否需要扩容</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            // 扩容</span><br><span class="line">            resize();</span><br><span class="line">        // 在节点插入后做点什么事，在LinkedHashMap中用到</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        // 没找到元素返回null</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hashmap中的元素是否是有序的"><a class="markdownIt-Anchor" href="#hashmap中的元素是否是有序的">#</a> HashMap 中的元素是否是有序的？</h2>
<p>HashMap 中的元素是无序的</p>
<h2 id="hashmap何时进行树化何时进行反树化"><a class="markdownIt-Anchor" href="#hashmap何时进行树化何时进行反树化">#</a> HashMap 何时进行树化？何时进行反树化？</h2>
<p>如果冲突的节点数已经达到 8 个，看是否需要改变冲突节点的存储结构，treeifyBin 首先判断当前 hashMap 的长度，如果不足 64，只进行 resize，扩容 table，如果达到 64，那么将冲突的存储结构为红黑树。</p>
<p>当链表的元素大于 8 时进行树化，小于 6 时进行反树化。</p>
<p><strong>选择 8 作为阀值和加载因子为 0.75 的原因是参考 泊松概率函数 (Poisson distribution)</strong></p>
<p>在 hashCode 离散性很好的情况下，红黑树用到的概率非常小，因为数据均匀分布在每个桶中，几乎不会有桶中链表长度会达到阈值 (8)。但是在随机 hashCode 下，离散性可能会变差，然而 JDK 又不能阻止用户实现这种不好的 hash 算法，因此就可能导致不均匀的数据分布。<br>
事实上，随机 hashCode 算法下所有桶中节点的分布频率遵循如下的泊松分布。在扩容阈值为 0.75 的情况下，（即使因为扩容而方差很大）遵循着参数平均为 0.5 的泊松分布。一个桶中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件。之所以选择 8，是时间和空间的权衡 (trade-off)，是根据概率统计决定的，是非常严谨和科学的。</p>
<p>通俗点将就是 put 进去的 key 进行计算 hashCode 时 只要选择计算 hash 值的算法足够好 (hash 碰撞率极低)，从而遵循泊松分布，使得桶中挂载的 bin 的数量等于 8 的概率非常小，从而转换为红黑树的概率也小，反之则概率大。</p>
<p><strong>为什么转化为红黑树的阈值 8 和转化为链表的阈值 6 不一样？</strong></p>
<p>为了避免频繁来回转化。</p>
<h2 id="泊松分布与指数分布"><a class="markdownIt-Anchor" href="#泊松分布与指数分布">#</a> 泊松分布与指数分布</h2>
<h3 id="泊松分布"><a class="markdownIt-Anchor" href="#泊松分布">#</a> 泊松分布</h3>
<p>Poisson 分布，是一种统计与概率论中常见的离散概率分布，其适合于描述单位时间内随机事件发生的次数的概率分布。</p>
<p>如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA 序列的变异数、放射性原子核的衰变数、激光的光子数分布等等；</p>
<h3 id="指数分布"><a class="markdownIt-Anchor" href="#指数分布">#</a> 指数分布</h3>
<p>指数分布（Exponential distribution）是一种连续概率分布。指数分配可以用来表示独立随机事件发生的时间间隔，比如旅客进入机场的时间间隔、打进客服中心电话的时间间隔、中文维基百科新条目出现的时间间隔等等；</p>
<p>与泊松分布相比，其最大的差异就是指数分布是针对连续随机变量定义，即时间这个变量。时间必须是连续的。而泊松分布是针对随机事件发生次数定义的，发生次数是离散的。粗略地可以认为这两个分布之间有一种 “倒数” 的关系</p>
<h2 id="hashmap是怎么进行缩容的"><a class="markdownIt-Anchor" href="#hashmap是怎么进行缩容的">#</a> HashMap 是怎么进行缩容的？</h2>
<p>它不会动态地进行缩容，也就是说，你不应该保留一个已经删除过大量 Entry 的 HashMap（如果不打算继续添加元素的话），此时它的 buckets 数组经过多次扩容已经变得非常大了，这会占用非常多的无用内存，这样做的好处是不用多次对数组进行扩容或缩容操作。不过一般也不会出现这种情况，如果遇见了，请毫不犹豫地丢掉它，或者把数据转移到一个新的 HashMap。</p>
<h2 id="hashmap插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#hashmap插入-删除-查询元素的时间复杂度各是多少">#</a> HashMap 插入、删除、查询元素的时间复杂度各是多少？</h2>
<p>因为 HashMap 很少出现 hash 冲突了，因为哈希算法足够优秀，那么全是 o（1）</p>
<p>但是当有链表的时候，那么就是 o（n）的复杂度</p>
<p>如果转成红黑树 也就是二叉树的一种，那么应该是 o（logN）的平均复杂度</p>
<h2 id="hashmap中的红黑树实现部分可以用其它数据结构代替吗"><a class="markdownIt-Anchor" href="#hashmap中的红黑树实现部分可以用其它数据结构代替吗">#</a> HashMap 中的红黑树实现部分可以用其它数据结构代替吗？</h2>
<p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构 (这就跟原来使用链表结构一样了，造成很深的问题)，遍历查找会非常慢。</p>
<p>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持 “平衡” 是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于 8 的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p>
<h2 id="linkedhashmap是怎么实现的"><a class="markdownIt-Anchor" href="#linkedhashmap是怎么实现的">#</a> LinkedHashMap 是怎么实现的？</h2>
<p>LinkedHashMap 内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现 LRU 缓存策略。</p>
<p>LinkedHashMap 可以看成是 LinkedList + HashMap。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817171707.png" alt="202105091520406812.png"></p>
<h2 id="linkedhashmap是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#linkedhashmap是有序的吗怎么个有序法">#</a> LinkedHashMap 是有序的吗？怎么个有序法？</h2>
<p>如果 accessOrder 为 false，则可以按插入元素的顺序遍历元素；</p>
<p>如果 accessOrder 为 true，则可以按访问元素的顺序遍历元素；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">   * 双向链表头节点</span><br><span class="line">   */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">   * 双向链表尾节点</span><br><span class="line">   */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">   * 是否按访问顺序排序</span><br><span class="line">   */</span><br><span class="line">   final boolean accessOrder;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LinkedHashMap 通过重写 HashMap 提供的回调方法，从而实现其对<strong>顺序</strong>的特性的处理。同时，因为 LinkedHashMap 的<strong>顺序</strong>特性，需要重写  <code>#keysToArray(T[] a)</code>  等<strong>遍历</strong>相关的方法。</p>
<h2 id="linkedhashmap如何实现lru缓存淘汰策略"><a class="markdownIt-Anchor" href="#linkedhashmap如何实现lru缓存淘汰策略">#</a> LinkedHashMap 如何实现 LRU 缓存淘汰策略？</h2>
<p>首先，我们先来看看 LRU 是个什么鬼。LRU，Least Recently Used，最近最少使用，也就是优先淘汰最近最少使用的元素。</p>
<p>如果使用 LinkedHashMap，我们把 accessOrder 设置为 true 是不是就差不多能实现这个策略了呢？答案是肯定的。请看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class LRUTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个只有5个元素的缓存</span><br><span class="line">        LRU&lt;Integer, Integer&gt; lru = new LRU&lt;&gt;(5, 0.75f);</span><br><span class="line">        lru.put(1, 1);</span><br><span class="line">        lru.put(2, 2);</span><br><span class="line">        lru.put(3, 3);</span><br><span class="line">        lru.put(4, 4);</span><br><span class="line">        lru.put(5, 5);</span><br><span class="line">        lru.put(6, 6);</span><br><span class="line">        lru.put(7, 7);</span><br><span class="line"></span><br><span class="line">        System.out.println(lru.get(4));</span><br><span class="line"></span><br><span class="line">        lru.put(6, 666);</span><br><span class="line"></span><br><span class="line">        // 输出: &#123;3=3, 5=5, 7=7, 4=4, 6=666&#125;</span><br><span class="line">        // 可以看到最旧的元素被删除了</span><br><span class="line">        // 且最近访问的4被移到了后面</span><br><span class="line">        System.out.println(lru);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LRU&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 保存缓存的容量</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    public LRU(int capacity, float loadFactor) &#123;</span><br><span class="line">        super(capacity, loadFactor, true);</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写removeEldestEntry()方法设置何时移除旧元素</span><br><span class="line">     * @param eldest</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        // 当元素个数大于了缓存的容量, 就移除元素</span><br><span class="line">        return size() &gt; this.capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="weakhashmap使用的数据结构"><a class="markdownIt-Anchor" href="#weakhashmap使用的数据结构">#</a> WeakHashMap 使用的数据结构？</h2>
<p>WeakHashMap 因为 gc 的时候会把没有强引用的 key 回收掉，所以注定了它里面的元素不会太多，因此也就不需要像 HashMap 那样元素多的时候转化为红黑树来处理了。</p>
<p>因此，WeakHashMap 的存储结构只有（数组 + 链表）。</p>
<h2 id="weakhashmap具有什么特性"><a class="markdownIt-Anchor" href="#weakhashmap具有什么特性">#</a> WeakHashMap 具有什么特性？</h2>
<p>WeakHashMap 是一种弱引用 map，内部的 key 会存储为弱引用，当 jvm gc 的时候，如果这些 key 没有强引用存在的话，会被 gc 回收掉，下一次当我们操作 map 的时候会把对应的 Entry 整个删除掉，基于这种特性，WeakHashMap 特别适用于缓存处理。</p>
<h2 id="weakhashmap通常用来做什么"><a class="markdownIt-Anchor" href="#weakhashmap通常用来做什么">#</a> WeakHashMap 通常用来做什么？</h2>
<p>任何事物都有他存在的道理，WeakHashmap 业务场景就是缓存，可以有效的节省内存，缓存丢失也不会出太大问题，可以再次获取。许多开源框架，例如 tomcat 等都使用了 weakHashmap 做为缓存处理。</p>
<h2 id="weakhashmap使用string作为key是需要注意些什么为什么"><a class="markdownIt-Anchor" href="#weakhashmap使用string作为key是需要注意些什么为什么">#</a> WeakHashMap 使用 String 作为 key 是需要注意些什么？为什么？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: LvXueYang</span><br><span class="line"> * @creat:2021-08-17 09:29</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class WeakHashMapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = new WeakHashMap&lt;&gt;();</span><br><span class="line">        map.put(new String(&quot;1&quot;), 1);</span><br><span class="line">        map.put(new String(&quot;2&quot;), 2);</span><br><span class="line">        map.put(new String(&quot;3&quot;), 3);</span><br><span class="line"></span><br><span class="line">        // 放入不用new String()声明的字符串</span><br><span class="line">        map.put(&quot;6&quot;, 6);</span><br><span class="line">        String key = null;</span><br><span class="line">        for (String s : map.keySet()) &#123;</span><br><span class="line">            // 这个&quot;3&quot;和new String(&quot;3&quot;)不是一个引用</span><br><span class="line">            if (s.equals(&quot;3&quot;)) &#123;</span><br><span class="line">                key = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        // gc一下</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 放一个new String()声明的字符串</span><br><span class="line">        map.put(new String(&quot;4&quot;), 4);</span><br><span class="line"></span><br><span class="line">        // 输出&#123;4=4, 6=6, 3=3&#125;，gc后放入的值和强引用的key可以打印出来</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        // key与&quot;3&quot;的引用断裂</span><br><span class="line">        key = null;</span><br><span class="line"></span><br><span class="line">        // gc一下</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 输出&#123;6=6&#125;，gc后强引用的key可以打印出来</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="什么是强引用-软引用-弱引用-虚引用"><a class="markdownIt-Anchor" href="#什么是强引用-软引用-弱引用-虚引用">#</a> 什么是强引用、软引用、弱引用、虚引用？</h2>
<p>（1）强引用</p>
<p>使用最普遍的引用。如果一个对象具有强引用，它绝对不会被 gc 回收。如果内存空间不足了，gc 宁愿抛出 OutOfMemoryError，也不是会回收具有强引用的对象。</p>
<p>（2）软引用</p>
<p>如果一个对象只具有软引用，则内存空间足够时不会回收它，但内存空间不够时就会回收这部分对象。只要这个具有软引用对象没有被回收，程序就可以正常使用。</p>
<p>（3）弱引用</p>
<p>如果一个对象只具有弱引用，则不管内存空间够不够，当 gc 扫描到它时就会回收它。</p>
<p>（4）虚引用</p>
<p>如果一个对象只具有虚引用，那么它就和没有任何引用一样，任何时候都可能被 gc 回收。</p>
<p>软（弱、虚）引用必须和一个引用队列（ReferenceQueue）一起使用，当 gc 回收这个软（弱、虚）引用引用的对象时，会把这个软（弱、虚）引用放到这个引用队列中。</p>
<h2 id="红黑树具有哪些特性"><a class="markdownIt-Anchor" href="#红黑树具有哪些特性">#</a> 红黑树具有哪些特性？</h2>
<p>红黑树具有以下 5 种性质：</p>
<p>（1）节点是红色或黑色。</p>
<p>（2）根节点是黑色。</p>
<p>（3）每个叶节点（NIL 节点，空节点）是黑色的。</p>
<p>（4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
<p>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>红黑树的时间复杂度为 O (log n)，与树的高度成正比。</p>
<p>红黑树每次的插入、删除操作都需要做平衡，平衡时有可能会改变根节点的位置，颜色转换，左旋，右旋等</p>
<h2 id="treemap就有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#treemap就有序的吗怎么个有序法">#</a> TreeMap 就有序的吗？怎么个有序法？</h2>
<p>TreeMap 中的元素是有序的，按 key 的顺序排列；</p>
<h2 id="treemap是否需要扩容"><a class="markdownIt-Anchor" href="#treemap是否需要扩容">#</a> TreeMap 是否需要扩容？</h2>
<p>TreeMap 因为采用树结构，所以无需初始考虑像 HashMap 考虑<strong>容量</strong>问题，也不存在扩容问题。</p>
<p>,TreeMap 的存储结构只有一颗红黑树</p>
<h2 id="什么是左旋什么是右旋"><a class="markdownIt-Anchor" href="#什么是左旋什么是右旋">#</a> 什么是左旋？什么是右旋？</h2>
<p>左旋，就是以某个节点为支点向左旋转。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173626.png" alt="202105091520433963.png"></p>
<p>整个左旋过程如下：</p>
<p>（1）将 y 的左节点 设为 x 的右节点，即将 β 设为 x 的右节点；</p>
<p>（2）将 x 设为 y 的左节点的父节点，即将 β 的父节点 设为 x；</p>
<p>（3）将 x 的父节点 设为 y 的父节点；</p>
<p>（4）如果 x 的父节点 为空节点，则将 y 设置为根节点；如果 x 是它父节点的左（右）节点，则将 y 设置为 x 父节点的左（右）节点；</p>
<p>（5）将 x 设为 y 的左节点；</p>
<p>（6）将 x 的父节点 设为 y；</p>
<p>让我们来看看 TreeMap 中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">   * 以p为支点进行左旋</span><br><span class="line">   * 假设p为图中的x</span><br><span class="line">   */</span><br><span class="line">  private void rotateLeft(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">      if (p != null) &#123;</span><br><span class="line">          // p的右节点，即y</span><br><span class="line">          Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">  </span><br><span class="line">          // （1）将 y的左节点 设为 x的右节点</span><br><span class="line">          p.right = r.left;</span><br><span class="line">  </span><br><span class="line">          // （2）将 x 设为 y的左节点的父节点（如果y的左节点存在的话）</span><br><span class="line">          if (r.left != null)</span><br><span class="line">              r.left.parent = p;</span><br><span class="line">  </span><br><span class="line">          // （3）将 x的父节点 设为 y的父节点</span><br><span class="line">          r.parent = p.parent;</span><br><span class="line">  </span><br><span class="line">          // （4）...</span><br><span class="line">          if (p.parent == null)</span><br><span class="line">              // 如果 x的父节点 为空，则将y设置为根节点</span><br><span class="line">              root = r;</span><br><span class="line">          else if (p.parent.left == p)</span><br><span class="line">              // 如果x是它父节点的左节点，则将y设置为x父节点的左节点</span><br><span class="line">              p.parent.left = r;</span><br><span class="line">          else</span><br><span class="line">              // 如果x是它父节点的右节点，则将y设置为x父节点的右节点</span><br><span class="line">              p.parent.right = r;</span><br><span class="line">  </span><br><span class="line">          // （5）将 x 设为 y的左节点</span><br><span class="line">          r.left = p;</span><br><span class="line">  </span><br><span class="line">          // （6）将 x的父节点 设为 y</span><br><span class="line">          p.parent = r;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>右旋，就是以某个节点为支点向右旋转。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173656.png" alt="202105091520436904.png"></p>
<p>整个右旋过程如下：</p>
<p>（1）将 x 的右节点 设为 y 的左节点，即 将 β 设为 y 的左节点；</p>
<p>（2）将 y 设为 x 的右节点的父节点，即 将 β 的父节点 设为 y；</p>
<p>（3）将 y 的父节点 设为 x 的父节点；</p>
<p>（4）如果 y 的父节点 是 空节点，则将 x 设为根节点；如果 y 是它父节点的左（右）节点，则将 x 设为 y 的父节点的左（右）节点；</p>
<p>（5）将 y 设为 x 的右节点；</p>
<p>（6）将 y 的父节点 设为 x；</p>
<p>让我们来看看 TreeMap 中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">    * 以p为支点进行右旋</span><br><span class="line">    * 假设p为图中的y</span><br><span class="line">    */</span><br><span class="line">   private void rotateRight(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">       if (p != null) &#123;</span><br><span class="line">           // p的左节点，即x</span><br><span class="line">           Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">   </span><br><span class="line">           // （1）将 x的右节点 设为 y的左节点</span><br><span class="line">           p.left = l.right;</span><br><span class="line">   </span><br><span class="line">           // （2）将 y 设为 x的右节点的父节点（如果x有右节点的话）</span><br><span class="line">           if (l.right != null) l.right.parent = p;</span><br><span class="line">   </span><br><span class="line">           // （3）将 y的父节点 设为 x的父节点</span><br><span class="line">           l.parent = p.parent;</span><br><span class="line">   </span><br><span class="line">           // （4）...</span><br><span class="line">           if (p.parent == null)</span><br><span class="line">               // 如果 y的父节点 是 空节点，则将x设为根节点</span><br><span class="line">               root = l;</span><br><span class="line">           else if (p.parent.right == p)</span><br><span class="line">               // 如果y是它父节点的右节点，则将x设为y的父节点的右节点</span><br><span class="line">               p.parent.right = l;</span><br><span class="line">           else</span><br><span class="line">               // 如果y是它父节点的左节点，则将x设为y的父节点的左节点</span><br><span class="line">               p.parent.left = l;</span><br><span class="line">   </span><br><span class="line">           // （5）将 y 设为 x的右节点</span><br><span class="line">           l.right = p;</span><br><span class="line">   </span><br><span class="line">           // （6）将 y的父节点 设为 x</span><br><span class="line">           p.parent = l;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="红黑树怎么插入元素"><a class="markdownIt-Anchor" href="#红黑树怎么插入元素">#</a> 红黑树怎么插入元素？</h2>
<p>插入元素，如果元素在树中存在，则替换 value；如果元素不存在，则插入到对应的位置，再平衡树。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">     Entry&lt;K,V&gt; t = root;</span><br><span class="line">     if (t == null) &#123;</span><br><span class="line">         // 如果没有根节点，直接插入到根节点</span><br><span class="line">         compare(key, key); // type (and possibly null) check</span><br><span class="line">         root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">         size = 1;</span><br><span class="line">         modCount++;</span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br><span class="line">     // key比较的结果</span><br><span class="line">     int cmp;</span><br><span class="line">     // 用来寻找待插入节点的父节点</span><br><span class="line">     Entry&lt;K,V&gt; parent;</span><br><span class="line">     // 根据是否有comparator使用不同的分支</span><br><span class="line">     Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">     if (cpr != null) &#123;</span><br><span class="line">         // 如果使用的是comparator方式，key值可以为null，只要在comparator.compare()中允许即可</span><br><span class="line">         // 从根节点开始遍历寻找</span><br><span class="line">         do &#123;</span><br><span class="line">             parent = t;</span><br><span class="line">             cmp = cpr.compare(key, t.key);</span><br><span class="line">             if (cmp &lt; 0)</span><br><span class="line">                 // 如果小于0从左子树寻找</span><br><span class="line">                 t = t.left;</span><br><span class="line">             else if (cmp &gt; 0)</span><br><span class="line">                 // 如果大于0从右子树寻找</span><br><span class="line">                 t = t.right;</span><br><span class="line">             else</span><br><span class="line">                 // 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span><br><span class="line">                 return t.setValue(value);</span><br><span class="line">         &#125; while (t != null);</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         // 如果使用的是Comparable方式，key不能为null</span><br><span class="line">         if (key == null)</span><br><span class="line">             throw new NullPointerException();</span><br><span class="line">         @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">         Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">         // 从根节点开始遍历寻找</span><br><span class="line">         do &#123;</span><br><span class="line">             parent = t;</span><br><span class="line">             cmp = k.compareTo(t.key);</span><br><span class="line">             if (cmp &lt; 0)</span><br><span class="line">                 // 如果小于0从左子树寻找</span><br><span class="line">                 t = t.left;</span><br><span class="line">             else if (cmp &gt; 0)</span><br><span class="line">                 // 如果大于0从右子树寻找</span><br><span class="line">                 t = t.right;</span><br><span class="line">             else</span><br><span class="line">                 // 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span><br><span class="line">                 return t.setValue(value);</span><br><span class="line">         &#125; while (t != null);</span><br><span class="line">     &#125;</span><br><span class="line">     // 如果没找到，那么新建一个节点，并插入到树中</span><br><span class="line">     Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">     if (cmp &lt; 0)</span><br><span class="line">         // 如果小于0插入到左子节点</span><br><span class="line">         parent.left = e;</span><br><span class="line">     else</span><br><span class="line">         // 如果大于0插入到右子节点</span><br><span class="line">         parent.right = e;</span><br><span class="line"> </span><br><span class="line">     // 插入之后的平衡</span><br><span class="line">     fixAfterInsertion(e);</span><br><span class="line">     // 元素个数加1（不需要扩容）</span><br><span class="line">     size++;</span><br><span class="line">     // 修改次数加1</span><br><span class="line">     modCount++;</span><br><span class="line">     // 如果插入了新节点返回空</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="插入再平衡"><a class="markdownIt-Anchor" href="#插入再平衡">#</a> 插入再平衡</h3>
<p>插入的元素默认都是红色，因为插入红色元素只违背了第 4 条特性，那么我们只要根据这个特性来平衡就容易多了。</p>
<p>根据不同的情况有以下几种处理方式：</p>
<ol>
<li>插入的元素如果是根节点，则直接涂成黑色即可，不用平衡；</li>
<li>插入的元素的父节点如果为黑色，不需要平衡；</li>
<li>插入的元素的父节点如果为红色，则违背了特性 4，需要平衡，平衡时又分成下面三种情况：</li>
</ol>
<p><strong>（如果父节点是祖父节点的左节点）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>1）父节点为红色，叔叔节点也为红色</td>
<td>（1）将父节点设为黑色；（2）将叔叔节点设为黑色；（3）将祖父节点设为红色；（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td>
</tr>
<tr>
<td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td>
<td>（1）将父节点作为新的当前节点；（2）以新当节点为支点进行左旋，进入情况 3）；</td>
</tr>
<tr>
<td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td>
<td>（1）将父节点设为黑色；（2）将祖父节点设为红色；（3）以祖父节点为支点进行右旋，进入下一次循环判断；</td>
</tr>
</tbody>
</table>
<p><strong>（如果父节点是祖父节点的右节点，则正好与上面反过来）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>1）父节点为红色，叔叔节点也为红色</td>
<td>（1）将父节点设为黑色；（2）将叔叔节点设为黑色；（3）将祖父节点设为红色；（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td>
</tr>
<tr>
<td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td>
<td>（1）将父节点作为新的当前节点；（2）以新当节点为支点进行右旋；</td>
</tr>
<tr>
<td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td>
<td>（1）将父节点设为黑色；（2）将祖父节点设为红色；（3）以祖父节点为支点进行左旋，进入下一次循环判断；</td>
</tr>
</tbody>
</table>
<p>让我们来看看 TreeMap 中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">    * 插入再平衡</span><br><span class="line">    *（1）每个节点或者是黑色，或者是红色。</span><br><span class="line">    *（2）根节点是黑色。</span><br><span class="line">    *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span><br><span class="line">    *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line">    *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span><br><span class="line">    */</span><br><span class="line">   private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123;</span><br><span class="line">       // 插入的节点为红节点，x为当前节点</span><br><span class="line">       x.color = RED;</span><br><span class="line">   </span><br><span class="line">       // 只有当插入节点不是根节点且其父节点为红色时才需要平衡（违背了特性4）</span><br><span class="line">       while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">           if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">               // a）如果父节点是祖父节点的左节点</span><br><span class="line">               // y为叔叔节点</span><br><span class="line">               Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">               if (colorOf(y) == RED) &#123;</span><br><span class="line">                   // 情况1）如果叔叔节点为红色</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将叔叔节点设为黑色</span><br><span class="line">                   setColor(y, BLACK);</span><br><span class="line">                   // （3）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （4）将祖父节点设为新的当前节点</span><br><span class="line">                   x = parentOf(parentOf(x));</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // 如果叔叔节点为黑色</span><br><span class="line">                   // 情况2）如果当前节点为其父节点的右节点</span><br><span class="line">                   if (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                       // （1）将父节点设为当前节点</span><br><span class="line">                       x = parentOf(x);</span><br><span class="line">                       // （2）以新当前节点左旋</span><br><span class="line">                       rotateLeft(x);</span><br><span class="line">                   &#125;</span><br><span class="line">                   // 情况3）如果当前节点为其父节点的左节点（如果是情况2）则左旋之后新当前节点正好为其父节点的左节点了）</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （3）以祖父节点为支点进行右旋</span><br><span class="line">                   rotateRight(parentOf(parentOf(x)));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // b）如果父节点是祖父节点的右节点</span><br><span class="line">               // y是叔叔节点</span><br><span class="line">               Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">               if (colorOf(y) == RED) &#123;</span><br><span class="line">                   // 情况1）如果叔叔节点为红色</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将叔叔节点设为黑色</span><br><span class="line">                   setColor(y, BLACK);</span><br><span class="line">                   // （3）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （4）将祖父节点设为新的当前节点</span><br><span class="line">                   x = parentOf(parentOf(x));</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // 如果叔叔节点为黑色</span><br><span class="line">                   // 情况2）如果当前节点为其父节点的左节点</span><br><span class="line">                   if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                       // （1）将父节点设为当前节点</span><br><span class="line">                       x = parentOf(x);</span><br><span class="line">                       // （2）以新当前节点右旋</span><br><span class="line">                       rotateRight(x);</span><br><span class="line">                   &#125;</span><br><span class="line">                   // 情况3）如果当前节点为其父节点的右节点（如果是情况2）则右旋之后新当前节点正好为其父节点的右节点了）</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （3）以祖父节点为支点进行左旋</span><br><span class="line">                   rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 平衡完成后将根节点设为黑色</span><br><span class="line">       root.color = BLACK;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="红黑树怎么删除元素"><a class="markdownIt-Anchor" href="#红黑树怎么删除元素">#</a> 红黑树怎么删除元素？</h2>
<p>删除元素本身比较简单，就是采用二叉树的删除规则。</p>
<p>（1）如果删除的位置有两个叶子节点，则从其右子树中取最小的元素放到删除的位置，然后把删除位置移到替代元素的位置，进入下一步。</p>
<p>（2）如果删除的位置只有一个叶子节点（有可能是经过第一步转换后的删除位置），则把那个叶子节点作为替代元素，放到删除的位置，然后把这个叶子节点删除。</p>
<p>（3）如果删除的位置没有叶子节点，则直接把这个删除位置的元素删除即可。</p>
<p>（4）针对红黑树，如果删除位置是黑色节点，还需要做再平衡。</p>
<p>（5）如果有替代元素，则以替代元素作为当前节点进入再平衡。</p>
<p>（6）如果没有替代元素，则以删除的位置的元素作为当前节点进入再平衡，平衡之后再删除这个节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">       // 获取节点</span><br><span class="line">       Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">       if (p == null)</span><br><span class="line">           return null;</span><br><span class="line">   </span><br><span class="line">       V oldValue = p.value;</span><br><span class="line">       // 删除节点</span><br><span class="line">       deleteEntry(p);</span><br><span class="line">       // 返回删除的value</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private void deleteEntry(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">       // 修改次数加1</span><br><span class="line">       modCount++;</span><br><span class="line">       // 元素个数减1</span><br><span class="line">       size--;</span><br><span class="line">   </span><br><span class="line">       if (p.left != null &amp;&amp; p.right != null) &#123;</span><br><span class="line">           // 如果当前节点既有左子节点，又有右子节点</span><br><span class="line">           // 取其右子树中最小的节点</span><br><span class="line">           Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">           // 用右子树中最小节点的值替换当前节点的值</span><br><span class="line">           p.key = s.key;</span><br><span class="line">           p.value = s.value;</span><br><span class="line">           // 把右子树中最小节点设为当前节点</span><br><span class="line">           p = s;</span><br><span class="line">           // 这种情况实际上并没有删除p节点，而是把p节点的值改了，实际删除的是p的后继节点</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 如果原来的当前节点（p）有2个子节点，则当前节点已经变成原来p的右子树中的最小节点了，也就是说其没有左子节点了</span><br><span class="line">       // 到这一步，p肯定只有一个子节点了</span><br><span class="line">       // 如果当前节点有子节点，则用子节点替换当前节点</span><br><span class="line">       Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);</span><br><span class="line">   </span><br><span class="line">       if (replacement != null) &#123;</span><br><span class="line">           // 把替换节点直接放到当前节点的位置上（相当于删除了p，并把替换节点移动过来了）</span><br><span class="line">           replacement.parent = p.parent;</span><br><span class="line">           if (p.parent == null)</span><br><span class="line">               root = replacement;</span><br><span class="line">           else if (p == p.parent.left)</span><br><span class="line">               p.parent.left  = replacement;</span><br><span class="line">           else</span><br><span class="line">               p.parent.right = replacement;</span><br><span class="line">   </span><br><span class="line">           // 将p的各项属性都设为空</span><br><span class="line">           p.left = p.right = p.parent = null;</span><br><span class="line">   </span><br><span class="line">           // 如果p是黑节点，则需要再平衡</span><br><span class="line">           if (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(replacement);</span><br><span class="line">       &#125; else if (p.parent == null) &#123;</span><br><span class="line">           // 如果当前节点就是根节点，则直接将根节点设为空即可</span><br><span class="line">           root = null;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // 如果当前节点没有子节点且其为黑节点，则把自己当作虚拟的替换节点进行再平衡</span><br><span class="line">           if (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(p);</span><br><span class="line">   </span><br><span class="line">           // 平衡完成后删除当前节点（与父节点断绝关系）</span><br><span class="line">           if (p.parent != null) &#123;</span><br><span class="line">               if (p == p.parent.left)</span><br><span class="line">                   p.parent.left = null;</span><br><span class="line">               else if (p == p.parent.right)</span><br><span class="line">                   p.parent.right = null;</span><br><span class="line">               p.parent = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>经过上面的处理，真正删除的肯定是黑色节点才会进入到再平衡阶段。</p>
<p>因为删除的是黑色节点，导致整颗树不平衡了，所以这里我们假设把删除的黑色赋予当前节点，这样当前节点除了它自已的颜色还多了一个黑色，那么：</p>
<p>（1）如果当前节点是根节点，则直接涂黑即可，不需要再平衡；</p>
<p>（2）如果当前节点是红 + 黑节点，则直接涂黑即可，不需要平衡；</p>
<p>（3）如果当前节点是黑 + 黑节点，则我们只要通过旋转把这个多出来的黑色不断的向上传递到一个红色节点即可，这又可能会出现以下四种情况：</p>
<p><strong>（假设当前节点为父节点的左子节点）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>1）x 是黑 + 黑节点，x 的兄弟是红节点</td>
<td>（1）将兄弟节点设为黑色；（2）将父节点设为红色；（3）以父节点为支点进行左旋；（4）重新设置 x 的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>2）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td>
<td>（1）将兄弟节点设置为红色；（2）将 x 的父节点作为新的当前节点，进入下一次循环；</td>
</tr>
<tr>
<td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的右子节点为黑色，左子节点为红色</td>
<td>（1）将兄弟节点的左子节点设为黑色；（2）将兄弟节点设为红色；（3）以兄弟节点为支点进行右旋；（4）重新设置 x 的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的右子节点为红色，左子节点任意颜色</td>
<td>（1）将兄弟节点的颜色设为父节点的颜色；（2）将父节点设为黑色；（3）将兄弟节点的右子节点设为黑色；（4）以父节点为支点进行左旋；（5）将 root 作为新的当前节点（退出循环）；</td>
</tr>
</tbody>
</table>
<p><strong>（假设当前节点为父节点的右子节点，正好反过来）</strong></p>
<table>
<thead>
<tr>
<th>情况</th>
<th>策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>1）x 是黑 + 黑节点，x 的兄弟是红节点</td>
<td>（1）将兄弟节点设为黑色；（2）将父节点设为红色；（3）以父节点为支点进行右旋；（4）重新设置 x 的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>2）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td>
<td>（1）将兄弟节点设置为红色；（2）将 x 的父节点作为新的当前节点，进入下一次循环；</td>
</tr>
<tr>
<td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的左子节点为黑色，右子节点为红色</td>
<td>（1）将兄弟节点的右子节点设为黑色；（2）将兄弟节点设为红色；（3）以兄弟节点为支点进行左旋；（4）重新设置 x 的兄弟节点，进入下一步；</td>
</tr>
<tr>
<td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的左子节点为红色，右子节点任意颜色</td>
<td>（1）将兄弟节点的颜色设为父节点的颜色；（2）将父节点设为黑色；（3）将兄弟节点的左子节点设为黑色；（4）以父节点为支点进行右旋；（5）将 root 作为新的当前节点（退出循环）；</td>
</tr>
</tbody>
</table>
<p>让我们来看看 TreeMap 中的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">     * 删除再平衡</span><br><span class="line">     *（1）每个节点或者是黑色，或者是红色。</span><br><span class="line">     *（2）根节点是黑色。</span><br><span class="line">     *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span><br><span class="line">     *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line">     *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span><br><span class="line">*/</span><br><span class="line">private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123;</span><br><span class="line">        // 只有当前节点不是根节点且当前节点是黑色时才进入循环</span><br><span class="line">        while (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">            if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                // 如果当前节点是其父节点的左子节点</span><br><span class="line">                // sib是当前节点的兄弟节点</span><br><span class="line">                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">    </span><br><span class="line">                // 情况1）如果兄弟节点是红色</span><br><span class="line">                if (colorOf(sib) == RED) &#123;</span><br><span class="line">                    // （1）将兄弟节点设为黑色</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    // （2）将父节点设为红色</span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    // （3）以父节点为支点进行左旋</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    // （4）重新设置x的兄弟节点，进入下一步</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                if (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                        colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    // 情况2）如果兄弟节点的两个子节点都是黑色</span><br><span class="line">                    // （1）将兄弟节点设置为红色</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    // （2）将x的父节点作为新的当前节点，进入下一次循环</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                        // 情况3）如果兄弟节点的右子节点为黑色</span><br><span class="line">                        // （1）将兄弟节点的左子节点设为黑色</span><br><span class="line">                        setColor(leftOf(sib), BLACK);</span><br><span class="line">                        // （2）将兄弟节点设为红色</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        // （3）以兄弟节点为支点进行右旋</span><br><span class="line">                        rotateRight(sib);</span><br><span class="line">                        // （4）重新设置x的兄弟节点</span><br><span class="line">                        sib = rightOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 情况4）</span><br><span class="line">                    // （1）将兄弟节点的颜色设为父节点的颜色</span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    // （2）将父节点设为黑色</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    // （3）将兄弟节点的右子节点设为黑色</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    // （4）以父节点为支点进行左旋</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    // （5）将root作为新的当前节点（退出循环）</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // symmetric</span><br><span class="line">                // 如果当前节点是其父节点的右子节点</span><br><span class="line">                // sib是当前节点的兄弟节点</span><br><span class="line">                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">    </span><br><span class="line">                // 情况1）如果兄弟节点是红色</span><br><span class="line">                if (colorOf(sib) == RED) &#123;</span><br><span class="line">                    // （1）将兄弟节点设为黑色</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    // （2）将父节点设为红色</span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    // （3）以父节点为支点进行右旋</span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    // （4）重新设置x的兄弟节点</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                if (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                        colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    // 情况2）如果兄弟节点的两个子节点都是黑色</span><br><span class="line">                    // （1）将兄弟节点设置为红色</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    // （2）将x的父节点作为新的当前节点，进入下一次循环</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                        // 情况3）如果兄弟节点的左子节点为黑色</span><br><span class="line">                        // （1）将兄弟节点的右子节点设为黑色</span><br><span class="line">                        setColor(rightOf(sib), BLACK);</span><br><span class="line">                        // （2）将兄弟节点设为红色</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        // （3）以兄弟节点为支点进行左旋</span><br><span class="line">                        rotateLeft(sib);</span><br><span class="line">                        // （4）重新设置x的兄弟节点</span><br><span class="line">                        sib = leftOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 情况4）</span><br><span class="line">                    // （1）将兄弟节点的颜色设为父节点的颜色</span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    // （2）将父节点设为黑色</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    // （3）将兄弟节点的左子节点设为黑色</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    // （4）以父节点为支点进行右旋</span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    // （5）将root作为新的当前节点（退出循环）</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 退出条件为多出来的黑色向上传递到了根节点或者红节点</span><br><span class="line">        // 则将x设为黑色即可满足红黑树规则</span><br><span class="line">        setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="为什么要进行平衡"><a class="markdownIt-Anchor" href="#为什么要进行平衡">#</a> 为什么要进行平衡？</h2>
<p>因为违背了红黑树的性质，必须保证红黑树的五大性质。</p>
<p>（1）节点是红色或黑色。</p>
<p>（2）根节点是黑色。</p>
<p>（3）每个叶节点（NIL 节点，空节点）是黑色的。</p>
<p>（4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>
<p>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<h2 id="如何实现红黑树的遍历"><a class="markdownIt-Anchor" href="#如何实现红黑树的遍历">#</a> 如何实现红黑树的遍历？</h2>
<p>（1）从 root 遍历整个树；</p>
<p>（2）如果待查找的 key 比当前遍历的 key 小，则在其左子树中查找；</p>
<p>（3）如果待查找的 key 比当前遍历的 key 大，则在其右子树中查找；</p>
<p>（4）如果待查找的 key 与当前遍历的 key 相等，则找到了该元素，直接返回；</p>
<p>（5）从这里可以看出是否有 comparator 分化成了两个方法，但是内部逻辑一模一样，因此可见笔者 <code>comparator = (k1, k2) -&gt; ((Comparable&lt;? super K&gt;)k1).compareTo(k2);</code>  这种改造的必要性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">        // 根据key查找元素</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        // 找到了返回value值，没找到返回null</span><br><span class="line">        return (p==null ? null : p.value);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">        // 如果comparator不为空，使用comparator的版本获取元素</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            return getEntryUsingComparator(key);</span><br><span class="line">        // 如果key为空返回空指针异常</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        // 将key强转为Comparable</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">        // 从根元素开始遍历</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            int cmp = k.compareTo(p.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                // 如果小于0从左子树查找</span><br><span class="line">                p = p.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                // 如果大于0从右子树查找</span><br><span class="line">                p = p.right;</span><br><span class="line">            else</span><br><span class="line">                // 如果相等说明找到了直接返回</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没找到返回null</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K k = (K) key;</span><br><span class="line">        Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">        if (cpr != null) &#123;</span><br><span class="line">            // 从根元素开始遍历</span><br><span class="line">            Entry&lt;K,V&gt; p = root;</span><br><span class="line">            while (p != null) &#123;</span><br><span class="line">                int cmp = cpr.compare(k, p.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    // 如果小于0从左子树查找</span><br><span class="line">                    p = p.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    // 如果大于0从右子树查找</span><br><span class="line">                    p = p.right;</span><br><span class="line">                else</span><br><span class="line">                    // 如果相等说明找到了直接返回</span><br><span class="line">                    return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没找到返回null</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="treemap为什么不允许key为null"><a class="markdownIt-Anchor" href="#treemap为什么不允许key为null">#</a> TreeMap 为什么不允许 key 为 null?</h2>
<p>TreeMap 的 <strong>key</strong> 不允许为空 (  <code>null</code>  )，可能是因为红黑树是一颗二叉查找树，需要对 key 进行排序。</p>
<h2 id="treemap中是怎么遍历的"><a class="markdownIt-Anchor" href="#treemap中是怎么遍历的">#</a> TreeMap 中是怎么遍历的？</h2>
<h2 id="treemap插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#treemap插入-删除-查询元素的时间复杂度各是多少">#</a> TreeMap 插入、删除、查询元素的时间复杂度各是多少？</h2>
<p>TreeMap 的查找、添加、删除 key-value 键值对的<strong>平均</strong>时间复杂度为  <code>O(logN)</code>  。原因是，TreeMap 采用红黑树，操作都需要经过二分查找，而二分查找的时间复杂度是  <code>O(logN)</code>  。</p>
<h2 id="hashmap在多线程环境中什么时候会出现问题"><a class="markdownIt-Anchor" href="#hashmap在多线程环境中什么时候会出现问题">#</a> HashMap 在多线程环境中什么时候会出现问题？</h2>
<p>在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，下面举例子说明在并发的多线程使用场景中使用 HashMap 可能造成死循环。代码例子如下 (便于理解，仍然使用 JDK1.7 的环境)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class HashMapInfiniteLoop &#123;  </span><br><span class="line"></span><br><span class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f);  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        map.put(5， &quot;C&quot;);  </span><br><span class="line"></span><br><span class="line">        new Thread(&quot;Thread1&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(7, &quot;B&quot;);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        new Thread(&quot;Thread2&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(3, &quot;A);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，map 初始化为一个长度为 2 的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当 put 第二个 key 的时候，map 就需要进行 resize。</p>
<p>通过设置断点让线程 1 和线程 2 同时 debug 到 transfer 方法 (3.3 小节代码块) 的首行。注意此时两个线程已经成功添加数据。放开 thread1 的断点至 transfer 方法的 “Entry next = e.next;” 这一行；然后放开线程 2 的的断点，让线程 2 进行 resize。结果如下图。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173358.png" alt="img"></p>
<p>注意，Thread1 的 e 指向了 key (3)，而 next 指向了 key (7)，其在线程二 rehash 后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe [i] = e， 然后是 e = next，导致了 e 指向了 key (7)，而下一次循环的 next = e.next 导致了 next 指向了 key (3)。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173416.png" alt="img"></p>
<p>于是，当我们用线程一调用 map.get (11) 时，悲剧就出现了 ——Infinite Loop。</p>
<h2 id="concurrenthashmap的存储结构"><a class="markdownIt-Anchor" href="#concurrenthashmap的存储结构">#</a> ConcurrentHashMap 的存储结构？</h2>
<p>ConcurrentHashMap 采用（数组 + 链表 + 红黑树）的结构存储元素；</p>
<h2 id="concurrenthashmap是怎么保证并发安全的"><a class="markdownIt-Anchor" href="#concurrenthashmap是怎么保证并发安全的">#</a> ConcurrentHashMap 是怎么保证并发安全的？</h2>
<p>ConcurrentHashMap 采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile 等</p>
<h2 id="concurrenthashmap是怎么扩容的"><a class="markdownIt-Anchor" href="#concurrenthashmap是怎么扩容的">#</a> ConcurrentHashMap 是怎么扩容的？</h2>
<p>1. 每次添加元素后，元素数量加 1，并判断是否达到扩容门槛，达到了则进行扩容或协助扩容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        // 这里使用的思想跟LongAdder类是一模一样的（后面会讲）</span><br><span class="line">        // 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想）</span><br><span class="line">        // 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段</span><br><span class="line">        // 这样可以保证尽量小的减少冲突</span><br><span class="line">    </span><br><span class="line">        // 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上</span><br><span class="line">        if ((as = counterCells) != null ||</span><br><span class="line">                !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            boolean uncontended = true;</span><br><span class="line">            // 如果as为空</span><br><span class="line">            // 或者长度为0</span><br><span class="line">            // 或者当前线程所在的段为null</span><br><span class="line">            // 或者在当前线程的段上加数量失败</span><br><span class="line">            if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">                    (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">                    !(uncontended =</span><br><span class="line">                            U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                // 强制增加数量（无论如何数量是一定要加上的，并不是简单地自旋）</span><br><span class="line">                // 不同线程对应不同的段都更新失败了</span><br><span class="line">                // 说明已经发生冲突了，那么就对counterCells进行扩容</span><br><span class="line">                // 以减少多个线程hash到同一个段的概率</span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;= 1)</span><br><span class="line">                return;</span><br><span class="line">            // 计算元素个数</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;= 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            // 如果元素个数达到了扩容门槛，则进行扩容</span><br><span class="line">            // 注意，正常情况下sizeCtl存储的是扩容门槛，即容量的0.75倍</span><br><span class="line">            while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">                    (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                // rs是扩容时的一个邮戳标识</span><br><span class="line">                int rs = resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    // sc&lt;0说明正在扩容中</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                            transferIndex &lt;= 0)</span><br><span class="line">                        // 扩容已经完成了，退出循环</span><br><span class="line">                        // 正常应该只会触发nextTable==null这个条件，其它条件没看出来何时触发</span><br><span class="line">                        break;</span><br><span class="line">    </span><br><span class="line">                    // 扩容未完成，则当前线程加入迁移元素中</span><br><span class="line">                    // 并把扩容线程数加1</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                        (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    // 这里是触发扩容的那个线程进入的地方</span><br><span class="line">                    // sizeCtl的高16位存储着rs这个扩容邮戳</span><br><span class="line">                    // sizeCtl的低16位存储着扩容线程数加1，即(1+nThreads)</span><br><span class="line">                    // 所以官方说的扩容时sizeCtl的值为 -(1+nThreads)是错误的</span><br><span class="line">    </span><br><span class="line">                    // 进入迁移元素</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                // 重新计算元素个数</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）元素个数的存储方式类似于 LongAdder 类，存储在不同的段上，减少不同线程同时更新 size 时的冲突；</p>
<p>（2）计算元素个数时把这些段的值及 baseCount 相加算出总的元素个数；</p>
<p>（3）正常情况下 sizeCtl 存储着扩容门槛，扩容门槛为容量的 0.75 倍；</p>
<p>（4）扩容时 sizeCtl 高位存储扩容邮戳 (resizeStamp)，低位存储扩容线程数加 1（1+nThreads）；</p>
<p>（5）其它线程添加元素后如果发现存在扩容，也会加入的扩容行列中来；</p>
<p>2. 线程添加元素时发现正在扩容且当前元素所在的桶元素已经迁移完成了，则协助迁移其它桶的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        // 如果桶数组不为空，并且当前桶第一个元素为ForwardingNode类型，并且nextTab不为空</span><br><span class="line">        // 说明当前桶已经迁移完毕了，才去帮忙迁移其它桶的元素</span><br><span class="line">        // 扩容时会把旧桶的第一个元素置为ForwardingNode，并让其nextTab指向新桶数组</span><br><span class="line">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">                (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">            int rs = resizeStamp(tab.length);</span><br><span class="line">            // sizeCtl&lt;0，说明正在扩容</span><br><span class="line">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                    (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                // 扩容线程数加1</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                    // 当前线程帮忙迁移元素</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前桶元素迁移完成了才去协助迁移其它桶元素；</p>
<p>3. 扩容时容量变为两倍，并把部分元素迁移到其它桶中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">        int n = tab.length, stride;</span><br><span class="line">        if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">        if (nextTab == null) &#123;            // initiating</span><br><span class="line">            // 如果nextTab为空，说明还没开始迁移</span><br><span class="line">            // 就新建一个新桶数组</span><br><span class="line">            try &#123;</span><br><span class="line">                // 新桶数组是原桶的两倍</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        // 新桶数组大小</span><br><span class="line">        int nextn = nextTab.length;</span><br><span class="line">        // 新建一个ForwardingNode类型的节点，并把新桶数组存储在里面</span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        boolean advance = true;</span><br><span class="line">        boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">        for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int fh;</span><br><span class="line">            // 整个while循环就是在算i的值，过程太复杂，不用太关心</span><br><span class="line">            // i的值会从n-1依次递减，感兴趣的可以打下断点就知道了</span><br><span class="line">            // 其中n是旧桶数组的大小，也就是说i从15开始一直减到1这样去迁移元素</span><br><span class="line">            while (advance) &#123;</span><br><span class="line">                int nextIndex, nextBound;</span><br><span class="line">                if (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = false;</span><br><span class="line">                else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    advance = false;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt</span><br><span class="line">                        (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                                nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                        nextIndex - stride : 0))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - 1;</span><br><span class="line">                    advance = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                // 如果一次遍历完成了</span><br><span class="line">                // 也就是整个map所有桶中的元素都迁移完成了</span><br><span class="line">                int sc;</span><br><span class="line">                if (finishing) &#123;</span><br><span class="line">                    // 如果全部迁移完成了，则替换旧桶数组</span><br><span class="line">                    // 并设置下一次扩容门槛为新桶数组容量的0.75倍</span><br><span class="line">                    nextTable = null;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                    // 当前线程扩容完成，把扩容线程数-1</span><br><span class="line">                    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        // 扩容完成两边肯定相等</span><br><span class="line">                        return;</span><br><span class="line">                    // 把finishing设置为true</span><br><span class="line">                    // finishing为true才会走到上面的if条件</span><br><span class="line">                    finishing = advance = true;</span><br><span class="line">                    // i重新赋值为n</span><br><span class="line">                    // 这样会再重新遍历一次桶数组，看看是不是都迁移完成了</span><br><span class="line">                    // 也就是第二次遍历都会走到下面的(fh = f.hash) == MOVED这个条件</span><br><span class="line">                    i = n; // recheck before commit</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">                // 如果桶中无数据，直接放入ForwardingNode标记该桶已迁移</span><br><span class="line">                advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">            else if ((fh = f.hash) == MOVED)</span><br><span class="line">                // 如果桶中第一个元素的hash值为MOVED</span><br><span class="line">                // 说明它是ForwardingNode节点</span><br><span class="line">                // 也就是该桶已迁移</span><br><span class="line">                advance = true; // already processed</span><br><span class="line">            else &#123;</span><br><span class="line">                // 锁定该桶并迁移元素</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    // 再次判断当前桶第一个元素是否有修改</span><br><span class="line">                    // 也就是可能其它线程先一步迁移了元素</span><br><span class="line">                    if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        // 把一个链表分化成两个链表</span><br><span class="line">                        // 规则是桶中各元素的hash与桶大小n进行与操作</span><br><span class="line">                        // 等于0的放到低位链表(low)中，不等于0的放到高位链表(high)中</span><br><span class="line">                        // 其中低位链表迁移到新桶中的位置相对旧桶不变</span><br><span class="line">                        // 高位链表迁移到新桶中位置正好是其在旧桶的位置加n</span><br><span class="line">                        // 这也正是为什么扩容时容量在变成两倍的原因</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        if (fh &gt;= 0) &#123;</span><br><span class="line">                            // 第一个元素的hash值大于等于0</span><br><span class="line">                            // 说明该桶中元素是以链表形式存储的</span><br><span class="line">                            // 这里与HashMap迁移算法基本类似</span><br><span class="line">                            // 唯一不同的是多了一步寻找lastRun</span><br><span class="line">                            // 这里的lastRun是提取出链表后面不用处理再特殊处理的子链表</span><br><span class="line">                            // 比如所有元素的hash值与桶大小n与操作后的值分别为 0 0 4 4 0 0 0</span><br><span class="line">                            // 则最后后面三个0对应的元素肯定还是在同一个桶中</span><br><span class="line">                            // 这时lastRun对应的就是倒数第三个节点</span><br><span class="line">                            // 至于为啥要这样处理，我也没太搞明白</span><br><span class="line">                            int runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                                int b = p.hash &amp; n;</span><br><span class="line">                                if (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 看看最后这几个元素归属于低位链表还是高位链表</span><br><span class="line">                            if (runBit == 0) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = null;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = null;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 遍历链表，把hash&amp;n为0的放在低位链表中</span><br><span class="line">                            // 不为0的放在高位链表中</span><br><span class="line">                            for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                if ((ph &amp; n) == 0)</span><br><span class="line">                                    ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                else</span><br><span class="line">                                    hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 低位链表的位置不变</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            // 高位链表的位置是原位置加n</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            // 标记当前桶已迁移</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            // advance为true，返回上面进行--i操作</span><br><span class="line">                            advance = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123;</span><br><span class="line">                            // 如果第一个元素是树节点</span><br><span class="line">                            // 也是一样，分化成两颗树</span><br><span class="line">                            // 也是根据hash&amp;n为0放在低位树中</span><br><span class="line">                            // 不为0放在高位树中</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                            int lc = 0, hc = 0;</span><br><span class="line">                            // 遍历整颗树，根据hash&amp;n是否为0分化成两颗树</span><br><span class="line">                            for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                                int h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                        (h, e.key, e.val, null, null);</span><br><span class="line">                                if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                    if ((p.prev = loTail) == null)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    else</span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                else &#123;</span><br><span class="line">                                    if ((p.prev = hiTail) == null)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    else</span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 如果分化的树中元素个数小于等于6，则退化成链表</span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                    (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                    (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            // 低位树的位置不变</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            // 高位树的位置是原位置加n</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            // 标记该桶已迁移</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            // advance为true，返回上面进行--i操作</span><br><span class="line">                            advance = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）新桶数组大小是旧桶数组的两倍；</p>
<p>（2）迁移元素先从靠后的桶开始；</p>
<p>（3）迁移完成的桶在里面放置一 ForwardingNode 类型的元素，标记该桶迁移完成；</p>
<p>（4）迁移时根据 hash&amp;n 是否等于 0 把桶中元素分化成两个链表或树；</p>
<p>（5）低位链表（树）存储在原来的位置；</p>
<p>（6）高们链表（树）存储在原来的位置加 n 的位置；</p>
<p>（7）迁移元素时会锁住当前桶，也是分段锁的思想；</p>
<h2 id="concurrenthashmap的size方法的实现知道多少"><a class="markdownIt-Anchor" href="#concurrenthashmap的size方法的实现知道多少">#</a> ConcurrentHashMap 的 size () 方法的实现知道多少？</h2>
<p>元素个数的存储也是采用分段的思想，获取元素个数时需要把所有段加起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public int size() &#123;</span><br><span class="line">        // 调用sumCount()计算元素个数</span><br><span class="line">        long n = sumCount();</span><br><span class="line">        return ((n &lt; 0L) ? 0 :</span><br><span class="line">                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                        (int)n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    final long sumCount() &#123;</span><br><span class="line">        // 计算CounterCell所有段及baseCount的数量之和</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        long sum = baseCount;</span><br><span class="line">        if (as != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">                if ((a = as[i]) != null)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）元素的个数依据不同的线程存在在不同的段里；（见 addCounter () 分析）</p>
<p>（2）计算 CounterCell 所有段及 baseCount 的数量之和；</p>
<p>（3）获取元素个数没有加锁；</p>
<h2 id="concurrenthashmap是强一致性的吗"><a class="markdownIt-Anchor" href="#concurrenthashmap是强一致性的吗">#</a> ConcurrentHashMap 是强一致性的吗？</h2>
<p>查询操作是不会加锁的，所以 ConcurrentHashMap 不是强一致性的；</p>
<h2 id="concurrenthashmap不能解决什么问题"><a class="markdownIt-Anchor" href="#concurrenthashmap不能解决什么问题">#</a> ConcurrentHashMap 不能解决什么问题？</h2>
<p>ConcurrentHashMap 中不能存储 key 或 value 为 null 的元素；</p>
<p>例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private static final Map&lt;Integer, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">public void unsafeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        if (oldValue == null) &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里如果有多个线程同时调用 unsafeUpdate () 这个方法，ConcurrentHashMap 还能保证线程安全吗？</p>
<p>答案是不能。因为 get () 之后 if 之前可能有其它线程已经 put () 了这个元素，这时候再 put () 就把那个线程 put () 的元素覆盖了。</p>
<p>那怎么修改呢？</p>
<p>答案也很简单，使用 putIfAbsent () 方法，它会保证元素不存在时才插入元素，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void safeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        map.putIfAbsent(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，如果上面 oldValue 不是跟 null 比较，而是跟一个特定的值比如 1 进行比较怎么办？也就是下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void unsafeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        if (oldValue == 1) &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样的话就没办法使用 putIfAbsent () 方法了。</p>
<p>其实，ConcurrentHashMap 还提供了另一个方法叫 replace (K key, V oldValue, V newValue) 可以解决这个问题。</p>
<p>replace (K key, V oldValue, V newValue) 这个方法可不能乱用，如果传入的 newValue 是 null，则会删除元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void safeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        map.replace(key, 1, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>那么，如果 if 之后不是简单的 put () 操作，而是还有其它业务操作，之后才是 put ()，比如下面这样，这该怎么办呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void unsafeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        if (oldValue == 1) &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">            /**</span><br><span class="line">             * 其它业务操作</span><br><span class="line">             */</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这时候就没办法使用 ConcurrentHashMap 提供的方法了，只能业务自己来保证线程安全了，比如下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void safeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        synchronized (map) &#123;</span><br><span class="line">            Integer oldValue = map.get(key);</span><br><span class="line">            if (oldValue == null) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">                /**</span><br><span class="line">                 * 其它业务操作</span><br><span class="line">                 */</span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样虽然不太友好，但是最起码能保证业务逻辑是正确的。</p>
<p>当然，这里使用 ConcurrentHashMap 的意义也就不大了，可以换成普通的 HashMap 了。</p>
<p>上面只是举一个简单的例子，我们不能听说 ConcurrentHashMap 是线程安全的，就认为它无论什么情况下都是线程安全的，还是那句话尽信书不如无书。</p>
<h2 id="concurrenthashmap的sizectl知道吗"><a class="markdownIt-Anchor" href="#concurrenthashmap的sizectl知道吗">#</a> ConcurrentHashMap 的 sizeCtl 知道吗？</h2>
<p>ConcurrentHashMap 中没有 threshold 和 loadFactor 这两个字段，而是采用 sizeCtl 来控制；</p>
<p>sizeCtl = -1，表示正在进行初始化；</p>
<p>sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p>
<p>sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；</p>
<p>sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加 1；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                MAXIMUM_CAPACITY :</span><br><span class="line">                tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">&#125;</span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">            initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">        long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">        int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">                MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="concurrenthashmap中哪些地方运用到分段锁的思想"><a class="markdownIt-Anchor" href="#concurrenthashmap中哪些地方运用到分段锁的思想">#</a> ConcurrentHashMap 中哪些地方运用到分段锁的思想？</h2>
<p>分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在 ConcurrentHashMap 中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。</p>
<h2 id="什么是伪共享为何会出现伪共享怎么避免伪共享"><a class="markdownIt-Anchor" href="#什么是伪共享为何会出现伪共享怎么避免伪共享">#</a> 什么是伪共享？为何会出现伪共享？怎么避免伪共享？</h2>
<h3 id="什么是伪共享"><a class="markdownIt-Anchor" href="#什么是伪共享">#</a> 什么是伪共享？</h3>
<p>计算机系统中为了解决主内存与 CPU 运行速度的差距，在 CPU 与主内存之间添加了一级或者多级高速缓冲存储器（Cache），这个 Cache 一般是集成到 CPU 内部的，所以也叫 CPU Cache，如下图是两级 cache 结构：</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817175342.jpg" alt="img"></p>
<p>Cache 内部是按行存储的，其中每一行称为一个 cache 行，cache 行是 Cache 与主内存进行数据交换的单位，cache 行的大小一般为 2 的幂次数字节。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817175402.png" alt="img"></p>
<p>当 CPU 访问某一个变量时候，首先会去看 CPU Cache 内是否有该变量，如果有则直接从中获取，否者就去主内存里面获取该变量，然后把该变量所在内存区域的一个 Cache 行大小的内存拷贝到 Cache（cache 行是 Cache 与主内存进行数据交换的单位）。由于存放到 Cache 行的的是内存块而不是单个变量，所以可能会把多个变量存放到了一个 cache 行。当多个线程同时修改一个缓存行里面的多个变量时候，由于同时只能有一个线程操作缓存行，所以相比每个变量放到一个缓存行性能会有所下降，这就是伪共享。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817175419.png" alt="img"></p>
<p>如上图变量 x,y 同时被放到了 CPU 的一级和二级缓存，当线程 1 使用 CPU1 对变量 x 进行更新时候，首先会修改 cpu1 的一级缓存变量 x 所在缓存行，这时候缓存一致性协议会导致 cpu2 中变量 x 对应的缓存行失效，那么线程 2 写入变量 x 的时候就只能去二级缓存去查找，这就破坏了一级缓存，而一级缓存比二级缓存更快。更坏的情况下如果 cpu 只有一级缓存，那么会导致频繁的直接访问主内存。</p>
<h3 id="为何会出现伪共享"><a class="markdownIt-Anchor" href="#为何会出现伪共享">#</a> 为何会出现伪共享</h3>
<p>伪共享的产生是因为多个变量被放入了一个缓存行，并且多个线程同时去写入缓存行中不同变量。那么为何多个变量会被放入一个缓存行那。其实是因为 Cache 与内存交换数据的单位就是 Cache，当 CPU 要访问的变量没有在 Cache 命中时候，根据程序运行的局部性原理会把该变量在内存中大小为 Cache 行的内存放如缓存行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">long a;</span><br><span class="line">long b;</span><br><span class="line">long c;</span><br><span class="line">long d;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如上代码，声明了四个 long 变量，假设 cache 行的大小为 32 个字节，那么当 cpu 访问变量 a 时候发现该变量没有在 cache 命中，那么就会去主内存把变量 a 以及内存地址附近的 b,c,d 放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中，当创建数组时候，数组里面的多个元素就会被放入到同一个缓存行。那么单线程下多个变量放入缓存行对性能有影响？其实正常情况下单线程访问时候由于数组元素被放入到了一个或者多个 cache 行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p>
<h4 id="如何解决伪共享"><a class="markdownIt-Anchor" href="#如何解决伪共享">#</a> 如何解决伪共享</h4>
<p>@Contended 注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="line">public @interface Contended &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Contended 注解可以用于类型上和属性上，加上这个注解之后虚拟机会自动进行填充，从而避免伪共享。这个注解在 Java8 ConcurrentHashMap、ForkJoinPool 和 Thread 等类中都有应用。我们来看一下 Java8 中 ConcurrentHashMap 中如何运用 Contended 这个注解来解决伪共享问题。以下说的 ConcurrentHashMap 都是 Java8 版本。</p>
<p><strong>注意</strong>：在 Java8 中提供了 **@sun.misc.Contended<strong> 来避免伪共享时，在运行时需要设置 JVM 启动参数</strong> - XX:-RestrictContended** 否则可能不生效。</p>
<p>缓存行填充的威力</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓存行测试</span><br><span class="line"> */</span><br><span class="line">public class CacheLineTest &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 是否启用缓存行填充</span><br><span class="line">     */</span><br><span class="line">    private final boolean isDataPadding = false;</span><br><span class="line">    /**</span><br><span class="line">     * 正常定义的变量</span><br><span class="line">     */</span><br><span class="line">    private volatile long x = 0;</span><br><span class="line">    private volatile long y = 0;</span><br><span class="line">    private volatile long z = 0;</span><br><span class="line">    /**</span><br><span class="line">     * 通过缓存行填充的变量</span><br><span class="line">     */</span><br><span class="line">    private volatile VolatileData volatileDataX = new VolatileData(0);</span><br><span class="line">    private volatile VolatileData volatileDataY = new VolatileData(0);</span><br><span class="line">    private volatile VolatileData volatileDataZ = new VolatileData(0);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 循环次数</span><br><span class="line">     */</span><br><span class="line">    private final long size = 100000000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行累加操作</span><br><span class="line">     */</span><br><span class="line">    public void accumulationX() &#123;</span><br><span class="line">        //计算耗时</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        long value = 0;</span><br><span class="line">        //循环累加</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            //使用缓存行填充的方式</span><br><span class="line">            if (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataX.accumulationAdd();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //不使用缓存行填充的方式 因为时单线程操作不需要加锁</span><br><span class="line">                value = (++x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //打印</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        //打印耗时</span><br><span class="line">        System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行累加操作</span><br><span class="line">     */</span><br><span class="line">    public void accumulationY() &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        long value = 0;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataY.accumulationAdd();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                value = ++y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行累加操作</span><br><span class="line">     */</span><br><span class="line">    public void accumulationZ() &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        long value = 0;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataZ.accumulationAdd();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                value = ++z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建对象</span><br><span class="line">        CacheLineTest cacheRowTest = new CacheLineTest();</span><br><span class="line">        //创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        //启动三个线程个调用他们各自的方法</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationX());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationY());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationZ());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当多个线程同时对共享的缓存行进行写操作的时候，因为缓存系统自身的缓存一致性原则，会引发伪共享问题，解决的常用办法是将共享变量根据缓存行大小进行补充对齐，使其加载到缓存时能够独享缓存行，避免与其他共享变量存储在同一个缓存行。</p>
<h2 id="什么是跳表"><a class="markdownIt-Anchor" href="#什么是跳表">#</a> 什么是跳表？</h2>
<p>跳表是一个随机化的数据结构，实质就是一种可以进行<strong>二分</strong>查找的<strong>有序链表</strong>。</p>
<p>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p>
<p>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817181502" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 数据节点，典型的单链表结构</span><br><span class="line">   static final class Node&lt;K,V&gt; &#123;</span><br><span class="line">       final K key;</span><br><span class="line">       // 注意：这里value的类型是Object，而不是V</span><br><span class="line">       // 在删除元素的时候value会指向当前元素本身</span><br><span class="line">       volatile Object value;</span><br><span class="line">       volatile Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">       Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.key = key;</span><br><span class="line">           this.value = value;</span><br><span class="line">           this.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.key = null;</span><br><span class="line">           this.value = this; // 当前元素本身(marker)</span><br><span class="line">           this.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 索引节点，存储着对应的node值，及向下和向右的索引指针</span><br><span class="line">   static class Index&lt;K,V&gt; &#123;</span><br><span class="line">       final Node&lt;K,V&gt; node;</span><br><span class="line">       final Index&lt;K,V&gt; down;</span><br><span class="line">       volatile Index&lt;K,V&gt; right;</span><br><span class="line">   </span><br><span class="line">       Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123;</span><br><span class="line">           this.node = node;</span><br><span class="line">           this.down = down;</span><br><span class="line">           this.right = right;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 头索引节点，继承自Index，并扩展一个level字段，用于记录索引的层级</span><br><span class="line">   static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123;</span><br><span class="line">       final int level;</span><br><span class="line">   </span><br><span class="line">       HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123;</span><br><span class="line">           super(node, down, right);</span><br><span class="line">           this.level = level;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）Node，数据节点，存储数据的节点，典型的单链表结构；</p>
<p>（2）Index，索引节点，存储着对应的 node 值，及向下和向右的索引指针；</p>
<p>（3）HeadIndex，头索引节点，继承自 Index，并扩展一个 level 字段，用于记录索引的层级；</p>
<h2 id="concurrentskiplist是有序的吗"><a class="markdownIt-Anchor" href="#concurrentskiplist是有序的吗">#</a> ConcurrentSkipList 是有序的吗？</h2>
<p>ConcurrentSkipListMap 的 key 是有序的。</p>
<h2 id="concurrentskiplist是如何保证线程安全的"><a class="markdownIt-Anchor" href="#concurrentskiplist是如何保证线程安全的">#</a> ConcurrentSkipList 是如何保证线程安全的？</h2>
<h2 id="concurrentskiplist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#concurrentskiplist插入-删除-查询元素的时间复杂度各是多少">#</a> ConcurrentSkipList 插入、删除、查询元素的时间复杂度各是多少？</h2>
<p>跳表查询、插入、删除的时间复杂度为 O (log n)，与平衡二叉树接近；</p>
<h3 id="添加"><a class="markdownIt-Anchor" href="#添加">#</a> 添加</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        // 不能存储value为null的元素</span><br><span class="line">        // 因为value为null标记该元素被删除（后面会看到）</span><br><span class="line">        if (value == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">    </span><br><span class="line">        // 调用doPut()方法添加元素</span><br><span class="line">        return doPut(key, value, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private V doPut(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        // 添加元素后存储在z中</span><br><span class="line">        Node&lt;K,V&gt; z;             // added node</span><br><span class="line">        // key也不能为null</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">    </span><br><span class="line">        // Part I：找到目标节点的位置并插入</span><br><span class="line">        // 这里的目标节点是数据节点，也就是最底层的那条链</span><br><span class="line">        // 自旋</span><br><span class="line">        outer: for (;;) &#123;</span><br><span class="line">            // 寻找目标节点之前最近的一个索引对应的数据节点，存储在b中，b=before</span><br><span class="line">            // 并把b的下一个数据节点存储在n中，n=next</span><br><span class="line">            // 为了便于描述，我这里把b叫做当前节点，n叫做下一个节点</span><br><span class="line">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                // 如果下一个节点不为空</span><br><span class="line">                // 就拿其key与目标节点的key比较，找到目标节点应该插入的位置</span><br><span class="line">                if (n != null) &#123;</span><br><span class="line">                    // v=value，存储节点value值</span><br><span class="line">                    // c=compare，存储两个节点比较的大小</span><br><span class="line">                    Object v; int c;</span><br><span class="line">                    // n的下一个数据节点，也就是b的下一个节点的下一个节点（孙子节点）</span><br><span class="line">                    Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                    // 如果n不为b的下一个节点</span><br><span class="line">                    // 说明有其它线程修改了数据，则跳出内层循环</span><br><span class="line">                    // 也就是回到了外层循环自旋的位置，从头来过</span><br><span class="line">                    if (n != b.next)               // inconsistent read</span><br><span class="line">                        break;</span><br><span class="line">                    // 如果n的value值为空，说明该节点已删除，协助删除节点</span><br><span class="line">                    if ((v = n.value) == null) &#123;   // n is deleted</span><br><span class="line">                        // todo 这里为啥会协助删除？后面讲</span><br><span class="line">                        n.helpDelete(b, f);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果b的值为空或者v等于n，说明b已被删除</span><br><span class="line">                    // 这时候n就是marker节点，那b就是被删除的那个</span><br><span class="line">                    if (b.value == null || v == n) // b is deleted</span><br><span class="line">                        break;</span><br><span class="line">                    // 如果目标key与下一个节点的key大</span><br><span class="line">                    // 说明目标元素所在的位置还在下一个节点的后面</span><br><span class="line">                    if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123;</span><br><span class="line">                        // 就把当前节点往后移一位</span><br><span class="line">                        // 同样的下一个节点也往后移一位</span><br><span class="line">                        // 再重新检查新n是否为空，它与目标key的关系</span><br><span class="line">                        b = n;</span><br><span class="line">                        n = f;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果比较时发现下一个节点的key与目标key相同</span><br><span class="line">                    // 说明链表中本身就存在目标节点</span><br><span class="line">                    if (c == 0) &#123;</span><br><span class="line">                        // 则用新值替换旧值，并返回旧值（onlyIfAbsent=false）</span><br><span class="line">                        if (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                            return vv;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 如果替换旧值时失败，说明其它线程先一步修改了值，从头来过</span><br><span class="line">                        break; // restart if lost race to replace value</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果c&lt;0，就往下走，也就是找到了目标节点的位置</span><br><span class="line">                    // else c &lt; 0; fall through</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                // 有两种情况会到这里</span><br><span class="line">                // 一是到链表尾部了，也就是n为null了</span><br><span class="line">                // 二是找到了目标节点的位置，也就是上面的c&lt;0</span><br><span class="line">    </span><br><span class="line">                // 新建目标节点，并赋值给z</span><br><span class="line">                // 这里把n作为新节点的next</span><br><span class="line">                // 如果到链表尾部了，n为null，这毫无疑问</span><br><span class="line">                // 如果c&lt;0，则n的key比目标key大，相妆于在b和n之间插入目标节点z</span><br><span class="line">                z = new Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">                // 原子更新b的下一个节点为目标节点z</span><br><span class="line">                if (!b.casNext(n, z))</span><br><span class="line">                    // 如果更新失败，说明其它线程先一步修改了值，从头来过</span><br><span class="line">                    break;         // restart if lost race to append to b</span><br><span class="line">                // 如果更新成功，跳出自旋状态</span><br><span class="line">                break outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 经过Part I，目标节点已经插入到有序链表中了</span><br><span class="line">    </span><br><span class="line">        // Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引</span><br><span class="line">    </span><br><span class="line">        // 取个随机数</span><br><span class="line">        int rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">        // 0x80000001展开为二进制为10000000000000000000000000000001</span><br><span class="line">        // 只有两头是1</span><br><span class="line">        // 这里(rnd &amp; 0x80000001) == 0</span><br><span class="line">        // 相当于排除了负数（负数最高位是1），排除了奇数（奇数最低位是1）</span><br><span class="line">        // 只有最高位最低位都不为1的数跟0x80000001做&amp;操作才会为0</span><br><span class="line">        // 也就是正偶数</span><br><span class="line">        if ((rnd &amp; 0x80000001) == 0) &#123; // test highest and lowest bits</span><br><span class="line">            // 默认level为1，也就是只要到这里了就会至少建立一层索引</span><br><span class="line">            int level = 1, max;</span><br><span class="line">            // 随机数从最低位的第二位开始，有几个连续的1则level就加几</span><br><span class="line">            // 因为最低位肯定是0，正偶数嘛</span><br><span class="line">            // 比如，1100110，level就加2</span><br><span class="line">            while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</span><br><span class="line">                ++level;</span><br><span class="line">    </span><br><span class="line">            // 用于记录目标节点建立的最高的那层索引节点</span><br><span class="line">            Index&lt;K,V&gt; idx = null;</span><br><span class="line">            // 取头索引节点（这是最高层的头索引节点）</span><br><span class="line">            HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">            // 如果生成的层数小于等于当前最高层的层级</span><br><span class="line">            // 也就是跳表的高度不会超过现有高度</span><br><span class="line">            if (level &lt;= (max = h.level)) &#123;</span><br><span class="line">                // 从第一层开始建立一条竖直的索引链表</span><br><span class="line">                // 这条链表使用down指针连接起来</span><br><span class="line">                // 每个索引节点里面都存储着目标节点这个数据节点</span><br><span class="line">                // 最后idx存储的是这条索引链表的最高层节点</span><br><span class="line">                for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                    idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // try to grow by one level</span><br><span class="line">                // 如果新的层数超过了现有跳表的高度</span><br><span class="line">                // 则最多只增加一层</span><br><span class="line">                // 比如现在只有一层索引，那下一次最多增加到两层索引，增加多了也没有意义</span><br><span class="line">                level = max + 1; // hold in array and later pick the one to use</span><br><span class="line">                // idxs用于存储目标节点建立的竖起索引的所有索引节点</span><br><span class="line">                // 其实这里直接使用idx这个最高节点也是可以完成的</span><br><span class="line">                // 只是用一个数组存储所有节点要方便一些</span><br><span class="line">                // 注意，这里数组0号位是没有使用的</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                        (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];</span><br><span class="line">                // 从第一层开始建立一条竖的索引链表（跟上面一样，只是这里顺便把索引节点放到数组里面了）</span><br><span class="line">                for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                    idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">    </span><br><span class="line">                // 自旋</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    // 旧的最高层头索引节点</span><br><span class="line">                    h = head;</span><br><span class="line">                    // 旧的最高层级</span><br><span class="line">                    int oldLevel = h.level;</span><br><span class="line">                    // 再次检查，如果旧的最高层级已经不比新层级矮了</span><br><span class="line">                    // 说明有其它线程先一步修改了值，从头来过</span><br><span class="line">                    if (level &lt;= oldLevel) // lost race to add level</span><br><span class="line">                        break;</span><br><span class="line">                    // 新的最高层头索引节点</span><br><span class="line">                    HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                    // 头节点指向的数据节点</span><br><span class="line">                    Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                    // 超出的部分建立新的头索引节点</span><br><span class="line">                    for (int j = oldLevel+1; j &lt;= level; ++j)</span><br><span class="line">                        newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                    // 原子更新头索引节点</span><br><span class="line">                    if (casHead(h, newh)) &#123;</span><br><span class="line">                        // h指向新的最高层头索引节点</span><br><span class="line">                        h = newh;</span><br><span class="line">                        // 把level赋值为旧的最高层级的</span><br><span class="line">                        // idx指向的不是最高的索引节点了</span><br><span class="line">                        // 而是与旧最高层平齐的索引节点</span><br><span class="line">                        idx = idxs[level = oldLevel];</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 经过上面的步骤，有两种情况</span><br><span class="line">            // 一是没有超出高度，新建一条目标节点的索引节点链</span><br><span class="line">            // 二是超出了高度，新建一条目标节点的索引节点链，同时最高层头索引节点同样往上长</span><br><span class="line">    </span><br><span class="line">            // Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起</span><br><span class="line">    </span><br><span class="line">            // 这时level是等于旧的最高层级的，自旋</span><br><span class="line">            splice: for (int insertionLevel = level;;) &#123;</span><br><span class="line">                // h为最高头索引节点</span><br><span class="line">                int j = h.level;</span><br><span class="line">    </span><br><span class="line">                // 从头索引节点开始遍历</span><br><span class="line">                // 为了方便，这里叫q为当前节点，r为右节点，d为下节点，t为目标节点相应层级的索引</span><br><span class="line">                for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                    // 如果遍历到了最右边，或者最下边，</span><br><span class="line">                    // 也就是遍历到头了，则退出外层循环</span><br><span class="line">                    if (q == null || t == null)</span><br><span class="line">                        break splice;</span><br><span class="line">                    // 如果右节点不为空</span><br><span class="line">                    if (r != null) &#123;</span><br><span class="line">                        // n是右节点的数据节点，为了方便，这里直接叫右节点的值</span><br><span class="line">                        Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                        // 比较目标key与右节点的值</span><br><span class="line">                        int c = cpr(cmp, key, n.key);</span><br><span class="line">                        // 如果右节点的值为空了，则表示此节点已删除</span><br><span class="line">                        if (n.value == null) &#123;</span><br><span class="line">                            // 则把右节点删除</span><br><span class="line">                            if (!q.unlink(r))</span><br><span class="line">                                // 如果删除失败，说明有其它线程先一步修改了，从头来过</span><br><span class="line">                                break;</span><br><span class="line">                            // 删除成功后重新取右节点</span><br><span class="line">                            r = q.right;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 如果比较c&gt;0，表示目标节点还要往右</span><br><span class="line">                        if (c &gt; 0) &#123;</span><br><span class="line">                            // 则把当前节点和右节点分别右移</span><br><span class="line">                            q = r;</span><br><span class="line">                            r = r.right;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    // 到这里说明已经到当前层级的最右边了</span><br><span class="line">                    // 这里实际是会先走第二个if</span><br><span class="line">    </span><br><span class="line">                    // 第一个if</span><br><span class="line">                    // j与insertionLevel相等了</span><br><span class="line">                    // 实际是先走的第二个if，j自减后应该与insertionLevel相等</span><br><span class="line">                    if (j == insertionLevel) &#123;</span><br><span class="line">                        // 这里是真正连右指针的地方</span><br><span class="line">                        if (!q.link(r, t))</span><br><span class="line">                            // 连接失败，从头来过</span><br><span class="line">                            break; // restart</span><br><span class="line">                        // t节点的值为空，可能是其它线程删除了这个元素</span><br><span class="line">                        if (t.node.value == null) &#123;</span><br><span class="line">                            // 这里会去协助删除元素</span><br><span class="line">                            findNode(key);</span><br><span class="line">                            break splice;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 当前层级右指针连接完毕，向下移一层继续连接</span><br><span class="line">                        // 如果移到了最下面一层，则说明都连接完成了，退出外层循环</span><br><span class="line">                        if (--insertionLevel == 0)</span><br><span class="line">                            break splice;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    // 第二个if</span><br><span class="line">                    // j先自减1，再与两个level比较</span><br><span class="line">                    // j、insertionLevel和t(idx)三者是对应的，都是还未把右指针连好的那个层级</span><br><span class="line">                    if (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                        // t往下移</span><br><span class="line">                        t = t.down;</span><br><span class="line">    </span><br><span class="line">                    // 当前层级到最右边了</span><br><span class="line">                    // 那只能往下一层级去走了</span><br><span class="line">                    // 当前节点下移</span><br><span class="line">                    // 再取相应的右节点</span><br><span class="line">                    q = q.down;</span><br><span class="line">                    r = q.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 寻找目标节点之前最近的一个索引对应的数据节点</span><br><span class="line">    private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) &#123;</span><br><span class="line">        // key不能为空</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException(); // don&#x27;t postpone errors</span><br><span class="line">        // 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 从最高层头索引节点开始查找，先向右，再向下</span><br><span class="line">            // 直到找到目标位置之前的那个索引</span><br><span class="line">            for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">                // 如果右节点不为空</span><br><span class="line">                if (r != null) &#123;</span><br><span class="line">                    // 右节点对应的数据节点，为了方便，我们叫右节点的值</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    K k = n.key;</span><br><span class="line">                    // 如果右节点的value为空</span><br><span class="line">                    // 说明其它线程把这个节点标记为删除了</span><br><span class="line">                    // 则协助删除</span><br><span class="line">                    if (n.value == null) &#123;</span><br><span class="line">                        if (!q.unlink(r))</span><br><span class="line">                            // 如果删除失败</span><br><span class="line">                            // 说明其它线程先删除了，从头来过</span><br><span class="line">                            break;           // restart</span><br><span class="line">                        // 删除之后重新读取右节点</span><br><span class="line">                        r = q.right;         // reread r</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果目标key比右节点还大，继续向右寻找</span><br><span class="line">                    if (cpr(cmp, key, k) &gt; 0) &#123;</span><br><span class="line">                        // 往右移</span><br><span class="line">                        q = r;</span><br><span class="line">                        // 重新取右节点</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果c&lt;0，说明不能再往右了</span><br><span class="line">                &#125;</span><br><span class="line">                // 到这里说明当前层级已经到最右了</span><br><span class="line">                // 两种情况：一是r==null，二是c&lt;0</span><br><span class="line">                // 再从下一级开始找</span><br><span class="line">    </span><br><span class="line">                // 如果没有下一级了，就返回这个索引对应的数据节点</span><br><span class="line">                if ((d = q.down) == null)</span><br><span class="line">                    return q.node;</span><br><span class="line">    </span><br><span class="line">                // 往下移</span><br><span class="line">                q = d;</span><br><span class="line">                // 重新取右节点</span><br><span class="line">                r = d.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Node.class中的方法，协助删除元素</span><br><span class="line">    void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Rechecking links and then doing only one of the</span><br><span class="line">         * help-out stages per call tends to minimize CAS</span><br><span class="line">         * interference among helping threads.</span><br><span class="line">         */</span><br><span class="line">        // 这里的调用者this==n，三者关系是b-&gt;n-&gt;f</span><br><span class="line">        if (f == next &amp;&amp; this == b.next) &#123;</span><br><span class="line">            // 将n的值设置为null后，会先把n的下个节点设置为marker节点</span><br><span class="line">            // 这个marker节点的值是它自己</span><br><span class="line">            // 这里如果不是它自己说明marker失败了，重新marker</span><br><span class="line">            if (f == null || f.value != f) // not already marked</span><br><span class="line">                casNext(f, new Node&lt;K,V&gt;(f));</span><br><span class="line">            else</span><br><span class="line">                // marker过了，就把b的下个节点指向marker的下个节点</span><br><span class="line">                b.casNext(this, f.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Index.class中的方法，删除succ节点</span><br><span class="line">    final boolean unlink(Index&lt;K,V&gt; succ) &#123;</span><br><span class="line">        // 原子更新当前节点指向下一个节点的下一个节点</span><br><span class="line">        // 也就是删除下一个节点</span><br><span class="line">        return node.value != null &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Index.class中的方法，在当前节点与succ之间插入newSucc节点</span><br><span class="line">    final boolean link(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc) &#123;</span><br><span class="line">        // 在当前节点与下一个节点中间插入一个节点</span><br><span class="line">        Node&lt;K,V&gt; n = node;</span><br><span class="line">        // 新节点指向当前节点的下一个节点</span><br><span class="line">        newSucc.right = succ;</span><br><span class="line">        // 原子更新当前节点的下一个节点指向新节点</span><br><span class="line">        return n.value != null &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们这里把整个插入过程分成三个部分：</p>
<p>Part I：找到目标节点的位置并插入</p>
<p>（1）这里的目标节点是数据节点，也就是最底层的那条链；</p>
<p>（2）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p>
<p>（3）从这个数据节点开始往后遍历，直到找到目标节点应该插入的位置；</p>
<p>（4）如果这个位置有元素，就更新其值（onlyIfAbsent=false）；</p>
<p>（5）如果这个位置没有元素，就把目标节点插入；</p>
<p>（6）至此，目标节点已经插入到最底层的数据节点链表中了；</p>
<p>Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引</p>
<p>（1）取个随机数 rnd，计算 (rnd &amp; 0x80000001)；</p>
<p>（2）如果不等于 0，结束插入过程，也就是不需要创建索引，返回；</p>
<p>（3）如果等于 0，才进入创建索引的过程（只要正偶数才会等于 0）；</p>
<p>（4）计算 <code>while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</code> ，决定层级数，level 从 1 开始；</p>
<p>（5）如果算出来的层级不高于现有最高层级，则直接建立一条竖直的索引链表（只有 down 有值），并结束 Part II；</p>
<p>（6）如果算出来的层级高于现有最高层级，则新的层级只能比现有最高层级多 1；</p>
<p>（7）同样建立一条竖直的索引链表（只有 down 有值）；</p>
<p>（8）将头索引也向上增加到相应的高度，结束 Part II；</p>
<p>（9）也就是说，如果层级不超过现有高度，只建立一条索引链，否则还要额外增加头索引链的高度（脑补一下，后面举例说明）；</p>
<p>Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起（补上 right 指针）</p>
<p>（1）从最高层级的头索引节点开始，向右遍历，找到目标索引节点的位置；</p>
<p>（2）如果当前层有目标索引，则把目标索引插入到这个位置，并把目标索引前一个索引向下移一个层级；</p>
<p>（3）如果当前层没有目标索引，则把目标索引位置前一个索引向下移一个层级；</p>
<p>（4）同样地，再向右遍历，寻找新的层级中目标索引的位置，回到第（2）步；</p>
<p>（5）依次循环找到所有层级目标索引的位置并把它们插入到横向的索引链表中；</p>
<p>总结起来，一共就是三大步：</p>
<p>（1）插入目标节点到数据节点链表中；</p>
<p>（2）建立竖直的 down 链表；</p>
<p>（3）建立横向的 right 链表；</p>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除">#</a> 删除</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">        return doRemove(key, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final V doRemove(Object key, Object value) &#123;</span><br><span class="line">        // key不为空</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">        // 自旋</span><br><span class="line">        outer: for (;;) &#123;</span><br><span class="line">            // 寻找目标节点之前的最近的索引节点对应的数据节点</span><br><span class="line">            // 为了方便，这里叫b为当前节点，n为下一个节点，f为下下个节点</span><br><span class="line">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                Object v; int c;</span><br><span class="line">                // 整个链表都遍历完了也没找到目标节点，退出外层循环</span><br><span class="line">                if (n == null)</span><br><span class="line">                    break outer;</span><br><span class="line">                // 下下个节点</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                // 再次检查</span><br><span class="line">                // 如果n不是b的下一个节点了</span><br><span class="line">                // 说明有其它线程先一步修改了，从头来过</span><br><span class="line">                if (n != b.next)                    // inconsistent read</span><br><span class="line">                    break;</span><br><span class="line">                // 如果下个节点的值奕为null了</span><br><span class="line">                // 说明有其它线程标记该元素为删除状态了</span><br><span class="line">                if ((v = n.value) == null) &#123;        // n is deleted</span><br><span class="line">                    // 协助删除</span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果b的值为空或者v等于n，说明b已被删除</span><br><span class="line">                // 这时候n就是marker节点，那b就是被删除的那个</span><br><span class="line">                if (b.value == null || v == n)      // b is deleted</span><br><span class="line">                    break;</span><br><span class="line">                // 如果c&lt;0，说明没找到元素，退出外层循环</span><br><span class="line">                if ((c = cpr(cmp, key, n.key)) &lt; 0)</span><br><span class="line">                    break outer;</span><br><span class="line">                // 如果c&gt;0，说明还没找到，继续向右找</span><br><span class="line">                if (c &gt; 0) &#123;</span><br><span class="line">                    // 当前节点往后移</span><br><span class="line">                    b = n;</span><br><span class="line">                    // 下一个节点往后移</span><br><span class="line">                    n = f;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // c=0，说明n就是要找的元素</span><br><span class="line">                // 如果value不为空且不等于找到元素的value，不需要删除，退出外层循环</span><br><span class="line">                if (value != null &amp;&amp; !value.equals(v))</span><br><span class="line">                    break outer;</span><br><span class="line">                // 如果value为空，或者相等</span><br><span class="line">                // 原子标记n的value值为空</span><br><span class="line">                if (!n.casValue(v, null))</span><br><span class="line">                    // 如果删除失败，说明其它线程先一步修改了，从头来过</span><br><span class="line">                    break;</span><br><span class="line">    </span><br><span class="line">                // P.S.到了这里n的值肯定是设置成null了</span><br><span class="line">    </span><br><span class="line">                // 关键！！！！</span><br><span class="line">                // 让n的下一个节点指向一个market节点</span><br><span class="line">                // 这个market节点的key为null，value为marker自己，next为n的下个节点f</span><br><span class="line">                // 或者让b的下一个节点指向下下个节点</span><br><span class="line">                // 注意：这里是或者||，因为两个CAS不能保证都成功，只能一个一个去尝试</span><br><span class="line">                // 这里有两层意思：</span><br><span class="line">                // 一是如果标记market成功，再尝试将b的下个节点指向下下个节点，如果第二步失败了，进入条件，如果成功了就不用进入条件了</span><br><span class="line">                // 二是如果标记market失败了，直接进入条件</span><br><span class="line">                if (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                    // 通过findNode()重试删除（里面有个helpDelete()方法）</span><br><span class="line">                    findNode(key);                  // retry via findNode</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 上面两步操作都成功了，才会进入这里，不太好理解，上面两个条件都有非&quot;!&quot;操作</span><br><span class="line">                    // 说明节点已经删除了，通过findPredecessor()方法删除索引节点</span><br><span class="line">                    // findPredecessor()里面有unlink()操作</span><br><span class="line">                    findPredecessor(key, cmp);      // clean index</span><br><span class="line">                    // 如果最高层头索引节点没有右节点，则跳表的高度降级</span><br><span class="line">                    if (head.right == null)</span><br><span class="line">                        tryReduceLevel();</span><br><span class="line">                &#125;</span><br><span class="line">                // 返回删除的元素值</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                return vv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p>
<p>（2）从这个数据节点开始往后遍历，直到找到目标节点的位置；</p>
<p>（3）如果这个位置没有元素，直接返回 null，表示没有要删除的元素；</p>
<p>（4）如果这个位置有元素，先通过 <code>n.casValue(v, null)</code>  原子更新把其 value 设置为 null；</p>
<p>（5）通过 <code>n.appendMarker(f)</code>  在当前元素后面添加一个 marker 元素标记当前元素是要删除的元素；</p>
<p>（6）通过 <code>b.casNext(n, f)</code>  尝试删除元素；</p>
<p>（7）如果上面两步中的任意一步失败了都通过 <code>findNode(key)</code>  中的 <code>n.helpDelete(b, f)</code>  再去不断尝试删除；</p>
<p>（8）如果上面两步都成功了，再通过 <code>findPredecessor(key, cmp)</code>  中的 <code>q.unlink(r)</code>  删除索引节点；</p>
<p>（9）如果 head 的 right 指针指向了 null，则跳表高度降级；</p>
<h3 id="查询"><a class="markdownIt-Anchor" href="#查询">#</a> 查询</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">       return doGet(key);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private V doGet(Object key) &#123;</span><br><span class="line">       // key不为空</span><br><span class="line">       if (key == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">       // 自旋</span><br><span class="line">       outer: for (;;) &#123;</span><br><span class="line">           // 寻找目标节点之前最近的索引对应的数据节点</span><br><span class="line">           // 为了方便，这里叫b为当前节点，n为下个节点，f为下下个节点</span><br><span class="line">           for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               Object v; int c;</span><br><span class="line">               // 如果链表到头还没找到元素，则跳出外层循环</span><br><span class="line">               if (n == null)</span><br><span class="line">                   break outer;</span><br><span class="line">               // 下下个节点</span><br><span class="line">               Node&lt;K,V&gt; f = n.next;</span><br><span class="line">               // 如果不一致读，从头来过</span><br><span class="line">               if (n != b.next)                // inconsistent read</span><br><span class="line">                   break;</span><br><span class="line">               // 如果n的值为空，说明节点已被其它线程标记为删除</span><br><span class="line">               if ((v = n.value) == null) &#123;    // n is deleted</span><br><span class="line">                   // 协助删除，再重试</span><br><span class="line">                   n.helpDelete(b, f);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               // 如果b的值为空或者v等于n，说明b已被删除</span><br><span class="line">               // 这时候n就是marker节点，那b就是被删除的那个</span><br><span class="line">               if (b.value == null || v == n)  // b is deleted</span><br><span class="line">                   break;</span><br><span class="line">               // 如果c==0，说明找到了元素，就返回元素值</span><br><span class="line">               if ((c = cpr(cmp, key, n.key)) == 0) &#123;</span><br><span class="line">                   @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                   return vv;</span><br><span class="line">               &#125;</span><br><span class="line">               // 如果c&lt;0，说明没找到元素</span><br><span class="line">               if (c &lt; 0)</span><br><span class="line">                   break outer;</span><br><span class="line">               // 如果c&gt;0，说明还没找到，继续寻找</span><br><span class="line">               // 当前节点往后移</span><br><span class="line">               b = n;</span><br><span class="line">               // 下一个节点往后移</span><br><span class="line">               n = f;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p>
<p>（2）从这个数据节点开始往后遍历，直到找到目标节点的位置；</p>
<p>（3）如果这个位置没有元素，直接返回 null，表示没有找到元素；</p>
<p>（4）如果这个位置有元素，返回元素的 value 值；</p>
<h2 id="concurrentskiplist的索引具有什么特性"><a class="markdownIt-Anchor" href="#concurrentskiplist的索引具有什么特性">#</a> ConcurrentSkipList 的索引具有什么特性？</h2>
<p>ConcurrentSkipListMap 提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中 Node 表示最底层的单链表有序节点、Index 表示为基于 Node 的索引层，HeadIndex 用来维护索引层次。到这里我们可以这样说 ConcurrentSkipListMap 是通过 HeadIndex 维护索引层次，通过 Index 从最上层开始往下层查找，一步一步缩小查询范围，最后到达最底层 Node 时，就只需要比较很小一部分数据了。<br>
Index 提供了一个基于 Node 节点的索引 Node，一个指向下一个 Index 的 right，一个指向下层的 down 节点。</p>
<h2 id="为什么redis选择使用跳表而不是红黑树来实现有序集合"><a class="markdownIt-Anchor" href="#为什么redis选择使用跳表而不是红黑树来实现有序集合">#</a> 为什么 Redis 选择使用跳表而不是红黑树来实现有序集合？</h2>
<p>首先，我们来分析下 Redis 的有序集合支持的操作：</p>
<p>1）插入元素</p>
<p>2）删除元素</p>
<p>3）查找元素</p>
<p>4）有序输出所有元素</p>
<p>5）查找区间内所有元素</p>
<p>其中，前 4 项红黑树都可以完成，且时间复杂度与跳表一致。</p>
<p>但是，最后一项，红黑树的效率就没有跳表高了。</p>
<p>在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。</p>
<p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。</p>
<p>此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以 Redis 选择使用跳表来实现有序集合。</p>
<h2 id="hashset怎么保证添加元素不重复"><a class="markdownIt-Anchor" href="#hashset怎么保证添加元素不重复">#</a> HashSet 怎么保证添加元素不重复？</h2>
<p>HashSet 内部使用 HashMap 的 key 存储元素，以此来保证元素不重复；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 内部使用HashMap</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line">// 虚拟对象，用来作为value放到map中</span><br><span class="line">private static final Object PRESENT = new Object();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hashset是有序的吗"><a class="markdownIt-Anchor" href="#hashset是有序的吗">#</a> HashSet 是有序的吗？</h2>
<p>HashSet 是无序的，因为 HashMap 的 key 是无序的；</p>
<h2 id="hashset是否允许null元素"><a class="markdownIt-Anchor" href="#hashset是否允许null元素">#</a> HashSet 是否允许 null 元素？</h2>
<p>HashSet 中允许有一个 null 元素，因为 HashMap 允许 key 为 null；</p>
<h2 id="set是否有get方法"><a class="markdownIt-Anchor" href="#set是否有get方法">#</a> Set 是否有 get () 方法？</h2>
<p>HashSet 是没有 get () 方法的，，因为 get 似乎没有意义，不像 List 那样可以按 index 获取元素。</p>
<p>这里只要一个检查元素是否存在的方法 contains ()，直接调用 map 的 containsKey () 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">        return map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="hashset源码"><a class="markdownIt-Anchor" href="#hashset源码">#</a> HashSet 源码？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> package java.util;</span><br><span class="line">    </span><br><span class="line">import java.io.InvalidObjectException;</span><br><span class="line">import sun.misc.SharedSecrets;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">        extends AbstractSet&lt;E&gt;</span><br><span class="line">        implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">    &#123;</span><br><span class="line">        static final long serialVersionUID = -5024744406713321676L;</span><br><span class="line">    </span><br><span class="line">        // 内部元素存储在HashMap中</span><br><span class="line">        private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line">        // 虚拟元素，用来存到map元素的value中的，没有实际意义</span><br><span class="line">        private static final Object PRESENT = new Object();</span><br><span class="line">    </span><br><span class="line">        // 空构造方法</span><br><span class="line">        public HashSet() &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 把另一个集合的元素全都添加到当前Set中</span><br><span class="line">        // 注意，这里初始化map的时候是计算了它的初始容量的</span><br><span class="line">        public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 指定初始容量和装载因子</span><br><span class="line">        public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 只指定初始容量</span><br><span class="line">        public HashSet(int initialCapacity) &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // LinkedHashSet专用的方法</span><br><span class="line">        // dummy是没有实际意义的, 只是为了跟上上面那个操持方法签名不同而已</span><br><span class="line">        HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">            map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 迭代器</span><br><span class="line">        public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">            return map.keySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 元素个数</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return map.size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否为空</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            return map.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否包含某个元素</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return map.containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 添加元素</span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            return map.put(e, PRESENT)==null;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 删除元素</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return map.remove(o)==PRESENT;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 清空所有元素</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 克隆方法</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public Object clone() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">                newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">                return newSet;</span><br><span class="line">            &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">                throw new InternalError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 序列化写出方法</span><br><span class="line">        private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">            throws java.io.IOException &#123;</span><br><span class="line">            // 写出非static非transient属性</span><br><span class="line">            s.defaultWriteObject();</span><br><span class="line">    </span><br><span class="line">            // 写出map的容量和装载因子</span><br><span class="line">            s.writeInt(map.capacity());</span><br><span class="line">            s.writeFloat(map.loadFactor());</span><br><span class="line">    </span><br><span class="line">            // 写出元素个数</span><br><span class="line">            s.writeInt(map.size());</span><br><span class="line">    </span><br><span class="line">            // 遍历写出所有元素</span><br><span class="line">            for (E e : map.keySet())</span><br><span class="line">                s.writeObject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 序列化读入方法</span><br><span class="line">        private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">            throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">            // 读入非static非transient属性</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">            // 读入容量, 并检查不能小于0</span><br><span class="line">            int capacity = s.readInt();</span><br><span class="line">            if (capacity &lt; 0) &#123;</span><br><span class="line">                throw new InvalidObjectException(&quot;Illegal capacity: &quot; +</span><br><span class="line">                                                 capacity);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 读入装载因子, 并检查不能小于等于0或者是NaN(Not a Number)</span><br><span class="line">            // java.lang.Float.NaN = 0.0f / 0.0f;</span><br><span class="line">            float loadFactor = s.readFloat();</span><br><span class="line">            if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">                throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                                 loadFactor);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 读入元素个数并检查不能小于0</span><br><span class="line">            int size = s.readInt();</span><br><span class="line">            if (size &lt; 0) &#123;</span><br><span class="line">                throw new InvalidObjectException(&quot;Illegal size: &quot; +</span><br><span class="line">                                                 size);</span><br><span class="line">            &#125;</span><br><span class="line">            // 根据元素个数重新设置容量</span><br><span class="line">            // 这是为了保证map有足够的容量容纳所有元素, 防止无意义的扩容</span><br><span class="line">            capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f),</span><br><span class="line">                    HashMap.MAXIMUM_CAPACITY);</span><br><span class="line">    </span><br><span class="line">            // 再次检查某些东西, 不重要的代码忽视掉</span><br><span class="line">            SharedSecrets.getJavaOISAccess()</span><br><span class="line">                         .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity));</span><br><span class="line">    </span><br><span class="line">            // 创建map, 检查是不是LinkedHashSet类型</span><br><span class="line">            map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?</span><br><span class="line">                   new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">                   new HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line">    </span><br><span class="line">            // 读入所有元素, 并放入map中</span><br><span class="line">            for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    E e = (E) s.readObject();</span><br><span class="line">                map.put(e, PRESENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 可分割的迭代器, 主要用于多线程并行迭代处理时使用</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            return new HashMap.KeySpliterator&lt;E,Object&gt;(map, 0, -1, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linkedhashset的底层使用什么存储元素"><a class="markdownIt-Anchor" href="#linkedhashset的底层使用什么存储元素">#</a> LinkedHashSet 的底层使用什么存储元素？</h2>
<p>LinkedHashSet 的底层使用 LinkedHashMap 存储元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> package java.util;</span><br><span class="line">    </span><br><span class="line">// LinkedHashSet继承自HashSet</span><br><span class="line"> public class LinkedHashSet&lt;E&gt;</span><br><span class="line">        extends HashSet&lt;E&gt;</span><br><span class="line">        implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">        private static final long serialVersionUID = -2851667679971038690L;</span><br><span class="line">    </span><br><span class="line">        // 传入容量和装载因子</span><br><span class="line">        public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">            super(initialCapacity, loadFactor, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 只传入容量, 装载因子默认为0.75</span><br><span class="line">        public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">            super(initialCapacity, .75f, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 使用默认容量16, 默认装载因子0.75</span><br><span class="line">        public LinkedHashSet() &#123;</span><br><span class="line">            super(16, .75f, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 将集合c中的所有元素添加到LinkedHashSet中</span><br><span class="line">        // 好奇怪, 这里计算容量的方式又变了</span><br><span class="line">        // HashSet中使用的是Math.max((int) (c.size()/.75f) + 1, 16)</span><br><span class="line">        // 这一点有点不得其解, 是作者偷懒？</span><br><span class="line">        public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 可分割的迭代器, 主要用于多线程并行迭代处理时使用</span><br><span class="line">        @Override</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            return Spliterators.spliterator(this, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linkedhashset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#linkedhashset是有序的吗怎么个有序法">#</a> LinkedHashSet 是有序的吗？怎么个有序法？</h2>
<p>LinkedHashSet 是有序的，它是按照插入的顺序排序的。</p>
<h2 id="linkedhashset支持按元素访问顺序排序吗"><a class="markdownIt-Anchor" href="#linkedhashset支持按元素访问顺序排序吗">#</a> LinkedHashSet 支持按元素访问顺序排序吗？</h2>
<p>不支持</p>
<p>首先，LinkedHashSet 所有的构造方法都是调用 HashSet 的同一个构造方法，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// HashSet的构造方法</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">            map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，通过调用 LinkedHashMap 的构造方法初始化 map，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">            super(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，这里把 accessOrder 写死为 false 了。</p>
<p>所以，LinkedHashSet 是不支持按访问顺序对元素排序的，只能按插入顺序排序。</p>
<h2 id="treeset真的是使用treemap来存储元素的吗"><a class="markdownIt-Anchor" href="#treeset真的是使用treemap来存储元素的吗">#</a> TreeSet 真的是使用 TreeMap 来存储元素的吗？</h2>
<p>通过源码分析我们知道 TreeSet 里面实际上是使用的 NavigableMap 来存储元素，虽然大部分时候这个 map 确实是 TreeMap，但不是所有时候都是 TreeMap。</p>
<p>因为有一个构造方法是 <code>TreeSet(NavigableMap&lt;E,Object&gt; m)</code> ，而且这是一个非 public 方法，通过调用关系我们可以发现这个构造方法都是在自己类中使用的，比如下面这个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123;</span><br><span class="line">            return new TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而这个 m 我们姑且认为它是 TreeMap，也就是调用 TreeMap 的 tailMap () 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) &#123;</span><br><span class="line">            return new AscendingSubMap&lt;&gt;(this,</span><br><span class="line">                                         false, fromKey, inclusive,</span><br><span class="line">                                         true,  null,    true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，返回的是 AscendingSubMap 对象，这个类的继承链是怎么样的呢？</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817183810.png" alt="202105091520593461.png"></p>
<p>可以看到，这个类并没有继承 TreeMap，不过通过源码分析也可以看出来这个类是组合了 TreeMap，也算和 TreeMap 有点关系，只是不是继承关系。</p>
<p>所以，TreeSet 的底层不完全是使用 TreeMap 来实现的，更准确地说，应该是 NavigableMap。</p>
<h2 id="treeset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#treeset是有序的吗怎么个有序法">#</a> TreeSet 是有序的吗？怎么个有序法？</h2>
<p>有序的，TreeSet 实现了 SortedSet 接口，它的有序性主要依赖于 NavigableMap 的有序性，而 NavigableMap 又继承自 SortedMap，这个接口的有序性是指按照 key 的自然排序保证的有序性，而 key 的自然排序又有两种实现方式，一种是 key 实现 Comparable 接口，一种是构造方法传入 Comparator 比较器。</p>
<h2 id="treeset和linkedhashset有何不同"><a class="markdownIt-Anchor" href="#treeset和linkedhashset有何不同">#</a> TreeSet 和 LinkedHashSet 有何不同？</h2>
<p>LinkedHashSet 并没有实现 SortedSet 接口，它的有序性主要依赖于 LinkedHashMap 的有序性，所以它的有序性是指按照插入顺序保证的有序性；</p>
<p>而 TreeSet 实现了 SortedSet 接口，它的有序性主要依赖于 NavigableMap 的有序性，而 NavigableMap 又继承自 SortedMap，这个接口的有序性是指按照 key 的自然排序保证的有序性，而 key 的自然排序又有两种实现方式，一种是 key 实现 Comparable 接口，一种是构造方法传入 Comparator 比较器。</p>
<h2 id="treeset和sortedset有什么区别和联系"><a class="markdownIt-Anchor" href="#treeset和sortedset有什么区别和联系">#</a> TreeSet 和 SortedSet 有什么区别和联系？</h2>
<p>TreeSet 实现了 NavigableSet 接口，而 NavigableSet 继承自 SortedSet 接口；TreeSet 实现了 SortedSet 接口；</p>
<h2 id="copyonwritearrayset是用map实现的吗"><a class="markdownIt-Anchor" href="#copyonwritearrayset是用map实现的吗">#</a> CopyOnWriteArraySet 是用 Map 实现的吗？</h2>
<p>CopyOnWriteArraySet 底层是使用 CopyOnWriteArrayList 存储元素的，所以它并不是使用 Map 来存储元素的。</p>
<h2 id="copyonwritearrayset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#copyonwritearrayset是有序的吗怎么个有序法">#</a> CopyOnWriteArraySet 是有序的吗？怎么个有序法？</h2>
<p>有序，因为底层是 CopyOnWriteArrayList 存储元素的，所以是个数组。</p>
<h2 id="copyonwritearrayset怎么保证并发安全"><a class="markdownIt-Anchor" href="#copyonwritearrayset怎么保证并发安全">#</a> CopyOnWriteArraySet 怎么保证并发安全？</h2>
<p>CopyOnWriteArraySet 是并发安全的，而且实现了读写分离；因为底层是 CopyOnWriteArrayList 存储元素的，所以见 CopyOnWriteArrayList 是如何实现并发安全的。</p>
<h2 id="copyonwritearrayset以何种方式保证元素不重复"><a class="markdownIt-Anchor" href="#copyonwritearrayset以何种方式保证元素不重复">#</a> CopyOnWriteArraySet 以何种方式保证元素不重复？</h2>
<p>在添加元素时调用了 CopyOnWriteArrayList 的 addIfAbsent () 方法来保证元素不重复。</p>
<p>CopyOnWriteArraySet 通过调用 CopyOnWriteArrayList 的 addIfAbsent () 方法来保证元素不重复</p>
<p>具体的见前文</p>
<h2 id="如何比较两个set中的元素是否完全一致"><a class="markdownIt-Anchor" href="#如何比较两个set中的元素是否完全一致">#</a> 如何比较两个 Set 中的元素是否完全一致？</h2>
<p>假设有两个 Set，一个是 A，一个是 B。</p>
<p>最简单的方式就是判断是否 A 中的元素都在 B 中，B 中的元素是否都在 A 中，也就是两次两层循环。</p>
<p>其实，并不需要。</p>
<p>因为 Set 中的元素并不重复，所以只要先比较两个 Set 的元素个数是否相等，再作一次两层循环就可以了，需要仔细体味。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class CopyOnWriteArraySetTest &#123;</span><br><span class="line">    </span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set1 = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">            set1.add(1);</span><br><span class="line">            set1.add(5);</span><br><span class="line">            set1.add(2);</span><br><span class="line">            set1.add(7);</span><br><span class="line">    //        set1.add(3);</span><br><span class="line">            set1.add(4);</span><br><span class="line">    </span><br><span class="line">            Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;();</span><br><span class="line">            set2.add(1);</span><br><span class="line">            set2.add(5);</span><br><span class="line">            set2.add(2);</span><br><span class="line">            set2.add(7);</span><br><span class="line">            set2.add(3);</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(set1, set2));</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(set2, set1));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private static &lt;T&gt; boolean eq(Set&lt;T&gt; set1, Set&lt;T&gt; set2) &#123;</span><br><span class="line">            if (set1.size() != set2.size()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            for (T t : set1) &#123;</span><br><span class="line">                // contains相当于一层for循环</span><br><span class="line">                if (!set2.contains(t)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="如何比较两个list中的元素是否完全相等呢"><a class="markdownIt-Anchor" href="#如何比较两个list中的元素是否完全相等呢">#</a> 如何比较两个 List 中的元素是否完全相等呢？</h2>
<p>我们知道，List 中元素是可以重复的，那是不是要做两次两层循环呢？</p>
<p>其实，也不需要做两次两层遍历，一次也可以搞定，设定一个标记数组，标记某个位置的元素是否找到过，请仔细体味。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ListEqTest &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">            list1.add(1);</span><br><span class="line">            list1.add(3);</span><br><span class="line">            list1.add(6);</span><br><span class="line">            list1.add(3);</span><br><span class="line">            list1.add(8);</span><br><span class="line">            list1.add(5);</span><br><span class="line">    </span><br><span class="line">            List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">            list2.add(3);</span><br><span class="line">            list2.add(1);</span><br><span class="line">            list2.add(3);</span><br><span class="line">            list2.add(8);</span><br><span class="line">            list2.add(5);</span><br><span class="line">            list2.add(6);</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(list1, list2));</span><br><span class="line">            System.out.println(eq(list2, list1));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private static &lt;T&gt; boolean eq(List&lt;T&gt; list1, List&lt;T&gt; list2) &#123;</span><br><span class="line">            if (list1.size() != list2.size()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 标记某个元素是否找到过，防止重复</span><br><span class="line">            boolean matched[] = new boolean[list2.size()];</span><br><span class="line">    </span><br><span class="line">            outer: for (T t : list1) &#123;</span><br><span class="line">                for (int i = 0; i &lt; list2.size(); i++) &#123;</span><br><span class="line">                    // i这个位置没找到过才比较大小</span><br><span class="line">                    if (!matched[i] &amp;&amp; list2.get(i).equals(t)) &#123;</span><br><span class="line">                        matched[i] = true;</span><br><span class="line">                        continue outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="concurrentskiplistset的底层是concurrentskiplistmap吗"><a class="markdownIt-Anchor" href="#concurrentskiplistset的底层是concurrentskiplistmap吗">#</a> ConcurrentSkipListSet 的底层是 ConcurrentSkipListMap 吗？</h2>
<p>ConcurrentSkipListSet 底层是通过 ConcurrentNavigableMap 来实现的，它是一个有序的线程安全的集合。</p>
<h2 id="concurrentskiplistset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#concurrentskiplistset是有序的吗怎么个有序法">#</a> ConcurrentSkipListSet 是有序的吗？怎么个有序法？</h2>
<p>ConcurrentSkipListSet 有序的，基于元素的自然排序或者通过比较器确定的顺序；</p>
<h2 id="concurrentskiplistset源码"><a class="markdownIt-Anchor" href="#concurrentskiplistset源码">#</a> ConcurrentSkipListSet 源码？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 实现了NavigableSet接口，并没有所谓的ConcurrentNavigableSet接口</span><br><span class="line">public class ConcurrentSkipListSet&lt;E&gt;</span><br><span class="line">        extends AbstractSet&lt;E&gt;</span><br><span class="line">        implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">        private static final long serialVersionUID = -2479143111061671589L;</span><br><span class="line">    </span><br><span class="line">        // 存储使用的map</span><br><span class="line">        private final ConcurrentNavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    </span><br><span class="line">        // 初始化</span><br><span class="line">        public ConcurrentSkipListSet() &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 传入比较器</span><br><span class="line">        public ConcurrentSkipListSet(Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;(comparator);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 使用ConcurrentSkipListMap初始化map</span><br><span class="line">        // 并将集合c中所有元素放入到map中</span><br><span class="line">        public ConcurrentSkipListSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 使用ConcurrentSkipListMap初始化map</span><br><span class="line">        // 并将有序Set中所有元素放入到map中</span><br><span class="line">        public ConcurrentSkipListSet(SortedSet&lt;E&gt; s) &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;(s.comparator());</span><br><span class="line">            addAll(s);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // ConcurrentSkipListSet类内部返回子set时使用的</span><br><span class="line">        ConcurrentSkipListSet(ConcurrentNavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">            this.m = m;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 克隆方法</span><br><span class="line">        public ConcurrentSkipListSet&lt;E&gt; clone() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                ConcurrentSkipListSet&lt;E&gt; clone =</span><br><span class="line">                    (ConcurrentSkipListSet&lt;E&gt;) super.clone();</span><br><span class="line">                clone.setMap(new ConcurrentSkipListMap&lt;E,Object&gt;(m));</span><br><span class="line">                return clone;</span><br><span class="line">            &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">                throw new InternalError();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /* ---------------- Set operations -------------- */</span><br><span class="line">        // 返回元素个数</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return m.size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否为空</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            return m.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否包含某个元素</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return m.containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 添加一个元素</span><br><span class="line">        // 调用map的putIfAbsent()方法</span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            return m.putIfAbsent(e, Boolean.TRUE) == null;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 移除一个元素</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return m.remove(o, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 清空所有元素</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            m.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 迭代器</span><br><span class="line">        public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">            return m.navigableKeySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 降序迭代器</span><br><span class="line">        public Iterator&lt;E&gt; descendingIterator() &#123;</span><br><span class="line">            return m.descendingKeySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        /* ---------------- AbstractSet Overrides -------------- */</span><br><span class="line">        // 比较相等方法</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            // Override AbstractSet version to avoid calling size()</span><br><span class="line">            if (o == this)</span><br><span class="line">                return true;</span><br><span class="line">            if (!(o instanceof Set))</span><br><span class="line">                return false;</span><br><span class="line">            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 这里是通过两次两层for循环来比较</span><br><span class="line">                // 这里是有很大优化空间的，参考上篇文章CopyOnWriteArraySet中的彩蛋</span><br><span class="line">                return containsAll(c) &amp;&amp; c.containsAll(this);</span><br><span class="line">            &#125; catch (ClassCastException unused) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; catch (NullPointerException unused) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 移除集合c中所有元素</span><br><span class="line">        public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">            // Override AbstractSet version to avoid unnecessary call to size()</span><br><span class="line">            boolean modified = false;</span><br><span class="line">            for (Object e : c)</span><br><span class="line">                if (remove(e))</span><br><span class="line">                    modified = true;</span><br><span class="line">            return modified;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /* ---------------- Relational operations -------------- */</span><br><span class="line">    </span><br><span class="line">        // 小于e的最大元素</span><br><span class="line">        public E lower(E e) &#123;</span><br><span class="line">            return m.lowerKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 小于等于e的最大元素</span><br><span class="line">        public E floor(E e) &#123;</span><br><span class="line">            return m.floorKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 大于等于e的最小元素</span><br><span class="line">        public E ceiling(E e) &#123;</span><br><span class="line">            return m.ceilingKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 大于e的最小元素</span><br><span class="line">        public E higher(E e) &#123;</span><br><span class="line">            return m.higherKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 弹出最小的元素</span><br><span class="line">        public E pollFirst() &#123;</span><br><span class="line">            Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry();</span><br><span class="line">            return (e == null) ? null : e.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 弹出最大的元素</span><br><span class="line">        public E pollLast() &#123;</span><br><span class="line">            Map.Entry&lt;E,Object&gt; e = m.pollLastEntry();</span><br><span class="line">            return (e == null) ? null : e.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        /* ---------------- SortedSet operations -------------- */</span><br><span class="line">    </span><br><span class="line">        // 取比较器</span><br><span class="line">        public Comparator&lt;? super E&gt; comparator() &#123;</span><br><span class="line">            return m.comparator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 最小的元素</span><br><span class="line">        public E first() &#123;</span><br><span class="line">            return m.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 最大的元素</span><br><span class="line">        public E last() &#123;</span><br><span class="line">            return m.lastKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取两个元素之间的子set</span><br><span class="line">        public NavigableSet&lt;E&gt; subSet(E fromElement,</span><br><span class="line">                                      boolean fromInclusive,</span><br><span class="line">                                      E toElement,</span><br><span class="line">                                      boolean toInclusive) &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;</span><br><span class="line">                (m.subMap(fromElement, fromInclusive,</span><br><span class="line">                          toElement,   toInclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取头子set</span><br><span class="line">        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取尾子set</span><br><span class="line">        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取子set，包含from，不包含to</span><br><span class="line">        public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) &#123;</span><br><span class="line">            return subSet(fromElement, true, toElement, false);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取头子set，不包含to</span><br><span class="line">        public NavigableSet&lt;E&gt; headSet(E toElement) &#123;</span><br><span class="line">            return headSet(toElement, false);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取尾子set，包含from</span><br><span class="line">        public NavigableSet&lt;E&gt; tailSet(E fromElement) &#123;</span><br><span class="line">            return tailSet(fromElement, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 降序set</span><br><span class="line">        public NavigableSet&lt;E&gt; descendingSet() &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;(m.descendingMap());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 可分割的迭代器</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            if (m instanceof ConcurrentSkipListMap)</span><br><span class="line">                return ((ConcurrentSkipListMap&lt;E,?&gt;)m).keySpliterator();</span><br><span class="line">            else</span><br><span class="line">                return (Spliterator&lt;E&gt;)((ConcurrentSkipListMap.SubMap&lt;E,?&gt;)m).keyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 原子更新map，给clone方法使用</span><br><span class="line">        private void setMap(ConcurrentNavigableMap&lt;E,Object&gt; map) &#123;</span><br><span class="line">            UNSAFE.putObjectVolatile(this, mapOffset, map);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 原子操作相关内容</span><br><span class="line">        private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">        private static final long mapOffset;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = ConcurrentSkipListSet.class;</span><br><span class="line">                mapOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(&quot;m&quot;));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="什么是堆什么是堆化"><a class="markdownIt-Anchor" href="#什么是堆什么是堆化">#</a> 什么是堆？什么是堆化？</h2>
<p>堆是一种特殊的树，只要满足下面两个条件，它就是一个堆：</p>
<p>（1）堆是一颗完全二叉树；</p>
<p>（2）堆中某个节点的值总是不大于（或不小于）其父节点的值。</p>
<p>其中，我们把根节点最大的堆叫做大顶堆，根节点最小的堆叫做小顶堆。</p>
<p>堆化（向下调整）、向上调整的前提都是：在二叉树中，只有一个位置不满足堆的性质，其它位置都满足堆的性质。<br>
向下调整 是让调整的结点与其孩子节点进行比较<br>
向上调整 是让调整的结点与其父亲结点进行比较</p>
<h2 id="什么是优先级队列"><a class="markdownIt-Anchor" href="#什么是优先级队列">#</a> 什么是优先级队列？</h2>
<h2 id="priorityqueue是怎么实现的"><a class="markdownIt-Anchor" href="#priorityqueue是怎么实现的">#</a> PriorityQueue 是怎么实现的？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> // 默认容量</span><br><span class="line">private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br><span class="line">// 存储元素的地方</span><br><span class="line">transient Object[] queue; // non-private to simplify nested class access</span><br><span class="line">// 元素个数</span><br><span class="line">private int size = 0;</span><br><span class="line">// 比较器</span><br><span class="line">private final Comparator&lt;? super E&gt; comparator;</span><br><span class="line">// 修改次数</span><br><span class="line">transient int modCount = 0; // non-private to simplify nested class access</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PriorityQueue 是一个小顶堆；</p>
<h2 id="priorityqueue是有序的吗"><a class="markdownIt-Anchor" href="#priorityqueue是有序的吗">#</a> PriorityQueue 是有序的吗？</h2>
<p>PriorityQueue 不是有序的，只有堆顶存储着最小的元素；</p>
<h2 id="priorityqueue入队-出队的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#priorityqueue入队-出队的时间复杂度各是多少">#</a> PriorityQueue 入队、出队的时间复杂度各是多少？</h2>
<p>建堆的时间复杂度是 O (n)；</p>
<p>堆的插入、删除元素的时间复杂度都是 O (log n)；</p>
<p>入队有两个方法，add (E e) 和 offer (E e)，两者是一致的，add (E e) 也是调用的 offer (E e)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        // 不支持null元素</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        // 取size</span><br><span class="line">        int i = size;</span><br><span class="line">        // 元素个数达到最大容量了，扩容</span><br><span class="line">        if (i &gt;= queue.length)</span><br><span class="line">            grow(i + 1);</span><br><span class="line">        // 元素个数加1</span><br><span class="line">        size = i + 1;</span><br><span class="line">        // 如果还没有元素</span><br><span class="line">        // 直接插入到数组第一个位置</span><br><span class="line">        // 这里跟我们之前讲堆不一样了</span><br><span class="line">        // java里面是从0开始的</span><br><span class="line">        // 我们说的堆是从1开始的</span><br><span class="line">        if (i == 0)</span><br><span class="line">            queue[0] = e;</span><br><span class="line">        else</span><br><span class="line">            // 否则，插入元素到数组size的位置，也就是最后一个元素的下一位</span><br><span class="line">            // 注意这里的size不是数组大小，而是元素个数</span><br><span class="line">            // 然后，再做自下而上的堆化</span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void siftUp(int k, E x) &#123;</span><br><span class="line">        // 根据是否有比较器，使用不同的方法</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private void siftUpComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            // 找到父节点的位置</span><br><span class="line">            // 因为元素是从0开始的，所以减1之后再除以2</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            // 父节点的值</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            // 比较插入的元素与父节点的值</span><br><span class="line">            // 如果比父节点大，则跳出循环</span><br><span class="line">            // 否则交换位置</span><br><span class="line">            if (key.compareTo((E) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 与父节点交换位置</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            // 现在插入的元素位置移到了父节点的位置</span><br><span class="line">            // 继续与父节点再比较</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后找到应该插入的位置，放入元素</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）入队不允许 null 元素；</p>
<p>（2）如果数组不够用了，先扩容；</p>
<p>（3）如果还没有元素，就插入下标 0 的位置；</p>
<p>（4）如果有元素了，就插入到最后一个元素往后的一个位置（实际并没有插入哈）；</p>
<p>（5）自下而上堆化，一直往上跟父节点比较；</p>
<p>（6）如果比父节点小，就与父节点交换位置，直到出现比父节点大为止；</p>
<p>（7）由此可见，PriorityQueue 是一个小顶堆。</p>
<p>出队有两个方法，remove () 和 poll ()，remove () 也是调用的 poll ()，只是没有元素的时候抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        // 调用poll弹出队首元素</span><br><span class="line">        E x = poll();</span><br><span class="line">        if (x != null)</span><br><span class="line">            // 有元素就返回弹出的元素</span><br><span class="line">            return x;</span><br><span class="line">        else</span><br><span class="line">            // 没有元素就抛出异常</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E poll() &#123;</span><br><span class="line">        // 如果size为0，说明没有元素</span><br><span class="line">        if (size == 0)</span><br><span class="line">            return null;</span><br><span class="line">        // 弹出元素，元素个数减1</span><br><span class="line">        int s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">        // 队列首元素</span><br><span class="line">        E result = (E) queue[0];</span><br><span class="line">        // 队列末元素</span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        // 将队列末元素删除</span><br><span class="line">        queue[s] = null;</span><br><span class="line">        // 如果弹出元素后还有元素</span><br><span class="line">        if (s != 0)</span><br><span class="line">            // 将队列末元素移到队列首</span><br><span class="line">            // 再做自上而下的堆化</span><br><span class="line">            siftDown(0, x);</span><br><span class="line">        // 返回弹出的元素</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void siftDown(int k, E x) &#123;</span><br><span class="line">        // 根据是否有比较器，选择不同的方法</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private void siftDownComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;</span><br><span class="line">        // 只需要比较一半就行了，因为叶子节点占了一半的元素</span><br><span class="line">        int half = size &gt;&gt;&gt; 1;        // loop while a non-leaf</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            // 寻找子节点的位置，这里加1是因为元素从0号位置开始</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1; // assume left child is least</span><br><span class="line">            // 左子节点的值</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            // 右子节点的位置</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)</span><br><span class="line">                // 左右节点取其小者</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            // 如果比子节点都小，则结束</span><br><span class="line">            if (key.compareTo((E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 如果比最小的子节点大，则交换位置</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            // 指针移到最小子节点的位置继续往下比较</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到正确的位置，放入元素</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）将队列首元素弹出；</p>
<p>（2）将队列末元素移到队列首；</p>
<p>（3）自上而下堆化，一直往下与最小的子节点比较；</p>
<p>（4）如果比最小的子节点大，就交换位置，再继续与最小的子节点比较；</p>
<p>（5）如果比最小的子节点小，就不用交换位置了，堆化结束；</p>
<p>（6）这就是堆中的删除堆顶元素；</p>
<h2 id="priorityqueue是否需要扩容扩容规则呢"><a class="markdownIt-Anchor" href="#priorityqueue是否需要扩容扩容规则呢">#</a> PriorityQueue 是否需要扩容？扩容规则呢？</h2>
<p>会因为 PriorityQueue 是无限增长的队列，元素不够用了会扩容，所以添加元素不会失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        // 旧容量</span><br><span class="line">        int oldCapacity = queue.length;</span><br><span class="line">        // Double size if small; else grow by 50%</span><br><span class="line">        // 旧容量小于64时，容量翻倍</span><br><span class="line">        // 旧容量大于等于64，容量只增加旧容量的一半</span><br><span class="line">        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="line">                                         (oldCapacity + 2) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; 1));</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        // 检查是否溢出</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">        // 创建出一个新容量大小的新数组并把旧数组元素拷贝过去</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）当数组比较小（小于 64）的时候每次扩容容量翻倍；</p>
<p>（2）当数组比较大的时候每次扩容只增加一半的容量；</p>
<h2 id="arrayblockingqueue的实现方式"><a class="markdownIt-Anchor" href="#arrayblockingqueue的实现方式">#</a> ArrayBlockingQueue 的实现方式？</h2>
<p>ArrayBlockingQueue 是 java 并发包下一个以数组实现的阻塞队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 使用数组存储元素</span><br><span class="line">    final Object[] items;</span><br><span class="line">    </span><br><span class="line">    // 取元素的指针</span><br><span class="line">    int takeIndex;</span><br><span class="line">    </span><br><span class="line">    // 放元素的指针</span><br><span class="line">    int putIndex;</span><br><span class="line">    </span><br><span class="line">    // 元素数量</span><br><span class="line">    int count;</span><br><span class="line">    </span><br><span class="line">    // 保证并发访问的锁</span><br><span class="line">    final ReentrantLock lock;</span><br><span class="line">    </span><br><span class="line">    // 非空条件</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    </span><br><span class="line">    // 非满条件</span><br><span class="line">    private final Condition notFull;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="arrayblockingqueue是否需要扩容"><a class="markdownIt-Anchor" href="#arrayblockingqueue是否需要扩容">#</a> ArrayBlockingQueue 是否需要扩容？</h2>
<p>ArrayBlockingQueue 不需要扩容，因为是初始化时指定容量，并循环利用数组；</p>
<p>ArrayBlockingQueue 利用 takeIndex 和 putIndex 循环利用数组</p>
<h2 id="arrayblockingqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#arrayblockingqueue怎么保证线程安全">#</a> ArrayBlockingQueue 怎么保证线程安全？</h2>
<p>利用重入锁和两个条件保证并发安全</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">      this(capacity, false);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">      if (capacity &lt;= 0)</span><br><span class="line">          throw new IllegalArgumentException();</span><br><span class="line">      // 初始化数组</span><br><span class="line">      this.items = new Object[capacity];</span><br><span class="line">      // 创建重入锁及两个条件</span><br><span class="line">      lock = new ReentrantLock(fair);</span><br><span class="line">      notEmpty = lock.newCondition();</span><br><span class="line">      notFull =  lock.newCondition();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>入队有四个方法，它们分别是 add (E e)、offer (E e)、put (E e)、offer (E e, long timeout, TimeUnit unit)，它们有什么区别呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        // 调用父类的add(e)方法</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // super.add(e)</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        // 调用offer(e)如果成功返回true，如果失败抛出异常</span><br><span class="line">        if (offer(e))</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        // 元素不可为空</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count == items.length)</span><br><span class="line">                // 如果数组满了就返回false</span><br><span class="line">                return false;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 如果数组没满就调用入队方法并返回true</span><br><span class="line">                enqueue(e);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁，如果线程中断了抛出异常</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果数组满了，使用notFull等待</span><br><span class="line">            // notFull等待的意思是说现在队列满了</span><br><span class="line">            // 只有取走一个元素后，队列才不满</span><br><span class="line">            // 然后唤醒notFull，然后继续现在的逻辑</span><br><span class="line">            // 这里之所以使用while而不是if</span><br><span class="line">            // 是因为有可能多个线程阻塞在lock上</span><br><span class="line">            // 即使唤醒了可能其它线程先一步修改了队列又变成满的了</span><br><span class="line">            // 这时候需要再次等待</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            // 入队</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        long nanos = unit.toNanos(timeout);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果数组满了，就阻塞nanos纳秒</span><br><span class="line">            // 如果唤醒这个线程时依然没有空间且时间到了就返回false</span><br><span class="line">            while (count == items.length) &#123;</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return false;</span><br><span class="line">                nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            // 入队</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void enqueue(E x) &#123;</span><br><span class="line">        final Object[] items = this.items;</span><br><span class="line">        // 把元素直接放在放指针的位置上</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        // 如果放指针到数组尽头了，就返回头部</span><br><span class="line">        if (++putIndex == items.length)</span><br><span class="line">            putIndex = 0;</span><br><span class="line">        // 数量加1</span><br><span class="line">        count++;</span><br><span class="line">        // 唤醒notEmpty，因为入队了一个元素，所以肯定不为空了</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）add (e) 时如果队列满了则抛出异常；</p>
<p>（2）offer (e) 时如果队列满了则返回 false；</p>
<p>（3）put (e) 时如果队列满了则使用 notFull 等待；</p>
<p>（4）offer (e, timeout, unit) 时如果队列满了则等待一段时间后如果队列依然满就返回 false；</p>
<p>（5）利用放指针循环使用数组来存储元素；</p>
<p>出队有四个方法，它们分别是 remove ()、poll ()、take ()、poll (long timeout, TimeUnit unit)，它们有什么区别呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        // 调用poll()方法出队</span><br><span class="line">        E x = poll();</span><br><span class="line">        if (x != null)</span><br><span class="line">            // 如果有元素出队就返回这个元素</span><br><span class="line">            return x;</span><br><span class="line">        else</span><br><span class="line">            // 如果没有元素出队就抛出异常</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E poll() &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列没有元素则返回null，否则出队</span><br><span class="line">            return (count == 0) ? null : dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列无元素，则阻塞等待在条件notEmpty上</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            // 有元素了再出队</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        long nanos = unit.toNanos(timeout);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列无元素，则阻塞等待nanos纳秒</span><br><span class="line">            // 如果下一次这个线程获得了锁但队列依然无元素且已超时就返回null</span><br><span class="line">            while (count == 0) &#123;</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private E dequeue() &#123;</span><br><span class="line">        final Object[] items = this.items;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        // 取取指针位置的元素</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        // 把取指针位置设为null</span><br><span class="line">        items[takeIndex] = null;</span><br><span class="line">        // 取指针前移，如果数组到头了就返回数组前端循环利用</span><br><span class="line">        if (++takeIndex == items.length)</span><br><span class="line">            takeIndex = 0;</span><br><span class="line">        // 元素数量减1</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs != null)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        // 唤醒notFull条件</span><br><span class="line">        notFull.signal();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）remove () 时如果队列为空则抛出异常；</p>
<p>（2）poll () 时如果队列为空则返回 null；</p>
<p>（3）take () 时如果队列为空则阻塞等待在条件 notEmpty 上；</p>
<p>（4）poll (timeout, unit) 时如果队列为空则阻塞等待一段时间后如果还为空就返回 null；</p>
<p>（5）利用取指针循环从数组中取元素；</p>
<h2 id="arrayblockingqueue有什么缺点"><a class="markdownIt-Anchor" href="#arrayblockingqueue有什么缺点">#</a> ArrayBlockingQueue 有什么缺点？</h2>
<p>a）队列长度固定且必须在初始化时指定，所以使用之前一定要慎重考虑好容量；</p>
<p>b）如果消费速度跟不上入队速度，则会导致提供者线程一直阻塞，且越阻塞越多，非常危险；</p>
<p>c）只使用了一个锁来控制入队出队，效率较低。</p>
<h2 id="linkedblockingqueue的实现方式"><a class="markdownIt-Anchor" href="#linkedblockingqueue的实现方式">#</a> LinkedBlockingQueue 的实现方式？</h2>
<p>LinkedBlockingQueue 采用单链表的形式实现；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">    </span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linkedblockingqueue是有界的还是无界的队列"><a class="markdownIt-Anchor" href="#linkedblockingqueue是有界的还是无界的队列">#</a> LinkedBlockingQueue 是有界的还是无界的队列？</h2>
<p>LinkedBlockingQueue 是有界队列，不传入容量时默认为最大 int 值；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public LinkedBlockingQueue() &#123;</span><br><span class="line">        // 如果没传容量，就使用最大int值初始化其容量</span><br><span class="line">        this(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">        if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        // 初始化head和last指针为空值节点</span><br><span class="line">        last = head = new Node&lt;E&gt;(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linkedblockingqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#linkedblockingqueue怎么保证线程安全">#</a> LinkedBlockingQueue 怎么保证线程安全？</h2>
<p>LinkedBlockingQueue 采用两把锁的锁分离技术实现入队出队互不阻塞；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 容量</span><br><span class="line">    private final int capacity;</span><br><span class="line">    </span><br><span class="line">    // 元素数量</span><br><span class="line">    private final AtomicInteger count = new AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    // 链表头</span><br><span class="line">    transient Node&lt;E&gt; head;</span><br><span class="line">    </span><br><span class="line">    // 链表尾</span><br><span class="line">    private transient Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    // take锁</span><br><span class="line">    private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    // notEmpty条件</span><br><span class="line">    // 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span><br><span class="line">    private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line">    </span><br><span class="line">    // 放锁</span><br><span class="line">    private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    // notFull条件</span><br><span class="line">    // 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span><br><span class="line">    private final Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linkedblockingqueue与arrayblockingqueue对比"><a class="markdownIt-Anchor" href="#linkedblockingqueue与arrayblockingqueue对比">#</a> LinkedBlockingQueue 与 ArrayBlockingQueue 对比？</h2>
<p>a）后者入队出队采用一把锁，导致入队出队相互阻塞，效率低下；</p>
<p>b）前才入队出队采用两把锁，入队出队互不干扰，效率较高；</p>
<p>c）二者都是有界队列，如果长度相等且出队速度跟不上入队速度，都会导致大量线程阻塞；</p>
<p>d）前者如果初始化不传入初始容量，则使用最大 int 值，如果出队速度跟不上入队速度，会导致队列特别长，占用大量内存；</p>
<h2 id="synchronousqueue的实现方式"><a class="markdownIt-Anchor" href="#synchronousqueue的实现方式">#</a> SynchronousQueue 的实现方式？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// Transferer抽象类，主要定义了一个transfer方法用来传输元素</span><br><span class="line">   abstract static class Transferer&lt;E&gt; &#123;</span><br><span class="line">       abstract E transfer(E e, boolean timed, long nanos);</span><br><span class="line">   &#125;</span><br><span class="line">   // 以栈方式实现的Transferer</span><br><span class="line">   static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123;</span><br><span class="line">       // 栈中节点的几种类型：</span><br><span class="line">       // 1. 消费者（请求数据的）</span><br><span class="line">       static final int REQUEST    = 0;</span><br><span class="line">       // 2. 生产者（提供数据的）</span><br><span class="line">       static final int DATA       = 1;</span><br><span class="line">       // 3. 二者正在撮合中</span><br><span class="line">       static final int FULFILLING = 2;</span><br><span class="line">   </span><br><span class="line">       // 栈中的节点</span><br><span class="line">       static final class SNode &#123;</span><br><span class="line">           // 下一个节点</span><br><span class="line">           volatile SNode next;        // next node in stack</span><br><span class="line">           // 匹配者</span><br><span class="line">           volatile SNode match;       // the node matched to this</span><br><span class="line">           // 等待着的线程</span><br><span class="line">           volatile Thread waiter;     // to control park/unpark</span><br><span class="line">           // 元素</span><br><span class="line">           Object item;                // data; or null for REQUESTs</span><br><span class="line">           // 模式，也就是节点的类型，是消费者，是生产者，还是正在撮合中</span><br><span class="line">           int mode;</span><br><span class="line">       &#125;</span><br><span class="line">       // 栈的头节点</span><br><span class="line">       volatile SNode head;</span><br><span class="line">   &#125;</span><br><span class="line">   // 以队列方式实现的Transferer</span><br><span class="line">   static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; &#123;</span><br><span class="line">       // 队列中的节点</span><br><span class="line">       static final class QNode &#123;</span><br><span class="line">           // 下一个节点</span><br><span class="line">           volatile QNode next;          // next node in queue</span><br><span class="line">           // 存储的元素</span><br><span class="line">           volatile Object item;         // CAS&#x27;ed to or from null</span><br><span class="line">           // 等待着的线程</span><br><span class="line">           volatile Thread waiter;       // to control park/unpark</span><br><span class="line">           // 是否是数据节点</span><br><span class="line">           final boolean isData;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 队列的头节点</span><br><span class="line">       transient volatile QNode head;</span><br><span class="line">       // 队列的尾节点</span><br><span class="line">       transient volatile QNode tail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）定义了一个抽象类 Transferer，里面定义了一个传输元素的方法；</p>
<p>（2）有两种传输元素的方法，一种是栈，一种是队列；</p>
<p>（3）栈的特点是后进先出，队列的特点是先进行出；</p>
<p>（4）栈只需要保存一个头节点就可以了，因为存取元素都是操作头节点；</p>
<p>（5）队列需要保存一个头节点一个尾节点，因为存元素操作尾节点，取元素操作头节点；</p>
<p>（6）每个节点中保存着存储的元素、等待着的线程，以及下一个节点；</p>
<h2 id="synchronousqueue真的是无缓冲的吗"><a class="markdownIt-Anchor" href="#synchronousqueue真的是无缓冲的吗">#</a> SynchronousQueue 真的是无缓冲的吗？</h2>
<p>通过源码分析，我们可以发现其实 SynchronousQueue 内部或者使用栈或者使用队列来存储包含线程和元素值的节点，如果同一个模式的节点过多的话，它们都会存储进来，且都会阻塞着，所以，严格上来说，SynchronousQueue 并不能算是一个无缓冲队列。</p>
<h2 id="synchronousqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#synchronousqueue怎么保证线程安全">#</a> SynchronousQueue 怎么保证线程安全？</h2>
<p>我们这里主要介绍以栈方式实现的传输模式，以 put (E e) 方法为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        // 元素不可为空</span><br><span class="line">        if (e == null) throw new NullPointerException();</span><br><span class="line">        // 直接调用传输器的transfer()方法</span><br><span class="line">        // 三个参数分别是：传输的元素，是否需要超时，超时的时间</span><br><span class="line">        if (transferer.transfer(e, false, 0) == null) &#123;</span><br><span class="line">            // 如果传输失败，直接让线程中断并抛出中断异常</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用 transferer 的 transfer () 方法，传入元素 e，说明是生产者</p>
<p>我们这里主要介绍以栈方式实现的传输模式，以 take () 方法为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">       // 直接调用传输器的transfer()方法</span><br><span class="line">       // 三个参数分别是：null，是否需要超时，超时的时间</span><br><span class="line">       // 第一个参数为null表示是消费者，要取元素</span><br><span class="line">       E e = transferer.transfer(null, false, 0);</span><br><span class="line">       // 如果取到了元素就返回</span><br><span class="line">       if (e != null)</span><br><span class="line">           return e;</span><br><span class="line">       // 否则让线程中断并抛出中断异常</span><br><span class="line">       Thread.interrupted();</span><br><span class="line">       throw new InterruptedException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用 transferer 的 transfer () 方法，传入 null，说明是消费者。</p>
<h3 id="transfer方法"><a class="markdownIt-Anchor" href="#transfer方法">#</a> transfer () 方法</h3>
<p>transfer () 方法同时实现了取元素和放元素的功能，下面我再来看看这个 transfer () 方法里究竟干了什么。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// TransferStack.transfer()方法</span><br><span class="line">    E transfer(E e, boolean timed, long nanos) &#123;</span><br><span class="line">        SNode s = null; // constructed/reused as needed</span><br><span class="line">        // 根据e是否为null决定是生产者还是消费者</span><br><span class="line">        int mode = (e == null) ? REQUEST : DATA;</span><br><span class="line">        // 自旋+CAS，熟悉的套路，熟悉的味道</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 栈顶元素</span><br><span class="line">            SNode h = head;</span><br><span class="line">            // 栈顶没有元素，或者栈顶元素跟当前元素是一个模式的</span><br><span class="line">            // 也就是都是生产者节点或者都是消费者节点</span><br><span class="line">            if (h == null || h.mode == mode) &#123;  // empty or same-mode</span><br><span class="line">                // 如果有超时而且已到期</span><br><span class="line">                if (timed &amp;&amp; nanos &lt;= 0) &#123;      // can&#x27;t wait</span><br><span class="line">                    // 如果头节点不为空且是取消状态</span><br><span class="line">                    if (h != null &amp;&amp; h.isCancelled())</span><br><span class="line">                        // 就把头节点弹出，并进入下一次循环</span><br><span class="line">                        casHead(h, h.next);     // pop cancelled node</span><br><span class="line">                    else</span><br><span class="line">                        // 否则，直接返回null（超时返回null）</span><br><span class="line">                        return null;</span><br><span class="line">                &#125; else if (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                    // 入栈成功（因为是模式相同的，所以只能入栈）</span><br><span class="line">                    // 调用awaitFulfill()方法自旋+阻塞当前入栈的线程并等待被匹配到</span><br><span class="line">                    SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                    // 如果m等于s，说明取消了，那么就把它清除掉，并返回null</span><br><span class="line">                    if (m == s) &#123;               // wait was cancelled</span><br><span class="line">                        clean(s);</span><br><span class="line">                        // 被取消了返回null</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    // 到这里说明匹配到元素了</span><br><span class="line">                    // 因为从awaitFulfill()里面出来要不被取消了要不就匹配到了</span><br><span class="line">    </span><br><span class="line">                    // 如果头节点不为空，并且头节点的下一个节点是s</span><br><span class="line">                    // 就把头节点换成s的下一个节点</span><br><span class="line">                    // 也就是把h和s都弹出了</span><br><span class="line">                    // 也就是把栈顶两个元素都弹出了</span><br><span class="line">                    if ((h = head) != null &amp;&amp; h.next == s)</span><br><span class="line">                        casHead(h, s.next);     // help s&#x27;s fulfiller</span><br><span class="line">                    // 根据当前节点的模式判断返回m还是s中的值</span><br><span class="line">                    return (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!isFulfilling(h.mode)) &#123; // try to fulfill</span><br><span class="line">                // 到这里说明头节点和当前节点模式不一样</span><br><span class="line">                // 如果头节点不是正在撮合中</span><br><span class="line">    </span><br><span class="line">                // 如果头节点已经取消了，就把它弹出栈</span><br><span class="line">                if (h.isCancelled())            // already cancelled</span><br><span class="line">                    casHead(h, h.next);         // pop and retry</span><br><span class="line">                else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                    // 头节点没有在撮合中，就让当前节点先入队，再让他们尝试匹配</span><br><span class="line">                    // 且s成为了新的头节点，它的状态是正在撮合中</span><br><span class="line">                    for (;;) &#123; // loop until matched or waiters disappear</span><br><span class="line">                        SNode m = s.next;       // m is s&#x27;s match</span><br><span class="line">                        // 如果m为null，说明除了s节点外的节点都被其它线程先一步撮合掉了</span><br><span class="line">                        // 就清空栈并跳出内部循环，到外部循环再重新入栈判断</span><br><span class="line">                        if (m == null) &#123;        // all waiters are gone</span><br><span class="line">                            casHead(s, null);   // pop fulfill node</span><br><span class="line">                            s = null;           // use new node next time</span><br><span class="line">                            break;              // restart main loop</span><br><span class="line">                        &#125;</span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        // 如果m和s尝试撮合成功，就弹出栈顶的两个元素m和s</span><br><span class="line">                        if (m.tryMatch(s)) &#123;</span><br><span class="line">                            casHead(s, mn);     // pop both s and m</span><br><span class="line">                            // 返回撮合结果</span><br><span class="line">                            return (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                        &#125; else                  // lost match</span><br><span class="line">                            // 尝试撮合失败，说明m已经先一步被其它线程撮合了</span><br><span class="line">                            // 就协助清除它</span><br><span class="line">                            s.casNext(m, mn);   // help unlink</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;                            // help a fulfiller</span><br><span class="line">                // 到这里说明当前节点和头节点模式不一样</span><br><span class="line">                // 且头节点是正在撮合中</span><br><span class="line">    </span><br><span class="line">                SNode m = h.next;               // m is h&#x27;s match</span><br><span class="line">                if (m == null)                  // waiter is gone</span><br><span class="line">                    // 如果m为null，说明m已经被其它线程先一步撮合了</span><br><span class="line">                    casHead(h, null);           // pop fulfilling node</span><br><span class="line">                else &#123;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    // 协助匹配，如果m和s尝试撮合成功，就弹出栈顶的两个元素m和s</span><br><span class="line">                    if (m.tryMatch(h))          // help match</span><br><span class="line">                        // 将栈顶的两个元素弹出后，再让s重新入栈</span><br><span class="line">                        casHead(h, mn);         // pop both h and m</span><br><span class="line">                    else                        // lost match</span><br><span class="line">                        // 尝试撮合失败，说明m已经先一步被其它线程撮合了</span><br><span class="line">                        // 就协助清除它</span><br><span class="line">                        h.casNext(m, mn);       // help unlink</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 三个参数：需要等待的节点，是否需要超时，超时时间</span><br><span class="line">    SNode awaitFulfill(SNode s, boolean timed, long nanos) &#123;</span><br><span class="line">        // 到期时间</span><br><span class="line">        final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">        // 当前线程</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        // 自旋次数</span><br><span class="line">        int spins = (shouldSpin(s) ?</span><br><span class="line">                     (timed ? maxTimedSpins : maxUntimedSpins) : 0);</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 当前线程中断了，尝试清除s</span><br><span class="line">            if (w.isInterrupted())</span><br><span class="line">                s.tryCancel();</span><br><span class="line">    </span><br><span class="line">            // 检查s是否匹配到了元素m（有可能是其它线程的m匹配到当前线程的s）</span><br><span class="line">            SNode m = s.match;</span><br><span class="line">            // 如果匹配到了，直接返回m</span><br><span class="line">            if (m != null)</span><br><span class="line">                return m;</span><br><span class="line">    </span><br><span class="line">            // 如果需要超时</span><br><span class="line">            if (timed) &#123;</span><br><span class="line">                // 检查超时时间如果小于0了，尝试清除s</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                if (nanos &lt;= 0L) &#123;</span><br><span class="line">                    s.tryCancel();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (spins &gt; 0)</span><br><span class="line">                // 如果还有自旋次数，自旋次数减一，并进入下一次自旋</span><br><span class="line">                spins = shouldSpin(s) ? (spins-1) : 0;</span><br><span class="line">    </span><br><span class="line">            // 后面的elseif都是自旋次数没有了</span><br><span class="line">            else if (s.waiter == null)</span><br><span class="line">                // 如果s的waiter为null，把当前线程注入进去，并进入下一次自旋</span><br><span class="line">                s.waiter = w; // establish waiter so can park next iter</span><br><span class="line">            else if (!timed)</span><br><span class="line">                // 如果不允许超时，直接阻塞，并等待被其它线程唤醒，唤醒后继续自旋并查看是否匹配到了元素</span><br><span class="line">                LockSupport.park(this);</span><br><span class="line">            else if (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                // 如果允许超时且还有剩余时间，就阻塞相应时间</span><br><span class="line">                LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        // SNode里面的方向，调用者m是s的下一个节点</span><br><span class="line">        // 这时候m节点的线程应该是阻塞状态的</span><br><span class="line"> boolean tryMatch(SNode s) &#123;</span><br><span class="line">            // 如果m还没有匹配者，就把s作为它的匹配者</span><br><span class="line">            if (match == null &amp;&amp;</span><br><span class="line">                UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123;</span><br><span class="line">                Thread w = waiter;</span><br><span class="line">                if (w != null) &#123;    // waiters need at most one unpark</span><br><span class="line">                    waiter = null;</span><br><span class="line">                    // 唤醒m中的线程，两者匹配完毕</span><br><span class="line">                    LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                // 匹配到了返回true</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // 可能其它线程先一步匹配了m，返回其是否是s</span><br><span class="line">            return match == s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整个逻辑比较复杂，这里为了简单起见，屏蔽掉多线程处理的细节，只描述正常业务场景下的逻辑：</p>
<p>（1）如果栈中没有元素，或者栈顶元素跟将要入栈的元素模式一样，就入栈；</p>
<p>（2）入栈后自旋等待一会看有没有其它线程匹配到它，自旋完了还没匹配到元素就阻塞等待；</p>
<p>（3）阻塞等待被唤醒了说明其它线程匹配到了当前的元素，就返回匹配到的元素；</p>
<p>（4）如果两者模式不一样，且头节点没有在匹配中，就拿当前节点跟它匹配，匹配成功了就返回匹配到的元素；</p>
<p>（5）如果两者模式不一样，且头节点正在匹配中，当前线程就协助去匹配，匹配完成了再让当前节点重新入栈重新匹配；</p>
<h2 id="synchronousqueue的公平模式和非公平模式有什么区别"><a class="markdownIt-Anchor" href="#synchronousqueue的公平模式和非公平模式有什么区别">#</a> SynchronousQueue 的公平模式和非公平模式有什么区别？</h2>
<p>SynchronousQueue 有两种实现方式，一种是公平（队列）方式，一种是非公平（栈）方式；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public SynchronousQueue() &#123;</span><br><span class="line">       // 默认非公平模式</span><br><span class="line">       this(false);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public SynchronousQueue(boolean fair) &#123;</span><br><span class="line">       // 如果是公平模式就使用队列，如果是非公平模式就使用栈</span><br><span class="line">       transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="synchronousqueue在高并发情景下会有什么问题"><a class="markdownIt-Anchor" href="#synchronousqueue在高并发情景下会有什么问题">#</a> SynchronousQueue 在高并发情景下会有什么问题？</h2>
<p>试想一下，如果有多个生产者，但只有一个消费者，如果消费者处理不过来，是不是生产者都会阻塞起来？反之亦然。</p>
<p>这是一件很危险的事，所以，SynchronousQueue 一般用于生产、消费的速度大致相当的情况，这样才不会导致系统中过多的线程处于阻塞状态。</p>
<h2 id="priorityblockingqueue的实现方式"><a class="markdownIt-Anchor" href="#priorityblockingqueue的实现方式">#</a> PriorityBlockingQueue 的实现方式？</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 默认容量为11</span><br><span class="line">private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br><span class="line">// 最大数组大小</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line">// 存储元素的地方</span><br><span class="line">private transient Object[] queue;</span><br><span class="line">// 元素个数</span><br><span class="line">private transient int size;</span><br><span class="line">// 比较器</span><br><span class="line">private transient Comparator&lt;? super E&gt; comparator;</span><br><span class="line">// 重入锁</span><br><span class="line">private final ReentrantLock lock;</span><br><span class="line">// 非空条件</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">// 扩容的时候使用的控制变量，CAS更新这个值，谁更新成功了谁扩容，其它线程让出CPU</span><br><span class="line">private transient volatile int allocationSpinLock;</span><br><span class="line">// 不阻塞的优先级队列，非存储元素的地方，仅用于序列化/反序列化时</span><br><span class="line">private PriorityQueue&lt;E&gt; q;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）依然是使用一个数组来使用元素；</p>
<p>（2）使用一个锁加一个 notEmpty 条件来保证并发安全；</p>
<p>（3）使用一个变量的 CAS 操作来控制扩容；</p>
<h2 id="priorityblockingqueue是否需要扩容"><a class="markdownIt-Anchor" href="#priorityblockingqueue是否需要扩容">#</a> PriorityBlockingQueue 是否需要扩容？</h2>
<p>PriorityBlockingQueue 扩容时使用一个单独变量的 CAS 操作来控制只有一个线程进行扩容；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void tryGrow(Object[] array, int oldCap) &#123;</span><br><span class="line">       // 先释放锁，因为是从offer()方法的锁内部过来的</span><br><span class="line">       // 这里先释放锁，使用allocationSpinLock变量控制扩容的过程</span><br><span class="line">       // 防止阻塞的线程过多</span><br><span class="line">       lock.unlock(); // must release and then re-acquire main lock</span><br><span class="line">       Object[] newArray = null;</span><br><span class="line">       // CAS更新allocationSpinLock变量为1的线程获得扩容资格</span><br><span class="line">       if (allocationSpinLock == 0 &amp;&amp;</span><br><span class="line">           UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,</span><br><span class="line">                                    0, 1)) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 旧容量小于64则翻倍，旧容量大于64则增加一半</span><br><span class="line">               int newCap = oldCap + ((oldCap &lt; 64) ?</span><br><span class="line">                                      (oldCap + 2) : // grow faster if small</span><br><span class="line">                                      (oldCap &gt;&gt; 1));</span><br><span class="line">               // 判断新容量是否溢出</span><br><span class="line">               if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123;    // possible overflow</span><br><span class="line">                   int minCap = oldCap + 1;</span><br><span class="line">                   if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                       throw new OutOfMemoryError();</span><br><span class="line">                   newCap = MAX_ARRAY_SIZE;</span><br><span class="line">               &#125;</span><br><span class="line">               // 创建新数组</span><br><span class="line">               if (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                   newArray = new Object[newCap];</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               // 相当于解锁</span><br><span class="line">               allocationSpinLock = 0;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 只有进入了上面条件的才会满足这个条件</span><br><span class="line">       // 意思是让其它线程让出CPU</span><br><span class="line">       if (newArray == null) // back off if another thread is allocating</span><br><span class="line">           Thread.yield();</span><br><span class="line">       // 再次加锁</span><br><span class="line">       lock.lock();</span><br><span class="line">       // 判断新数组创建成功并且旧数组没有被替换过</span><br><span class="line">       if (newArray != null &amp;&amp; queue == array) &#123;</span><br><span class="line">           // 队列赋值为新数组</span><br><span class="line">           queue = newArray;</span><br><span class="line">           // 并拷贝旧数组元素到新数组中</span><br><span class="line">           System.arraycopy(array, 0, newArray, 0, oldCap);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（1）解锁，解除 offer () 方法中加的锁；</p>
<p>（2）使用 allocationSpinLock 变量的 CAS 操作来控制扩容的过程；</p>
<p>（3）旧容量小于 64 则翻倍，旧容量大于 64 则增加一半；</p>
<p>（4）创建新数组；</p>
<p>（5）修改 allocationSpinLock 为 0，相当于解锁；</p>
<p>（6）其它线程在扩容的过程中要让出 CPU；</p>
<p>（7）再次加锁；</p>
<p>（8）新数组创建成功，把旧数组元素拷贝过来，并返回到 offer () 方法中继续添加元素操作；</p>
<h2 id="priorityblockingqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#priorityblockingqueue怎么保证线程安全">#</a> PriorityBlockingQueue 怎么保证线程安全？</h2>
<p>PriorityBlockingQueue 使用一个锁 + 一个 notEmpty 条件控制并发安全；</p>
<p>每个阻塞队列都有四个方法，我们这里只分析一个 offer (E e) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        // 元素不能为空</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        int n, cap;</span><br><span class="line">        Object[] array;</span><br><span class="line">        // 判断是否需要扩容，即元素个数达到了数组容量</span><br><span class="line">        while ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">            tryGrow(array, cap);</span><br><span class="line">        try &#123;</span><br><span class="line">            Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">            // 根据是否有比较器选择不同的方法</span><br><span class="line">            if (cmp == null)</span><br><span class="line">                siftUpComparable(n, e, array);</span><br><span class="line">            else</span><br><span class="line">                siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">            // 插入元素完毕，元素个数加1            </span><br><span class="line">            size = n + 1;</span><br><span class="line">            // 唤醒notEmpty条件</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123;</span><br><span class="line">        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            // 取父节点</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            // 父节点的元素值</span><br><span class="line">            Object e = array[parent];</span><br><span class="line">            // 如果key大于父节点，堆化结束</span><br><span class="line">            if (key.compareTo((T) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 否则，交换二者的位置，继续下一轮比较</span><br><span class="line">            array[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到了应该放的位置，放入元素</span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>入队的整个操作跟 PriorityQueue 几乎一致：</p>
<p>（1）加锁；</p>
<p>（2）判断是否需要扩容；</p>
<p>（3）添加元素并做自下而上的堆化；</p>
<p>（4）元素个数加 1 并唤醒 notEmpty 条件，唤醒取元素的线程；</p>
<p>（5）解锁；</p>
<p>阻塞队列的出队方法也有四个，我们这里只分析一个 take () 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        E result;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 队列没有元素，就阻塞在notEmpty条件上</span><br><span class="line">            // 出队成功，就跳出这个循环</span><br><span class="line">            while ( (result = dequeue()) == null)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回出队的元素</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private E dequeue() &#123;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        int n = size - 1;</span><br><span class="line">        if (n &lt; 0)</span><br><span class="line">            // 数组元素不足，返回null</span><br><span class="line">            return null;</span><br><span class="line">        else &#123;</span><br><span class="line">            Object[] array = queue;</span><br><span class="line">            // 弹出堆顶元素</span><br><span class="line">            E result = (E) array[0];</span><br><span class="line">            // 把堆尾元素拿到堆顶</span><br><span class="line">            E x = (E) array[n];</span><br><span class="line">            array[n] = null;</span><br><span class="line">            Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">            // 并做自上而下的堆化</span><br><span class="line">            if (cmp == null)</span><br><span class="line">                siftDownComparable(0, x, array, n);</span><br><span class="line">            else</span><br><span class="line">                siftDownUsingComparator(0, x, array, n, cmp);</span><br><span class="line">            // 修改size</span><br><span class="line">            size = n;</span><br><span class="line">            // 返回出队的元素</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array,</span><br><span class="line">                                               int n) &#123;</span><br><span class="line">        if (n &gt; 0) &#123;</span><br><span class="line">            Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;</span><br><span class="line">            int half = n &gt;&gt;&gt; 1;           // loop while a non-leaf</span><br><span class="line">            // 只需要遍历到叶子节点就够了</span><br><span class="line">            while (k &lt; half) &#123;</span><br><span class="line">                // 左子节点</span><br><span class="line">                int child = (k &lt;&lt; 1) + 1; // assume left child is least</span><br><span class="line">                // 左子节点的值</span><br><span class="line">                Object c = array[child];</span><br><span class="line">                // 右子节点</span><br><span class="line">                int right = child + 1;</span><br><span class="line">                // 取左右子节点中最小的值</span><br><span class="line">                if (right &lt; n &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)</span><br><span class="line">                    c = array[child = right];</span><br><span class="line">                // key如果比左右子节点都小，则堆化结束</span><br><span class="line">                if (key.compareTo((T) c) &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                // 否则，交换key与左右子节点中最小的节点的位置</span><br><span class="line">                array[k] = c;</span><br><span class="line">                k = child;</span><br><span class="line">            &#125;</span><br><span class="line">            // 找到了放元素的位置，放置元素</span><br><span class="line">            array[k] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>出队的过程与 PriorityQueue 基本类似：</p>
<p>（1）加锁；</p>
<p>（2）判断是否出队成功，未成功就阻塞在 notEmpty 条件上；</p>
<p>（3）出队时弹出堆顶元素，并把堆尾元素拿到堆顶；</p>
<p>（4）再做自上而下的堆化；</p>
<p>（5）解锁；</p>
<h2 id="priorityblockingqueue为什么不需要notfull条件"><a class="markdownIt-Anchor" href="#priorityblockingqueue为什么不需要notfull条件">#</a> PriorityBlockingQueue 为什么不需要 notFull 条件？</h2>
<p>因为 PriorityBlockingQueue 在入队的时候如果没有空间了是会自动扩容的，也就不存在队列满了的状态，也就是不需要等待通知队列不满了可以放元素了，所以也就不需要 notFull 条件了</p>
<h2 id="什么是双重队列"><a class="markdownIt-Anchor" href="#什么是双重队列">#</a> 什么是双重队列？</h2>
<p>放取元素使用同一个队列，队列中的节点具有两种模式，一种是数据节点，一种是非数据节点。</p>
<p>放元素时先跟队列头节点对比，如果头节点是非数据节点，就让他们匹配，如果头节点是数据节点，就生成一个数据节点放在队列尾端（入队）。</p>
<p>取元素时也是先跟队列头节点对比，如果头节点是数据节点，就让他们匹配，如果头节点是非数据节点，就生成一个非数据节点放在队列尾端（入队）。</p>
<p>用图形来表示就是下面这样：</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817204016.png" alt="202105091521058242.png"></p>
<h2 id="linkedtransferqueue是怎么实现阻塞队列的"><a class="markdownIt-Anchor" href="#linkedtransferqueue是怎么实现阻塞队列的">#</a> LinkedTransferQueue 是怎么实现阻塞队列的？</h2>
<p>LinkedTransferQueue 可以看作 LinkedBlockingQueue、SynchronousQueue（公平模式）、ConcurrentLinkedQueue 三者的集合体；</p>
<p>LinkedTransferQueue 的实现方式是使用一种叫做 <code>双重队列</code> 的数据结构；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">static final class Node &#123;</span><br><span class="line">        // 是否是数据节点（也就标识了是生产者还是消费者）</span><br><span class="line">        final boolean isData;   // false if this is a request node</span><br><span class="line">        // 元素的值</span><br><span class="line">        volatile Object item;   // initially non-null if isData; CASed to match</span><br><span class="line">        // 下一个节点</span><br><span class="line">        volatile Node next;</span><br><span class="line">        // 持有元素的线程</span><br><span class="line">        volatile Thread waiter; // null until waiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linkedtransferqueue是怎么控制并发安全的"><a class="markdownIt-Anchor" href="#linkedtransferqueue是怎么控制并发安全的">#</a> LinkedTransferQueue 是怎么控制并发安全的？</h2>
<p>LinkedTransferQueue 全程都没有使用 synchronized、重入锁等比较重的锁，基本是通过 自旋 + CAS 实现；</p>
<p>不管是取元素还是放元素都会入队；</p>
<p>先尝试跟头节点比较，如果二者模式不一样，就匹配它们，组成 CP，然后返回对方的值；</p>
<p>如果二者模式一样，就入队，并自旋或阻塞等待被唤醒；</p>
<p>至于是否入队及阻塞有四种模式，NOW、ASYNC、SYNC、TIMED；</p>
<h3 id="xfer"><a class="markdownIt-Anchor" href="#xfer">#</a> xfer()</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private E xfer(E e, boolean haveData, int how, long nanos) &#123;</span><br><span class="line">        // 不允许放入空元素</span><br><span class="line">        if (haveData &amp;&amp; (e == null))</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Node s = null;                        // the node to append, if needed</span><br><span class="line">        // 外层循环，自旋，失败就重试</span><br><span class="line">        retry:</span><br><span class="line">        for (;;) &#123;                            // restart on append race</span><br><span class="line">    </span><br><span class="line">            // 下面这个for循环用于控制匹配的过程</span><br><span class="line">            // 同一时刻队列中只会存储一种类型的节点</span><br><span class="line">            // 从头节点开始尝试匹配，如果头节点被其它线程先一步匹配了</span><br><span class="line">            // 就再尝试其下一个，直到匹配到为止，或者到队列中没有元素为止</span><br><span class="line">    </span><br><span class="line">            for (Node h = head, p = h; p != null;) &#123; // find &amp; match first node</span><br><span class="line">                // p节点的模式</span><br><span class="line">                boolean isData = p.isData;</span><br><span class="line">                // p节点的值</span><br><span class="line">                Object item = p.item;</span><br><span class="line">                // p没有被匹配到</span><br><span class="line">                if (item != p &amp;&amp; (item != null) == isData) &#123; // unmatched</span><br><span class="line">                    // 如果两者模式一样，则不能匹配，跳出循环后尝试入队</span><br><span class="line">                    if (isData == haveData)   // can&#x27;t match</span><br><span class="line">                        break;</span><br><span class="line">                    // 如果两者模式不一样，则尝试匹配</span><br><span class="line">                    // 把p的值设置为e（如果是取元素则e是null，如果是放元素则e是元素值）</span><br><span class="line">                    if (p.casItem(item, e)) &#123; // match</span><br><span class="line">                        // 匹配成功</span><br><span class="line">                        // for里面的逻辑比较复杂，用于控制多线程同时放取元素时出现竞争的情况的</span><br><span class="line">                        // 看不懂可以直接跳过</span><br><span class="line">                        for (Node q = p; q != h;) &#123;</span><br><span class="line">                            // 进入到这里可能是头节点已经被匹配，然后p会变成h的下一个节点</span><br><span class="line">                            Node n = q.next;  // update by 2 unless singleton</span><br><span class="line">                            // 如果head还没变，就把它更新成新的节点</span><br><span class="line">                            // 并把它删除（forgetNext()会把它的next设为自己，也就是从单链表中删除了）</span><br><span class="line">                            // 这时为什么要把head设为n呢？因为到这里了，肯定head本身已经被匹配掉了</span><br><span class="line">                            // 而上面的p.casItem()又成功了，说明p也被当前这个元素给匹配掉了</span><br><span class="line">                            // 所以需要把它们俩都出队列，让其它线程可以从真正的头开始，不用重复检查了</span><br><span class="line">                            if (head == h &amp;&amp; casHead(h, n == null ? q : n)) &#123;</span><br><span class="line">                                h.forgetNext();</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;                 // advance and retry</span><br><span class="line">                            // 如果新的头节点为空，或者其next为空，或者其next未匹配，就重试</span><br><span class="line">                            if ((h = head)   == null ||</span><br><span class="line">                                (q = h.next) == null || !q.isMatched())</span><br><span class="line">                                break;        // unless slack &lt; 2</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 唤醒p中等待的线程</span><br><span class="line">                        LockSupport.unpark(p.waiter);</span><br><span class="line">                        // 并返回匹配到的元素</span><br><span class="line">                        return LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // p已经被匹配了或者尝试匹配的时候失败了</span><br><span class="line">                // 也就是其它线程先一步匹配了p</span><br><span class="line">                // 这时候又分两种情况，p的next还没来得及修改，p的next指向了自己</span><br><span class="line">                // 如果p的next已经指向了自己，就重新取head重试，否则就取其next重试</span><br><span class="line">                Node n = p.next;</span><br><span class="line">                p = (p != n) ? n : (h = head); // Use head if p offlist</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 到这里肯定是队列中存储的节点类型和自己一样</span><br><span class="line">            // 或者队列中没有元素了</span><br><span class="line">            // 就入队（不管放元素还是取元素都得入队）</span><br><span class="line">            // 入队又分成四种情况：</span><br><span class="line">            // NOW，立即返回，没有匹配到立即返回，不做入队操作</span><br><span class="line">            // ASYNC，异步，元素入队但当前线程不会阻塞（相当于无界LinkedBlockingQueue的元素入队）</span><br><span class="line">            // SYNC，同步，元素入队后当前线程阻塞，等待被匹配到</span><br><span class="line">            // TIMED，有超时，元素入队后等待一段时间被匹配，时间到了还没匹配到就返回元素本身</span><br><span class="line">    </span><br><span class="line">            // 如果不是立即返回</span><br><span class="line">            if (how != NOW) &#123;                 // No matches available</span><br><span class="line">                // 新建s节点</span><br><span class="line">                if (s == null)</span><br><span class="line">                    s = new Node(e, haveData);</span><br><span class="line">                // 尝试入队</span><br><span class="line">                Node pred = tryAppend(s, haveData);</span><br><span class="line">                // 入队失败，重试</span><br><span class="line">                if (pred == null)</span><br><span class="line">                    continue retry;           // lost race vs opposite mode</span><br><span class="line">                // 如果不是异步（同步或者有超时）</span><br><span class="line">                // 就等待被匹配</span><br><span class="line">                if (how != ASYNC)</span><br><span class="line">                    return awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            return e; // not waiting</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Node tryAppend(Node s, boolean haveData) &#123;</span><br><span class="line">        // 从tail开始遍历，把s放到链表尾端</span><br><span class="line">        for (Node t = tail, p = t;;) &#123;        // move p to last node and append</span><br><span class="line">            Node n, u;                        // temps for reads of next &amp; tail</span><br><span class="line">            // 如果首尾都是null，说明链表中还没有元素</span><br><span class="line">            if (p == null &amp;&amp; (p = head) == null) &#123;</span><br><span class="line">                // 就让首节点指向s</span><br><span class="line">                // 注意，这里插入第一个元素的时候tail指针并没有指向s</span><br><span class="line">                if (casHead(null, s))</span><br><span class="line">                    return s;                 // initialize</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p.cannotPrecede(haveData))</span><br><span class="line">                // 如果p无法处理，则返回null</span><br><span class="line">                // 这里无法处理的意思是，p和s节点的类型不一样，不允许s入队</span><br><span class="line">                // 比如，其它线程先入队了一个数据节点，这时候要入队一个非数据节点，就不允许，</span><br><span class="line">                // 队列中所有的元素都要保证是同一种类型的节点</span><br><span class="line">                // 返回null后外面的方法会重新尝试匹配重新入队等</span><br><span class="line">                return null;                  // lost race vs opposite mode</span><br><span class="line">            else if ((n = p.next) != null)    // not last; keep traversing</span><br><span class="line">                // 如果p的next不为空，说明不是最后一个节点</span><br><span class="line">                // 则让p重新指向最后一个节点</span><br><span class="line">                p = p != t &amp;&amp; t != (u = tail) ? (t = u) : // stale tail</span><br><span class="line">                    (p != n) ? n : null;      // restart if off list</span><br><span class="line">            else if (!p.casNext(null, s))</span><br><span class="line">                // 如果CAS更新s为p的next失败</span><br><span class="line">                // 则说明有其它线程先一步更新到p的next了</span><br><span class="line">                // 就让p指向p的next，重新尝试让s入队</span><br><span class="line">                p = p.next;                   // re-read on CAS failure</span><br><span class="line">            else &#123;</span><br><span class="line">                // 到这里说明s成功入队了</span><br><span class="line">                // 如果p不等于t，就更新tail指针</span><br><span class="line">                // 还记得上面插入第一个元素时tail指针并没有指向新元素吗？</span><br><span class="line">                // 这里就是用来更新tail指针的</span><br><span class="line">                if (p != t) &#123;                 // update if slack now &gt;= 2</span><br><span class="line">                    while ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                           (t = tail)   != null &amp;&amp;</span><br><span class="line">                           (s = t.next) != null &amp;&amp; // advance and retry</span><br><span class="line">                           (s = s.next) != null &amp;&amp; s != t);</span><br><span class="line">                &#125;</span><br><span class="line">                // 返回p，即s的前一个元素</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) &#123;</span><br><span class="line">        // 如果是有超时的，计算其超时时间</span><br><span class="line">        final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">        // 当前线程</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        // 自旋次数</span><br><span class="line">        int spins = -1; // initialized after first item and cancel checks</span><br><span class="line">        // 随机数，随机让一些自旋的线程让出CPU</span><br><span class="line">        ThreadLocalRandom randomYields = null; // bound if needed</span><br><span class="line">    </span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Object item = s.item;</span><br><span class="line">            // 如果s元素的值不等于e，说明它被匹配到了</span><br><span class="line">            if (item != e) &#123;                  // matched</span><br><span class="line">                // assert item != s;</span><br><span class="line">                // 把s的item更新为s本身</span><br><span class="line">                // 并把s中的waiter置为空</span><br><span class="line">                s.forgetContents();           // avoid garbage</span><br><span class="line">                // 返回匹配到的元素</span><br><span class="line">                return LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果当前线程中断了，或者有超时的到期了</span><br><span class="line">            // 就更新s的元素值指向s本身</span><br><span class="line">            if ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= 0)) &amp;&amp;</span><br><span class="line">                    s.casItem(e, s)) &#123;        // cancel</span><br><span class="line">                // 尝试解除s与其前一个节点的关系</span><br><span class="line">                // 也就是删除s节点</span><br><span class="line">                unsplice(pred, s);</span><br><span class="line">                // 返回元素的值本身，说明没匹配到</span><br><span class="line">                return e;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 如果自旋次数小于0，就计算自旋次数</span><br><span class="line">            if (spins &lt; 0) &#123;                  // establish spins at/near front</span><br><span class="line">                // spinsFor()计算自旋次数</span><br><span class="line">                // 如果前面有节点未被匹配就返回0</span><br><span class="line">                // 如果前面有节点且正在匹配中就返回一定的次数，等待</span><br><span class="line">                if ((spins = spinsFor(pred, s.isData)) &gt; 0)</span><br><span class="line">                    // 初始化随机数</span><br><span class="line">                    randomYields = ThreadLocalRandom.current();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (spins &gt; 0) &#123;             // spin</span><br><span class="line">                // 还有自旋次数就减1</span><br><span class="line">                --spins;</span><br><span class="line">                // 并随机让出CPU</span><br><span class="line">                if (randomYields.nextInt(CHAINED_SPINS) == 0)</span><br><span class="line">                    Thread.yield();           // occasionally yield</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s.waiter == null) &#123;</span><br><span class="line">                // 更新s的waiter为当前线程</span><br><span class="line">                s.waiter = w;                 // request unpark then recheck</span><br><span class="line">            &#125;</span><br><span class="line">            else if (timed) &#123;</span><br><span class="line">                // 如果有超时，计算超时时间，并阻塞一定时间</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                if (nanos &gt; 0L)</span><br><span class="line">                    LockSupport.parkNanos(this, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 不是超时的，直接阻塞，等待被唤醒</span><br><span class="line">                // 唤醒后进入下一次循环，走第一个if的逻辑就返回匹配的元素了</span><br><span class="line">                LockSupport.park(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这三个方法里的内容特别复杂，很大一部分代码都是在控制线程安全，各种 CAS，我们这里简单描述一下大致的逻辑：</p>
<p>（1）来了一个元素，我们先查看队列头的节点，是否与这个元素的模式一样；</p>
<p>（2）如果模式不一样，就尝试让他们匹配，如果头节点被别的线程先匹配走了，就尝试与头节点的下一个节点匹配，如此一直往后，直到匹配到或到链表尾为止；</p>
<p>（3）如果模式一样，或者到链表尾了，就尝试入队；</p>
<p>（4）入队的时候有可能链表尾修改了，那就尾指针后移，再重新尝试入队，依此往复；</p>
<p>（5）入队成功了，就自旋或阻塞，阻塞了就等待被其它线程匹配到并唤醒；</p>
<p>（6）唤醒之后进入下一次循环就匹配到元素了，返回匹配到的元素；</p>
<p>（7）是否需要入队及阻塞有四种情况：</p>
<p>a）NOW，立即返回，没有匹配到立即返回，不做入队操作<br>
对应的方法有：poll ()、tryTransfer (e)<br>
 b）ASYNC，异步，元素入队但当前线程不会阻塞（相当于无界 LinkedBlockingQueue 的元素入队）<br>
对应的方法有：add (e)、offer (e)、put (e)、offer (e, timeout, unit)<br>
 c）SYNC，同步，元素入队后当前线程阻塞，等待被匹配到<br>
对应的方法有：take ()、transfer (e)<br>
 d）TIMED，有超时，元素入队后等待一段时间被匹配，时间到了还没匹配到就返回元素本身<br>
对应的方法有：poll (timeout, unit)、tryTransfer (e, timeout, unit)</p>
<h2 id="linkedtransferqueue与synchronousqueue有什么异同"><a class="markdownIt-Anchor" href="#linkedtransferqueue与synchronousqueue有什么异同">#</a> LinkedTransferQueue 与 SynchronousQueue 有什么异同？</h2>
<p>（1）在 java8 中两者的实现方式基本一致，都是使用的双重队列；</p>
<p>（2）前者完全实现了后者，但比后者更灵活；</p>
<p>（3）后者不管放元素还是取元素，如果没有可匹配的元素，所在的线程都会阻塞；</p>
<p>（4）前者可以自己控制放元素是否需要阻塞线程，比如使用四个添加元素的方法就不会阻塞线程，只入队元素，使用 transfer () 会阻塞线程；</p>
<p>（5）取元素两者基本一样，都会阻塞等待有新的元素进入被匹配到；</p>
<h2 id="concurrentlinkedqueue是阻塞队列吗"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue是阻塞队列吗">#</a> ConcurrentLinkedQueue 是阻塞队列吗？</h2>
<p>ConcurrentLinkedQueue 不是阻塞队列；ConcurrentLinkedQueue 只实现了 Queue 接口，并没有实现 BlockingQueue 接口，所以它不是阻塞队列，也不能用于线程池中，但是它是线程安全的，可用于多线程环境中。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817205205.png" alt="image-20210817205204809"></p>
<h2 id="concurrentlinkedqueue如何保证并发安全"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue如何保证并发安全">#</a> ConcurrentLinkedQueue 如何保证并发安全？</h2>
<p>能</p>
<p>因为它不是阻塞队列，所以只有两个入队的方法，add (e) 和 offer (e)。</p>
<p>因为是无界队列，所以 add (e) 方法也不用抛出异常了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        // 不能添加空元素</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        // 新节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">        // 入队到链表尾</span><br><span class="line">        for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            // 如果没有next，说明到链表尾部了，就入队</span><br><span class="line">            if (q == null) &#123;</span><br><span class="line">                // CAS更新p的next为新节点</span><br><span class="line">                // 如果成功了，就返回true</span><br><span class="line">                // 如果不成功就重新取next重新尝试</span><br><span class="line">                if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                    // 如果p不等于t，说明有其它线程先一步更新tail</span><br><span class="line">                    // 也就不会走到q==null这个分支了</span><br><span class="line">                    // p取到的可能是t后面的值</span><br><span class="line">                    // 把tail原子更新为新节点</span><br><span class="line">                    if (p != t) // hop two nodes at a time</span><br><span class="line">                        casTail(t, newNode);  // Failure is OK.</span><br><span class="line">                    // 返回入队成功</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p == q)</span><br><span class="line">                // 如果p的next等于p，说明p已经被删除了（已经出队了）</span><br><span class="line">                // 重新设置p的值</span><br><span class="line">                p = (t != (t = tail)) ? t : head;</span><br><span class="line">            else</span><br><span class="line">                // t后面还有值，重新设置p的值</span><br><span class="line">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>入队整个流程还是比较清晰的，这里有个前提是出队时会把出队的那个节点的 next 设置为节点本身。</p>
<p>（1）定位到链表尾部，尝试把新节点到后面；</p>
<p>（2）如果尾部变化了，则重新获取尾部，再重试；</p>
<p>因为它不是阻塞队列，所以只有两个出队的方法，remove () 和 poll ()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        E x = poll();</span><br><span class="line">        if (x != null)</span><br><span class="line">            return x;</span><br><span class="line">        else</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E poll() &#123;</span><br><span class="line">        restartFromHead:</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 尝试弹出链表的头节点</span><br><span class="line">            for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">                E item = p.item;</span><br><span class="line">                // 如果节点的值不为空，并且将其更新为null成功了</span><br><span class="line">                if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                    // 如果头节点变了，则不会走到这个分支</span><br><span class="line">                    // 会先走下面的分支拿到新的头节点</span><br><span class="line">                    // 这时候p就不等于h了，就更新头节点</span><br><span class="line">                    // 在updateHead()中会把head更新为新节点</span><br><span class="line">                    // 并让head的next指向其自己</span><br><span class="line">                    if (p != h) // hop two nodes at a time</span><br><span class="line">                        updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                    // 上面的casItem()成功，就可以返回出队的元素了</span><br><span class="line">                    return item;</span><br><span class="line">                &#125;</span><br><span class="line">                // 下面三个分支说明头节点变了</span><br><span class="line">                // 且p的item肯定为null</span><br><span class="line">                else if ((q = p.next) == null) &#123;</span><br><span class="line">                    // 如果p的next为空，说明队列中没有元素了</span><br><span class="line">                    // 更新h为p，也就是空元素的节点</span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    // 返回null</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (p == q)</span><br><span class="line">                    // 如果p等于p的next，说明p已经出队了，重试</span><br><span class="line">                    continue restartFromHead;</span><br><span class="line">                else</span><br><span class="line">                    // 将p设置为p的next</span><br><span class="line">                    p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新头节点的方法</span><br><span class="line">    final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">        // 原子更新h为p成功后，延迟更新h的next为它自己</span><br><span class="line">        // 这里用延迟更新是安全的，因为head节点已经变了</span><br><span class="line">        // 只要入队出队的时候检查head有没有变化就行了，跟它的next关系不大</span><br><span class="line">        if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">            h.lazySetNext(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>出队的整个逻辑也是比较清晰的：</p>
<p>（1）定位到头节点，尝试更新其值为 null；</p>
<p>（2）如果成功了，就成功出队；</p>
<p>（3）如果失败或者头节点变化了，就重新寻找头节点，并重试；</p>
<p>（4）整个出队过程没有一点阻塞相关的代码，所以出队的时候不会阻塞线程，没找到元素就返回 null；</p>
<h2 id="concurrentlinkedqueue能用于线程池吗"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue能用于线程池吗">#</a> ConcurrentLinkedQueue 能用于线程池吗？</h2>
<p>ConcurrentLinkedQueue 不能用在线程池中；因为不是阻塞队列。</p>
<h2 id="concurrentlinkedqueue与linkedblockingqueue对比"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue与linkedblockingqueue对比">#</a> ConcurrentLinkedQueue 与 LinkedBlockingQueue 对比？</h2>
<p>（1）两者都是线程安全的队列；</p>
<p>（2）两者都可以实现取元素时队列为空直接返回 null，后者的 poll () 方法可以实现此功能；</p>
<p>（3）前者全程无锁，后者全部都是使用重入锁控制的；</p>
<p>（4）前者效率较高，后者效率较低；</p>
<p>（5）前者无法实现如果队列为空等待元素到来的操作；</p>
<p>（6）前者是非阻塞队列，后者是阻塞队列；</p>
<p>（7）前者无法用在线程池中，后者可以；</p>
<h2 id="delayqueue是阻塞-队列吗"><a class="markdownIt-Anchor" href="#delayqueue是阻塞-队列吗">#</a> DelayQueue 是阻塞 - 队列吗？</h2>
<p>从继承体系可以看到，DelayQueue 实现了 BlockingQueue，所以它是一个阻塞队列。</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817205623.png" alt="image-20210817205623249"></p>
<h2 id="delayqueue的实现方式"><a class="markdownIt-Anchor" href="#delayqueue的实现方式">#</a> DelayQueue 的实现方式？</h2>
<p>DelayQueue 内部存储结构使用优先级队列；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 用于控制并发的锁</span><br><span class="line">    private final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    // 优先级队列</span><br><span class="line">    private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span><br><span class="line">    // 用于标记当前是否有线程在排队（仅用于取元素时）</span><br><span class="line">    private Thread leader = null;</span><br><span class="line">    // 条件，用于表示现在是否有可取的元素</span><br><span class="line">    private final Condition available = lock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="delayqueue如何保证并发安全"><a class="markdownIt-Anchor" href="#delayqueue如何保证并发安全">#</a> DelayQueue 如何保证并发安全？</h2>
<p>DelayQueue 使用重入锁和条件来控制并发安全；</p>
<p>因为 DelayQueue 是阻塞队列，且优先级队列是无界的，所以入队不会阻塞不会超时，因此它的四个入队方法是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(E e) &#123;</span><br><span class="line">        offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            q.offer(e);</span><br><span class="line">            if (q.peek() == e) &#123;</span><br><span class="line">                leader = null;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>入队方法比较简单：</p>
<p>（1）加锁；</p>
<p>（2）添加元素到优先级队列中；</p>
<p>（3）如果添加的元素是堆顶元素，就把 leader 置为空，并唤醒等待在条件 available 上的线程；</p>
<p>（4）解锁；</p>
<p>因为 DelayQueue 是阻塞队列，所以它的出队有四个不同的方法，有抛出异常的，有阻塞的，有不阻塞的，有超时的。</p>
<p>我们这里主要分析两个，poll () 和 take () 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public E poll() &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            if (first == null || first.getDelay(NANOSECONDS) &gt; 0)</span><br><span class="line">                return null;</span><br><span class="line">            else</span><br><span class="line">                return q.poll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>poll () 方法比较简单：</p>
<p>（1）加锁；</p>
<p>（2）检查第一个元素，如果为空或者还没到期，就返回 null；</p>
<p>（3）如果第一个元素到期了就调用 poll () 弹出第一个元素；</p>
<p>（4）解锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                // 堆顶元素</span><br><span class="line">                E first = q.peek();</span><br><span class="line">                // 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待</span><br><span class="line">                if (first == null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 堆顶元素的到期时间</span><br><span class="line">                    long delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    // 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素</span><br><span class="line">                    if (delay &lt;= 0)</span><br><span class="line">                        return q.poll();</span><br><span class="line">    </span><br><span class="line">                    // 如果delay大于0 ，则下面要阻塞了</span><br><span class="line">    </span><br><span class="line">                    // 将first置为空方便gc，因为有可能其它元素弹出了这个元素</span><br><span class="line">                    // 这里还持有着引用不会被清理</span><br><span class="line">                    first = null; // don&#x27;t retain ref while waiting</span><br><span class="line">                    // 如果前面有其它线程在等待，直接进入等待</span><br><span class="line">                    if (leader != null)</span><br><span class="line">                        available.await();</span><br><span class="line">                    else &#123;</span><br><span class="line">                        // 如果leader为null，把当前线程赋值给它</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            // 等待delay时间后自动醒过来</span><br><span class="line">                            // 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期</span><br><span class="line">                            // 这里即使醒过来后也不一定能获取到元素</span><br><span class="line">                            // 因为有可能其它线程先一步获取了锁并弹出了堆顶元素</span><br><span class="line">                            // 条件锁的唤醒分成两步，先从Condition的队列里出队</span><br><span class="line">                            // 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒</span><br><span class="line">                            // 关于AQS我们后面会讲的^^</span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            // 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素</span><br><span class="line">                            if (leader == thisThread)</span><br><span class="line">                                leader = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程</span><br><span class="line">            if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">                // signal()只是把等待的线程放到AQS的队列里面，并不是真正的唤醒</span><br><span class="line">                available.signal();</span><br><span class="line">            // 解锁，这才是真正的唤醒</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>take () 方法稍微要复杂一些：</p>
<p>（1）加锁；</p>
<p>（2）判断堆顶元素是否为空，为空的话直接阻塞等待；</p>
<p>（3）判断堆顶元素是否到期，到期了直接 poll () 出元素；</p>
<p>（4）没到期，再判断前面是否有其它线程在等待，有则直接等待；</p>
<p>（5）前面没有其它线程在等待，则把自己当作第一个线程等待 delay 时间后唤醒，再尝试获取元素；</p>
<p>（6）获取到元素之后再唤醒下一个等待的线程；</p>
<p>（7）解锁；</p>
<h2 id="delayqueue主要用于什么场景"><a class="markdownIt-Anchor" href="#delayqueue主要用于什么场景">#</a> DelayQueue 主要用于什么场景？</h2>
<p>DelayQueue 常用于定时任务</p>
<h2 id="java中的线程池实现定时任务是直接用的delayqueue吗"><a class="markdownIt-Anchor" href="#java中的线程池实现定时任务是直接用的delayqueue吗">#</a> java 中的线程池实现定时任务是直接用的 DelayQueue 吗？</h2>
<p>当然不是，ScheduledThreadPoolExecutor 中使用的是它自己定义的内部类 DelayedWorkQueue，其实里面的实现逻辑基本都是一样的，只不过 DelayedWorkQueue 里面没有使用现在的 PriorityQueue，而是使用数组又实现了一遍优先级队列，本质上没有什么区别。</p>
<h2 id="什么是双端队列"><a class="markdownIt-Anchor" href="#什么是双端队列">#</a> 什么是双端队列？</h2>
<p>双端队列是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列。</p>
<h2 id="arraydeque是怎么实现双端队列的"><a class="markdownIt-Anchor" href="#arraydeque是怎么实现双端队列的">#</a> ArrayDeque 是怎么实现双端队列的？</h2>
<p>ArrayDeque 是一种以数组方式实现的双端队列，它是非线程安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 存储元素的数组</span><br><span class="line">    transient Object[] elements; // non-private to simplify nested class access</span><br><span class="line">    // 队列头位置</span><br><span class="line">    transient int head;</span><br><span class="line">    // 队列尾位置</span><br><span class="line">    transient int tail;</span><br><span class="line">    // 最小初始容量</span><br><span class="line">    private static final int MIN_INITIAL_CAPACITY = 8;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="linkedlist与arraydeque的对比"><a class="markdownIt-Anchor" href="#linkedlist与arraydeque的对比">#</a> LinkedList 与 ArrayDeque 的对比？</h2>
<p>ArrayList、ArrayDeque 内部以数组的形式保存集合中的元素，因此随机访问元素时有较好的性能；而 LinkedList 内部以链表的形式来保存集合中的元素，因此随机访问集合中的元素时虽然性能较差，但在插入、删除元素时性能非常出色（只需要改变指针所指的地址即可）。需要指出的是，虽然 Vector 也是以数组的形式来存储</p>
<h2 id="双端队列是否可以作为栈使用"><a class="markdownIt-Anchor" href="#双端队列是否可以作为栈使用">#</a> 双端队列是否可以作为栈使用？</h2>
<p>可以</p>
<p>ArrayDeque 可以直接作为栈使用；</p>
<h2 id="linkedlist是list和deque的集合体"><a class="markdownIt-Anchor" href="#linkedlist是list和deque的集合体">#</a> LinkedList 是 List 和 Deque 的集合体？</h2>
<p>是</p>
<p>LinkedList 在功能上等于 ArrayList + ArrayDeque；</p>
<p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817210645.png" alt="image-20210817210645275"></p>
<h2 id="集合指定初始容量的好处"><a class="markdownIt-Anchor" href="#集合指定初始容量的好处">#</a> 集合指定初始容量的好处？</h2>
<p>集合是我们在 Java 编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection 的初始容量也显得异常重要。所以：<strong>对于已知的情景，请为集合指定初始容量。</strong></p>
<p>如 ArrayList 每次新增一个元素，就会检测 ArrayList 的当前容量是否已经到达临界点，如果到达临界点则会扩容 1.5 倍。然而 ArrayList 的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post_share"><div class="social-share" data-image="/img/6.png" data-sites="twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/09/05/mysql%E9%A2%98%E7%9B%AE/"><img class="prev-cover" src="/img/me.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">mysql问题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/me1.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Kris</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/brave-rabbit"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#arraylist%E5%92%8Clinkedlist%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text"> ArrayList 和 LinkedList 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arraylist%E7%9A%84sublist%E4%BF%AE%E6%94%B9%E6%98%AF%E5%90%A6%E5%BD%B1%E5%93%8Dlist%E6%9C%AC%E8%BA%AB"><span class="toc-number">2.</span> <span class="toc-text"> ArrayList 的 sublist 修改是否影响 list 本身？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronizedlist-vector%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text"> SynchronizedList、Vector 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arraysaslisttargs%E8%8E%B7%E5%BE%97%E7%9A%84list%E7%89%B9%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text"> Arrays.asList (T…args) 获得的 List 特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterator%E5%92%8Clistiterator%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text"> Iterator 和 ListIterator 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arraylist%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">6.</span> <span class="toc-text"> ArrayList 是怎么扩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arraylist%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">7.</span> <span class="toc-text"> ArrayList 插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%B1%82%E4%B8%A4%E4%B8%AA%E9%9B%86%E5%90%88%E7%9A%84%E5%B9%B6%E9%9B%86-%E4%BA%A4%E9%9B%86-%E5%B7%AE%E9%9B%86"><span class="toc-number">8.</span> <span class="toc-text"> 怎么求两个集合的并集、交集、差集？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arraylist%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84"><span class="toc-number">9.</span> <span class="toc-text"> ArrayList 是怎么实现序列化和反序列化的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95toarray%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text"> 集合的方法 toArray () 有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFfail-fast"><span class="toc-number">11.</span> <span class="toc-text"> 什么是 fail-fast？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.</span> <span class="toc-text"> 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">11.2.</span> <span class="toc-text"> 例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-fast%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text"> fail-fast 解决办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedlist%E6%98%AF%E5%8D%95%E9%93%BE%E8%A1%A8%E8%BF%98%E6%98%AF%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">12.</span> <span class="toc-text"> LinkedList 是单链表还是双链表实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedlist%E9%99%A4%E4%BA%86%E4%BD%9C%E4%B8%BAlist%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%A4%84"><span class="toc-number">13.</span> <span class="toc-text"> LinkedList 除了作为 List 还有什么用处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedlist%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">14.</span> <span class="toc-text"> LinkedList 插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE"><span class="toc-number">15.</span> <span class="toc-text"> 什么是随机访问？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#randomaccess%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.0.1.</span> <span class="toc-text"> RandomAccess 接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E6%94%AF%E6%8C%81%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%96%E4%BB%AC%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B1%E6%80%A7"><span class="toc-number">16.</span> <span class="toc-text"> 哪些集合支持随机访问？他们都有哪些共性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">17.</span> <span class="toc-text"> CopyOnWriteArrayList 是怎么保证并发安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%87%87%E7%94%A8%E4%BA%86%E4%BB%80%E4%B9%88%E6%80%9D%E6%83%B3"><span class="toc-number">18.</span> <span class="toc-text"> CopyOnWriteArrayList 的实现采用了什么思想？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84"><span class="toc-number">19.</span> <span class="toc-text"> CopyOnWriteArrayList 是不是强一致性的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylistaddifabsente-e%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">20.</span> <span class="toc-text"> CopyOnWriteArrayListaddIfAbsent (E e) 了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E9%80%82%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">21.</span> <span class="toc-text"> CopyOnWriteArrayList 适用于什么样的场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">22.</span> <span class="toc-text"> CopyOnWriteArrayList 插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89size%E5%B1%9E%E6%80%A7"><span class="toc-number">23.</span> <span class="toc-text"> CopyOnWriteArrayList 为什么没有 size 属性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%8F%A4%E8%80%81%E7%9A%84%E9%9B%86%E5%90%88vector%E5%92%8Cstack%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E9%99%B7"><span class="toc-number">24.</span> <span class="toc-text"> 比较古老的集合 Vector 和 Stack 有什么缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">25.</span> <span class="toc-text"> 什么是散列表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">26.</span> <span class="toc-text"> 常见的散列函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">27.</span> <span class="toc-text"> 碰撞解决方案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">28.</span> <span class="toc-text"> 怎么实现一个散列表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%ADhashmap%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">29.</span> <span class="toc-text"> java 中 HashMap 实现方式的演进？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E7%9A%84%E5%AE%B9%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">30.</span> <span class="toc-text"> HashMap 的容量有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%93%88%E5%B8%8C%E6%A1%B6%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E4%BD%8D%E7%BD%AE"><span class="toc-number">31.</span> <span class="toc-text"> HashMap 如何确定哈希桶数组索引位置？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">32.</span> <span class="toc-text"> HashMap 是怎么进行扩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E7%9A%84put%E6%96%B9%E6%B3%95"><span class="toc-number">33.</span> <span class="toc-text"> HashMap 的 put 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84"><span class="toc-number">34.</span> <span class="toc-text"> HashMap 中的元素是否是有序的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A0%91%E5%8C%96%E4%BD%95%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%8F%8D%E6%A0%91%E5%8C%96"><span class="toc-number">35.</span> <span class="toc-text"> HashMap 何时进行树化？何时进行反树化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E4%B8%8E%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83"><span class="toc-number">36.</span> <span class="toc-text"> 泊松分布与指数分布</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83"><span class="toc-number">36.1.</span> <span class="toc-text"> 泊松分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83"><span class="toc-number">36.2.</span> <span class="toc-text"> 指数分布</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E7%BC%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">37.</span> <span class="toc-text"> HashMap 是怎么进行缩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">38.</span> <span class="toc-text"> HashMap 插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E6%9B%BF%E5%90%97"><span class="toc-number">39.</span> <span class="toc-text"> HashMap 中的红黑树实现部分可以用其它数据结构代替吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedhashmap%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">40.</span> <span class="toc-text"> LinkedHashMap 是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedhashmap%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95"><span class="toc-number">41.</span> <span class="toc-text"> LinkedHashMap 是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedhashmap%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0lru%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">42.</span> <span class="toc-text"> LinkedHashMap 如何实现 LRU 缓存淘汰策略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weakhashmap%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">43.</span> <span class="toc-text"> WeakHashMap 使用的数据结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weakhashmap%E5%85%B7%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7"><span class="toc-number">44.</span> <span class="toc-text"> WeakHashMap 具有什么特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weakhashmap%E9%80%9A%E5%B8%B8%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">45.</span> <span class="toc-text"> WeakHashMap 通常用来做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weakhashmap%E4%BD%BF%E7%94%A8string%E4%BD%9C%E4%B8%BAkey%E6%98%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%9B%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">46.</span> <span class="toc-text"> WeakHashMap 使用 String 作为 key 是需要注意些什么？为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%BC%95%E7%94%A8-%E8%BD%AF%E5%BC%95%E7%94%A8-%E5%BC%B1%E5%BC%95%E7%94%A8-%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">47.</span> <span class="toc-text"> 什么是强引用、软引用、弱引用、虚引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7"><span class="toc-number">48.</span> <span class="toc-text"> 红黑树具有哪些特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treemap%E5%B0%B1%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95"><span class="toc-number">49.</span> <span class="toc-text"> TreeMap 就有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treemap%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9"><span class="toc-number">50.</span> <span class="toc-text"> TreeMap 是否需要扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A6%E6%97%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%B3%E6%97%8B"><span class="toc-number">51.</span> <span class="toc-text"> 什么是左旋？什么是右旋？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%8E%E4%B9%88%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-number">52.</span> <span class="toc-text"> 红黑树怎么插入元素？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="toc-number">52.1.</span> <span class="toc-text"> 插入再平衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">53.</span> <span class="toc-text"> 红黑树怎么删除元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%B9%B3%E8%A1%A1"><span class="toc-number">54.</span> <span class="toc-text"> 为什么要进行平衡？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">55.</span> <span class="toc-text"> 如何实现红黑树的遍历？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treemap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%81%E8%AE%B8key%E4%B8%BAnull"><span class="toc-number">56.</span> <span class="toc-text"> TreeMap 为什么不允许 key 为 null?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treemap%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E9%81%8D%E5%8E%86%E7%9A%84"><span class="toc-number">57.</span> <span class="toc-text"> TreeMap 中是怎么遍历的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treemap%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">58.</span> <span class="toc-text"> TreeMap 插入、删除、查询元素的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="toc-number">59.</span> <span class="toc-text"> HashMap 在多线程环境中什么时候会出现问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">60.</span> <span class="toc-text"> ConcurrentHashMap 的存储结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">61.</span> <span class="toc-text"> ConcurrentHashMap 是怎么保证并发安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E7%9A%84"><span class="toc-number">62.</span> <span class="toc-text"> ConcurrentHashMap 是怎么扩容的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E7%9A%84size%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%9F%A5%E9%81%93%E5%A4%9A%E5%B0%91"><span class="toc-number">63.</span> <span class="toc-text"> ConcurrentHashMap 的 size () 方法的实现知道多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E6%98%AF%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%90%97"><span class="toc-number">64.</span> <span class="toc-text"> ConcurrentHashMap 是强一致性的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">65.</span> <span class="toc-text"> ConcurrentHashMap 不能解决什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E7%9A%84sizectl%E7%9F%A5%E9%81%93%E5%90%97"><span class="toc-number">66.</span> <span class="toc-text"> ConcurrentHashMap 的 sizeCtl 知道吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E8%BF%90%E7%94%A8%E5%88%B0%E5%88%86%E6%AE%B5%E9%94%81%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">67.</span> <span class="toc-text"> ConcurrentHashMap 中哪些地方运用到分段锁的思想？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%BA%E4%BD%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BC%AA%E5%85%B1%E4%BA%AB%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">68.</span> <span class="toc-text"> 什么是伪共享？为何会出现伪共享？怎么避免伪共享？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">68.1.</span> <span class="toc-text"> 什么是伪共享？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">68.2.</span> <span class="toc-text"> 为何会出现伪共享</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%BC%AA%E5%85%B1%E4%BA%AB"><span class="toc-number">68.2.1.</span> <span class="toc-text"> 如何解决伪共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%A1%A8"><span class="toc-number">69.</span> <span class="toc-text"> 什么是跳表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentskiplist%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97"><span class="toc-number">70.</span> <span class="toc-text"> ConcurrentSkipList 是有序的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentskiplist%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">71.</span> <span class="toc-text"> ConcurrentSkipList 是如何保证线程安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentskiplist%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4-%E6%9F%A5%E8%AF%A2%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">72.</span> <span class="toc-text"> ConcurrentSkipList 插入、删除、查询元素的时间复杂度各是多少？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0"><span class="toc-number">72.1.</span> <span class="toc-text"> 添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">72.2.</span> <span class="toc-text"> 删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">72.3.</span> <span class="toc-text"> 查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentskiplist%E7%9A%84%E7%B4%A2%E5%BC%95%E5%85%B7%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7"><span class="toc-number">73.</span> <span class="toc-text"> ConcurrentSkipList 的索引具有什么特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88redis%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E8%80%8C%E4%B8%8D%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">74.</span> <span class="toc-text"> 为什么 Redis 选择使用跳表而不是红黑树来实现有序集合？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashset%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D"><span class="toc-number">75.</span> <span class="toc-text"> HashSet 怎么保证添加元素不重复？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashset%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97"><span class="toc-number">76.</span> <span class="toc-text"> HashSet 是有序的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashset%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8null%E5%85%83%E7%B4%A0"><span class="toc-number">77.</span> <span class="toc-text"> HashSet 是否允许 null 元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set%E6%98%AF%E5%90%A6%E6%9C%89get%E6%96%B9%E6%B3%95"><span class="toc-number">78.</span> <span class="toc-text"> Set 是否有 get () 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashset%E6%BA%90%E7%A0%81"><span class="toc-number">79.</span> <span class="toc-text"> HashSet 源码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedhashset%E7%9A%84%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0"><span class="toc-number">80.</span> <span class="toc-text"> LinkedHashSet 的底层使用什么存储元素？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedhashset%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95"><span class="toc-number">81.</span> <span class="toc-text"> LinkedHashSet 是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedhashset%E6%94%AF%E6%8C%81%E6%8C%89%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F%E5%90%97"><span class="toc-number">82.</span> <span class="toc-text"> LinkedHashSet 支持按元素访问顺序排序吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeset%E7%9C%9F%E7%9A%84%E6%98%AF%E4%BD%BF%E7%94%A8treemap%E6%9D%A5%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%97"><span class="toc-number">83.</span> <span class="toc-text"> TreeSet 真的是使用 TreeMap 来存储元素的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeset%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95"><span class="toc-number">84.</span> <span class="toc-text"> TreeSet 是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeset%E5%92%8Clinkedhashset%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">85.</span> <span class="toc-text"> TreeSet 和 LinkedHashSet 有何不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeset%E5%92%8Csortedset%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">86.</span> <span class="toc-text"> TreeSet 和 SortedSet 有什么区别和联系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearrayset%E6%98%AF%E7%94%A8map%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97"><span class="toc-number">87.</span> <span class="toc-text"> CopyOnWriteArraySet 是用 Map 实现的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearrayset%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95"><span class="toc-number">88.</span> <span class="toc-text"> CopyOnWriteArraySet 是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearrayset%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">89.</span> <span class="toc-text"> CopyOnWriteArraySet 怎么保证并发安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearrayset%E4%BB%A5%E4%BD%95%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E4%B8%8D%E9%87%8D%E5%A4%8D"><span class="toc-number">90.</span> <span class="toc-text"> CopyOnWriteArraySet 以何种方式保证元素不重复？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAset%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E4%B8%80%E8%87%B4"><span class="toc-number">91.</span> <span class="toc-text"> 如何比较两个 Set 中的元素是否完全一致？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAlist%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E7%9B%B8%E7%AD%89%E5%91%A2"><span class="toc-number">92.</span> <span class="toc-text"> 如何比较两个 List 中的元素是否完全相等呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentskiplistset%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AFconcurrentskiplistmap%E5%90%97"><span class="toc-number">93.</span> <span class="toc-text"> ConcurrentSkipListSet 的底层是 ConcurrentSkipListMap 吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentskiplistset%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97%E6%80%8E%E4%B9%88%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%B3%95"><span class="toc-number">94.</span> <span class="toc-text"> ConcurrentSkipListSet 是有序的吗？怎么个有序法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentskiplistset%E6%BA%90%E7%A0%81"><span class="toc-number">95.</span> <span class="toc-text"> ConcurrentSkipListSet 源码？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E5%8C%96"><span class="toc-number">96.</span> <span class="toc-text"> 什么是堆？什么是堆化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">97.</span> <span class="toc-text"> 什么是优先级队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityqueue%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">98.</span> <span class="toc-text"> PriorityQueue 是怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityqueue%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%E5%90%97"><span class="toc-number">99.</span> <span class="toc-text"> PriorityQueue 是有序的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityqueue%E5%85%A5%E9%98%9F-%E5%87%BA%E9%98%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">100.</span> <span class="toc-text"> PriorityQueue 入队、出队的时间复杂度各是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityqueue%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99%E5%91%A2"><span class="toc-number">101.</span> <span class="toc-text"> PriorityQueue 是否需要扩容？扩容规则呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arrayblockingqueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">102.</span> <span class="toc-text"> ArrayBlockingQueue 的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arrayblockingqueue%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9"><span class="toc-number">103.</span> <span class="toc-text"> ArrayBlockingQueue 是否需要扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arrayblockingqueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">104.</span> <span class="toc-text"> ArrayBlockingQueue 怎么保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arrayblockingqueue%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="toc-number">105.</span> <span class="toc-text"> ArrayBlockingQueue 有什么缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedblockingqueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">106.</span> <span class="toc-text"> LinkedBlockingQueue 的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedblockingqueue%E6%98%AF%E6%9C%89%E7%95%8C%E7%9A%84%E8%BF%98%E6%98%AF%E6%97%A0%E7%95%8C%E7%9A%84%E9%98%9F%E5%88%97"><span class="toc-number">107.</span> <span class="toc-text"> LinkedBlockingQueue 是有界的还是无界的队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedblockingqueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">108.</span> <span class="toc-text"> LinkedBlockingQueue 怎么保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedblockingqueue%E4%B8%8Earrayblockingqueue%E5%AF%B9%E6%AF%94"><span class="toc-number">109.</span> <span class="toc-text"> LinkedBlockingQueue 与 ArrayBlockingQueue 对比？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronousqueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">110.</span> <span class="toc-text"> SynchronousQueue 的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronousqueue%E7%9C%9F%E7%9A%84%E6%98%AF%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84%E5%90%97"><span class="toc-number">111.</span> <span class="toc-text"> SynchronousQueue 真的是无缓冲的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronousqueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">112.</span> <span class="toc-text"> SynchronousQueue 怎么保证线程安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transfer%E6%96%B9%E6%B3%95"><span class="toc-number">112.1.</span> <span class="toc-text"> transfer () 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronousqueue%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">113.</span> <span class="toc-text"> SynchronousQueue 的公平模式和非公平模式有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronousqueue%E5%9C%A8%E9%AB%98%E5%B9%B6%E5%8F%91%E6%83%85%E6%99%AF%E4%B8%8B%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">114.</span> <span class="toc-text"> SynchronousQueue 在高并发情景下会有什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityblockingqueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">115.</span> <span class="toc-text"> PriorityBlockingQueue 的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityblockingqueue%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E6%89%A9%E5%AE%B9"><span class="toc-number">116.</span> <span class="toc-text"> PriorityBlockingQueue 是否需要扩容？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityblockingqueue%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">117.</span> <span class="toc-text"> PriorityBlockingQueue 怎么保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#priorityblockingqueue%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81notfull%E6%9D%A1%E4%BB%B6"><span class="toc-number">118.</span> <span class="toc-text"> PriorityBlockingQueue 为什么不需要 notFull 条件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E9%87%8D%E9%98%9F%E5%88%97"><span class="toc-number">119.</span> <span class="toc-text"> 什么是双重队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedtransferqueue%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84"><span class="toc-number">120.</span> <span class="toc-text"> LinkedTransferQueue 是怎么实现阻塞队列的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedtransferqueue%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">121.</span> <span class="toc-text"> LinkedTransferQueue 是怎么控制并发安全的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xfer"><span class="toc-number">121.1.</span> <span class="toc-text"> xfer()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedtransferqueue%E4%B8%8Esynchronousqueue%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C"><span class="toc-number">122.</span> <span class="toc-text"> LinkedTransferQueue 与 SynchronousQueue 有什么异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentlinkedqueue%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%90%97"><span class="toc-number">123.</span> <span class="toc-text"> ConcurrentLinkedQueue 是阻塞队列吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentlinkedqueue%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">124.</span> <span class="toc-text"> ConcurrentLinkedQueue 如何保证并发安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentlinkedqueue%E8%83%BD%E7%94%A8%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%97"><span class="toc-number">125.</span> <span class="toc-text"> ConcurrentLinkedQueue 能用于线程池吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrentlinkedqueue%E4%B8%8Elinkedblockingqueue%E5%AF%B9%E6%AF%94"><span class="toc-number">126.</span> <span class="toc-text"> ConcurrentLinkedQueue 与 LinkedBlockingQueue 对比？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delayqueue%E6%98%AF%E9%98%BB%E5%A1%9E-%E9%98%9F%E5%88%97%E5%90%97"><span class="toc-number">127.</span> <span class="toc-text"> DelayQueue 是阻塞 - 队列吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delayqueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">128.</span> <span class="toc-text"> DelayQueue 的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delayqueue%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">129.</span> <span class="toc-text"> DelayQueue 如何保证并发安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delayqueue%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF"><span class="toc-number">130.</span> <span class="toc-text"> DelayQueue 主要用于什么场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%94%A8%E7%9A%84delayqueue%E5%90%97"><span class="toc-number">131.</span> <span class="toc-text"> java 中的线程池实现定时任务是直接用的 DelayQueue 吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">132.</span> <span class="toc-text"> 什么是双端队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arraydeque%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84"><span class="toc-number">133.</span> <span class="toc-text"> ArrayDeque 是怎么实现双端队列的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedlist%E4%B8%8Earraydeque%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">134.</span> <span class="toc-text"> LinkedList 与 ArrayDeque 的对比？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%A0%88%E4%BD%BF%E7%94%A8"><span class="toc-number">135.</span> <span class="toc-text"> 双端队列是否可以作为栈使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linkedlist%E6%98%AFlist%E5%92%8Cdeque%E7%9A%84%E9%9B%86%E5%90%88%E4%BD%93"><span class="toc-number">136.</span> <span class="toc-text"> LinkedList 是 List 和 Deque 的集合体？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">137.</span> <span class="toc-text"> 集合指定初始容量的好处？</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/09/05/mysql%E9%A2%98%E7%9B%AE/" title="mysql问题"><img src="/img/me.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql问题"/></a><div class="content"><a class="title" href="/2021/09/05/mysql%E9%A2%98%E7%9B%AE/" title="mysql问题">mysql问题</a><time datetime="2021-09-05T14:02:14.000Z" title="发表于 2021-09-05 22:02:14">2021-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/05/%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/" title="集合问题"><img src="/img/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集合问题"/></a><div class="content"><a class="title" href="/2021/09/05/%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/" title="集合问题">集合问题</a><time datetime="2021-09-05T01:26:59.000Z" title="发表于 2021-09-05 09:26:59">2021-09-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/6.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 By Kris</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">联系vx：Mizika02</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'hello-cloudbase-6gi7gi2qdd31baea',
      region: 'ap-shanghai'
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'hello-cloudbase-6gi7gi2qdd31baea',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><div class="aplayer no-destroy" data-id="6921693374" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script async src="/js/custom.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '#bgm-test',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script></div><!-- hexo injector body_end start --><script data-pjax>
                        function butterfly_swiper_injector_config(){
                          var parent_div_git = document.getElementById('recent-posts');
                          var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
                          console.log('已挂载butterfly_swiper')
                          // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                          parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
                          }
                        if( document.getElementById('recent-posts') && (location.pathname ==='all'|| 'all' ==='all')){
                        butterfly_swiper_injector_config()
                        }
                      </script><script defer src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/4.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>