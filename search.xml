<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql</title>
      <link href="/2021/09/11/mysql/"/>
      <url>/2021/09/11/mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库面试知识点汇总"><a class="markdownIt-Anchor" href="#数据库面试知识点汇总">#</a> 数据库面试知识点汇总</h1><h2 id="一-基本概念"><a class="markdownIt-Anchor" href="#一-基本概念">#</a> 一、基本概念</h2><h4 id="1主键-外键-超键-候选键"><a class="markdownIt-Anchor" href="#1主键-外键-超键-候选键">#</a> <strong>1. 主键、外键、超键、候选键</strong></h4><blockquote><p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p><p><strong>主键</strong>：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</p></blockquote><h4 id="2为什么用自增列作为主键"><a class="markdownIt-Anchor" href="#2为什么用自增列作为主键">#</a> <strong>2. 为什么用自增列作为主键</strong></h4><blockquote><p>如果我们定义了主键 (PRIMARY KEY)，那么 InnoDB 会选择主键作为聚集索引、</p><p>如果没有显式定义主键，则 InnoDB 会选择第一个不包含有 NULL 值的唯一索引作为主键索引、</p><p>如果也没有这样的唯一索引，则 InnoDB 会选择内置 6 字节长的 ROWID 作为隐含的聚集索引 (ROWID 随着行记录的写入而主键递增，这个 ROWID 不像 ORACLE 的 ROWID 那样可引用，是隐含的)。</p><p>数据记录本身被存于主索引（一颗 B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL 会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB 默认为 15/16），则开辟一个新的页（节点）</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时 MySQL 不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。</p></blockquote><h4 id="3触发器的作用"><a class="markdownIt-Anchor" href="#3触发器的作用">#</a> <strong>3. 触发器的作用？</strong></h4><blockquote><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p></blockquote><h4 id="4什么是存储过程用什么来调用"><a class="markdownIt-Anchor" href="#4什么是存储过程用什么来调用">#</a> <strong>4. 什么是存储过程？用什么来调用？</strong></h4><blockquote><p>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。</p><p><strong>调用：</strong></p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java 程序。</p></blockquote><h4 id="5存储过程的优缺点"><a class="markdownIt-Anchor" href="#5存储过程的优缺点">#</a> <strong>5. 存储过程的优缺点？</strong></h4><blockquote><p><strong>优点：</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p><p>** 缺点：** 移植性差</p></blockquote><h4 id="6存储过程与函数的区别"><a class="markdownIt-Anchor" href="#6存储过程与函数的区别">#</a> <strong>6. 存储过程与函数的区别</strong></h4><p><img src="https://i.imgur.com/ymE9HPJ.png" alt="img"></p><h4 id="7什么叫视图游标是什么"><a class="markdownIt-Anchor" href="#7什么叫视图游标是什么">#</a> <strong>7. 什么叫视图？游标是什么？</strong></h4><blockquote><p><strong>视图：</strong></p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong></p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p></blockquote><h4 id="8视图的优缺点"><a class="markdownIt-Anchor" href="#8视图的优缺点">#</a> <strong>8. 视图的优缺点</strong></h4><blockquote><p><strong>优点：</strong></p><p>1 对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p><p>2) 用户通过简单的查询可以从复杂查询中得到结果。</p><p>3) 维护数据的独立性，试图可从多个表检索数据。</p><p>4) 对于相同的数据可产生不同的视图。</p><p><strong>缺点：</strong></p><p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p></blockquote><h4 id="9drop-truncate-delete区别"><a class="markdownIt-Anchor" href="#9drop-truncate-delete区别">#</a> <strong>9.drop、truncate、 delete 区别</strong></h4><blockquote><p><strong>最基本：</strong></p><ul><li>drop 直接删掉表。</li><li>truncate 删除表中数据，再插入时自增长 id 又从 1 开始。</li><li>delete 删除表中数据，可以加 where 字句。</li></ul><p>（1） DELETE 语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被 TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而 DELETE 操作不会减少表或索引所占用的空间。drop 语句将表所占用的空间全释放掉。</p><p>（3） 一般而言，drop &gt; truncate &gt; delete</p><p>（4） 应用范围。TRUNCATE 只能对 TABLE；DELETE 可以是 table 和 view</p><p>（5） TRUNCATE 和 DELETE 只删除数据，而 DROP 则删除整个表（结构和数据）。</p><p>（6） truncate 与不带 where 的 delete ：只删除数据，而不删除表的结构（定义）drop 语句将删除表的结构被依赖的约束（constrain), 触发器（trigger) 索引（index); 依赖于该表的存储过程 / 函数将被保留，但其状态会变为：invalid。</p><p>（7） delete 语句为 DML（data maintain Language), 这个操作会被放到 rollback segment 中，事务提交后才生效。如果有相应的 tigger, 执行的时候将被触发。</p><p>（8） truncate、drop 是 DLL（data define language), 操作立即生效，原数据不放到 rollback segment 中，不能回滚。</p><p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用 delete 且注意结合 where 来约束影响范围。回滚段要足够大。要删除表用 drop; 若想保留表而将表中数据删除，如果于事务无关，用 truncate 即可实现。如果和事务有关，或老师想触发 trigger, 还是用 delete。</p><p>（10） Truncate table 表名 速度快，而且效率高，因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p></blockquote><h4 id="10什么是临时表临时表什么时候删除"><a class="markdownIt-Anchor" href="#10什么是临时表临时表什么时候删除">#</a> <strong>10. 什么是临时表，临时表什么时候删除？</strong></h4><blockquote><p><strong>临时表可以手动删除：</strong><br>DROP TEMPORARY TABLE IF EXISTS temp_tb;</p><p><strong>临时表只在当前连接可见，当关闭连接时，MySQL 会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。创建临时表的语法与创建表语法类似，不同之处是增加关键字 TEMPORARY，</strong></p><p>如：</p><p>CREATE TEMPORARY TABLE tmp_table (</p><p>NAME VARCHAR (10) NOT NULL,</p><p>time date NOT NULL<br>);</p><p>select * from tmp_table;</p></blockquote><h4 id="11非关系型数据库和关系型数据库区别优势比较"><a class="markdownIt-Anchor" href="#11非关系型数据库和关系型数据库区别优势比较">#</a> <strong>11. 非关系型数据库和关系型数据库区别，优势比较？</strong></h4><blockquote><p><strong>非关系型数据库的优势：</strong></p><ul><li>** 性能：**NOSQL 是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过 SQL 层的解析，所以性能非常高。</li><li>** 可扩展性：** 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><p><strong>关系型数据库的优势：</strong></p><ul><li>** 复杂查询：** 可以用 SQL 语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li>** 事务支持：** 使得对于安全性能很高的数据访问要求得以实现。</li></ul><p><strong>其他：</strong></p><p>**1.** 对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p>**2.**NOSQL 数据库慢慢开始具备 SQL 数据库的一些复杂查询功能，比如 MongoDB。</p><p>**3.** 对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如 Redis set nx。</p></blockquote><h4 id="12数据库范式根据某个场景设计数据表"><a class="markdownIt-Anchor" href="#12数据库范式根据某个场景设计数据表">#</a> <strong>12. 数据库范式，根据某个场景设计数据表？</strong></h4><blockquote><p><strong>第一范式:</strong>(确保每列保持原子性) 所有字段值都是不可分解的原子值。</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到 “地址” 这个属性，本来直接将 “地址” 属性设计成一个数据库表的字段就行。但是如果系统经常会访问 “地址” 属性中的 “城市” 部分，那么就非要将 “地址” 这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><p><strong>第二范式:</strong>(确保表中的每列都和主键相关) 在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p><strong>第三范式:</strong>(确保每列都和主键列直接相关，而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p>**BCNF:** 符合 3NF，并且，主属性不依赖于主属性。</p><p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则 R 属于 BC 范式。<br>通常 BC 范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。<br>BC 范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足 BC 范式的关系都必然满足第三范式。<br>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到 BC 范式。<br>一般，一个数据库设计符合 3NF 或 BCNF 就可以了。</p><p>** 第四范式:** 要求把同一表内的多对多关系删除。</p><p>** 第五范式:** 从最终结构重新建立原始结构。</p></blockquote><h4 id="13什么是-内连接-外连接-交叉连接-笛卡尔积等"><a class="markdownIt-Anchor" href="#13什么是-内连接-外连接-交叉连接-笛卡尔积等">#</a> <strong>13. 什么是 内连接、外连接、交叉连接、笛卡尔积等？</strong></h4><blockquote><p><strong>内连接:</strong> 只连接匹配的行</p><p><strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p>例如 1：<br>SELECT a.<em>,b.</em> FROM luntan LEFT JOIN usertable as b ON a.username=b.username</p><p>例如 2：<br>SELECT a.<em>,b.</em> FROM city as a FULL OUTER JOIN user as b ON a.username=b.username</p><p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p><p><strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>例如：<br>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</p><p><strong>注意：</strong></p><p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写 sql, 一般都是简单的连接查询，具体关于连接查询的 sql 练习，参见以下链接：</p><p><a href="https://www.nowcoder.com/ta/sql">牛客网数据库 SQL 实战</a></p><p><a href="https://leetcode-cn.com/problemset/database/">leetcode 中文网站数据库练习</a></p><p><a href="http://www.baidu.com/">我的另一篇文章，常用 sql 练习 50 题</a></p></blockquote><h4 id="14varchar和char的使用场景"><a class="markdownIt-Anchor" href="#14varchar和char的使用场景">#</a> <strong>14.varchar 和 char 的使用场景？</strong></h4><blockquote></blockquote><blockquote><p>**1.**char 的长度是不可变的，而 varchar 的长度是可变的。</p><p>定义一个 char [10] 和 varchar [10]。<br>如果存进去的是‘csdn’, 那么 char 所占的长度依然为 10，除了字符‘csdn’外，后面跟六个空格，varchar 就立马把长度变为 4 了，取数据的时候，char 类型的要用 trim () 去掉多余的空格，而 varchar 是不需要的。</p><p>**2.**char 的存取数度还是要比 varchar 要快得多，因为其长度固定，方便程序的存储与查找。<br>char 也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar 是以空间效率为首位。</p><p>**3.**char 的存储方式是：对英文字符（ASCII）占用 1 个字节，对一个汉字占用两个字节。<br>varchar 的存储方式是：对每个英文字符占用 2 个字节，汉字也占用 2 个字节。</p><p>**4.** 两者的存储数据都非 unicode 的字符数据。</p></blockquote><h4 id="15sql语言分类"><a class="markdownIt-Anchor" href="#15sql语言分类">#</a> <strong>15.SQL 语言分类</strong></h4><blockquote><p><strong>SQL 语言共分为四大类：</strong></p><ul><li>数据查询语言 DQL</li><li>数据操纵语言 DML</li><li>数据定义语言 DDL</li><li>数据控制语言 DCL。</li></ul><p><strong>1. 数据查询语言 DQL</strong></p><p>数据查询语言 DQL 基本结构是由 SELECT 子句，FROM 子句，WHERE 子句组成的查询块：</p><p>SELECT<br>FROM<br>WHERE</p><p><strong>2 . 数据操纵语言 DML</strong></p><p>数据操纵语言 DML 主要有三种形式：</p><ol><li>插入：INSERT</li><li>更新：UPDATE</li><li>删除：DELETE</li></ol><p><strong>3. 数据定义语言 DDL</strong></p><p>数据定义语言 DDL 用来创建数据库中的各种对象 ----- 表、视图、索引、同义词、聚簇等如：<br>CREATE TABLE/VIEW/INDEX/SYN/CLUSTER</p><p>表 视图 索引 同义词 簇</p><p>DDL 操作是隐性提交的！不能 rollback</p><p><strong>4. 数据控制语言 DCL</strong></p><p>数据控制语言 DCL 用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><ol><li>GRANT：授权。</li><li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚 —ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br>SQL&gt;ROLLBACK;</li><li>COMMIT [WORK]：提交。</li></ol><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用 COMMIT 命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用 SQL 命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把 AUTOCOMMIT 设置为 ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><p>参考文章：<br><a href="https://www.cnblogs.com/study-s/p/5287529.html">https://www.cnblogs.com/study-s/p/5287529.html</a></p></blockquote><h4 id="16like-和-的区别"><a class="markdownIt-Anchor" href="#16like-和-的区别">#</a> <strong>16.like % 和 - 的区别</strong></h4><blockquote><p><strong>通配符的分类:</strong></p><p>**% 百分号通配符:** 表示任何字符出现任意次数 (可以是 0 次).</p><p>**_下划线通配符:** 表示只能匹配单个字符，不能多也不能少，就是一个字符.</p><p><strong>like 操作符:</strong> LIKE 作用是指示 mysql 后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><p><strong>注意:</strong> 如果在使用 like 操作符时，后面的没有使用通用匹配符效果是和 = 一致的，SELECT * FROM products WHERE products.prod_name like ‘1000’;<br> 只能匹配的结果为 1000, 而不能匹配像 JetPack 1000 这样的结果.</p><ul><li>% 通配符使用：匹配以 &quot;yves&quot; 开头的记录：(包括记录 &quot;yves&quot;) SELECT <em>FROM products WHERE products.prod_name like ‘yves%’; 匹配包含 &quot;yves&quot; 的记录 (包括记录 &quot;yves&quot;) SELECT</em> FROM products WHERE products.prod_name like ‘%yves%’;<br> 匹配以 &quot;yves&quot; 结尾的记录 (包括记录 &quot;yves&quot;, 不包括记录 &quot;yves&quot;, 也就是 yves 后面有空格的记录，这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘% yves’;</li><li><em>通配符使用: SELECT FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为：像 &quot;yyves&quot; 这样记录.SELECT FROM products WHERE products.prod*name like 'yves</em>*’; 匹配结果为：像 &quot;yvesHe&quot; 这样的记录.(一个下划线只能匹配一个字符，不能多也不能少)</li></ul><p><strong>注意事项:</strong></p><ul><li>注意大小写，在使用模糊匹配时，也就是匹配文本时，mysql 是可能区分大小的，也可能是不区分大小写的，这个结果是取决于用户对 MySQL 的配置方式。如果是区分大小写，那么像 YvesHe 这样记录是不能被 &quot;yves__&quot; 这样的匹配条件匹配的.</li><li>注意尾部空格，&quot;% yves&quot; 是不能匹配 &quot;heyves&quot; 这样的记录的.</li><li>注意 NULL,% 通配符可以匹配任意字符，但是不能匹配 NULL, 也就是说 SELECT * FROM products WHERE products.prod_name like '%; 是匹配不到 products.prod_name 为 NULL 的的记录.</li></ul><p><strong>技巧与建议:</strong></p><p>正如所见， MySQL 的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</li></ul></blockquote><p>参考博文：<a href="https://blog.csdn.net/u011479200/article/details/78513632">https://blog.csdn.net/u011479200/article/details/78513632</a></p><h4 id="17count-count1-countcolumn的区别"><a class="markdownIt-Anchor" href="#17count-count1-countcolumn的区别">#</a> <strong>17.count (*)、count (1)、count (column) 的区别</strong></h4><blockquote><ul><li>count (*) 对行的数目进行计算，包含 NULL</li><li>count (column) 对特定的列的值具有的行数进行计算，不包含 NULL 值。</li><li>count () 还有一种使用方式，count (1) 这个用法和 count (*) 的结果是一样的。</li></ul><p><strong>性能问题:</strong></p><p>1. 任何情况下 SELECT COUNT (*) FROM tablename 是最优选择；</p><p>2. 尽量减少 SELECT COUNT (*) FROM tablename WHERE COL = ‘value’ 这种查询；</p><p>3. 杜绝 SELECT COUNT (COL) FROM tablename WHERE COL2 = ‘value’ 的出现。</p><ul><li>如果表没有主键，那么 count (1) 比 count (*) 快。</li><li>如果有主键，那么 count (主键，联合主键) 比 count (*) 快。</li><li>如果表只有一个字段，count (*) 最快。</li></ul><p>count (1) 跟 count (主键) 一样，只扫描主键。count (*) 跟 count (非主键) 一样，扫描整个表。明显前者更快一些。</p></blockquote><h4 id="18最左前缀原则"><a class="markdownIt-Anchor" href="#18最左前缀原则">#</a> <strong>18. 最左前缀原则</strong></h4><blockquote><p><strong>多列索引：</strong></p><p>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</p><p>为了提高搜索效率，我们需要考虑运用多列索引，由于索引文件以 B－Tree 格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p>注：在 mysql 中执行查询时，只能使用一个索引，如果我们在 lname,fname,age 上分别建索引，执行查询时，只能使用一个索引，mysql 会选择一个最严格 (获得结果集记录数最少) 的索引。</p><p>** 最左前缀原则：** 顾名思义，就是最左优先，上例中我们创建了 lname_fname_age 多列索引，相当于创建了 (lname) 单列索引，(lname,fname) 组合索引以及 (lname,fname,age) 组合索引。</p></blockquote><h2 id="二-索引"><a class="markdownIt-Anchor" href="#二-索引">#</a> 二、索引</h2><h4 id="1什么是索引"><a class="markdownIt-Anchor" href="#1什么是索引">#</a> <strong>1. 什么是索引？</strong></h4><blockquote><p><strong>何为索引：</strong></p><p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用 B 树及其变种 B + 树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p></blockquote><h4 id="2索引的作用它的优点缺点是什么"><a class="markdownIt-Anchor" href="#2索引的作用它的优点缺点是什么">#</a> <strong>2. 索引的作用？它的优点缺点是什么？</strong></h4><blockquote><p><strong>索引作用：</strong></p><p>协助快速查询、更新数据库表中数据。</p><p>为表设置索引要付出代价的：</p><ul><li><p>一是增加了数据库的存储空间</p></li><li><p>二是在插入和修改数据时要花费较多的时间 (因为索引也要随之变动)。</p><h4 id="3索引的优缺点"><a class="markdownIt-Anchor" href="#3索引的优缺点">#</a> <strong>3. 索引的优缺点？</strong></h4></li></ul><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p><p>1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2. 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4. 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5. 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面 (缺点)：</strong></p><p>1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h4 id="4哪些列适合建立索引-哪些不适合建索引"><a class="markdownIt-Anchor" href="#4哪些列适合建立索引-哪些不适合建索引">#</a> <strong>4. 哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong></p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在 WHERE 子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong></p><p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>（2）对于那些只有很少数据值的列也不应该增加索引。</p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>（3）对于那些定义为 text, image 和 bit 数据类型的列不应该增加索引。</p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>(4) 当修改性能远远大于检索性能时，不应该创建索引。</p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></blockquote><h4 id="5什么样的字段适合建索引"><a class="markdownIt-Anchor" href="#5什么样的字段适合建索引">#</a> <strong>5. 什么样的字段适合建索引</strong></h4><blockquote><p>唯一、不为空、经常被查询的字段</p><h4 id="6mysql-btree索引和hash索引的区别"><a class="markdownIt-Anchor" href="#6mysql-btree索引和hash索引的区别">#</a> <strong>6.MySQL B+Tree 索引和 Hash 索引的区别？</strong></h4><p><strong>Hash 索引和 B + 树索引的特点：</strong></p><ul><li>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位；</li><li>B + 树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的 IO 访问；</li></ul><p><strong>为什么不都用 Hash 索引而使用 B + 树索引？</strong></p><ol><li>Hash 索引仅仅能满足 &quot;=&quot;,“IN&quot;和”&quot; 查询，不能使用范围查询，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和 Hash 运算前完全一样；</li><li>Hash 索引无法被用来避免数据的排序操作，因为 Hash 值的大小关系并不一定和 Hash 运算前的键值完全一样；</li><li>Hash 索引不能利用部分索引键查询，对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用；</li><li>Hash 索引在任何时候都不能避免表扫描，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要回表查询数据；</li><li>Hash 索引遇到大量 Hash 值相等的情况后性能并不一定就会比 B + 树索引高。</li></ol><p><strong>补充：</strong></p><p>1.MySQL 中，只有 HEAP/MEMORY 引擎才显示支持 Hash 索引。</p><p>2. 常用的 InnoDB 引擎中默认使用的是 B + 树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的 “自适应哈希索引缓冲区” 建立哈希索引（在 InnoDB 中默认开启自适应哈希索引），通过观察搜索模式，MySQL 会利用 index key 的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>B + 树索引和哈希索引的明显区别是：</p><p>3. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p><p>4. 如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及 like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p><p>5. 哈希索引也不支持多列联合索引的最左匹配规则；</p><p>6.B + 树索引的关键字检索效率比较平均，不像 B 树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p><p>7. 在大多数场景下，都会有范围查询、排序、分组等查询特征，用 B + 树索引就可以了。</p></blockquote><h4 id="7b树和b树的区别"><a class="markdownIt-Anchor" href="#7b树和b树的区别">#</a> <strong>7.B 树和 B + 树的区别</strong></h4><blockquote><ol><li>B 树，每个节点都存储 key 和 data，所有节点组成这棵树，并且叶子节点指针为 nul，叶子结点不包含任何关键字信息。<br><img src="https://i.imgur.com/RbzI0R8.jpg" alt="img"></li><li>B + 树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而 B 树的非终节点也包含需要查找的有效信息)<br><img src="https://i.imgur.com/9VbnDME.jpg" alt="img"></li></ol></blockquote><h4 id="8为什么说b比b树更适合实际应用中操作系统的文件索引和数据库索引"><a class="markdownIt-Anchor" href="#8为什么说b比b树更适合实际应用中操作系统的文件索引和数据库索引">#</a> <strong>8. 为什么说 B + 比 B 树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><blockquote><p><strong>1.B + 的磁盘读写代价更低</strong></p><p>B + 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</p><p><strong>2.B+tree 的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><h4 id="9聚集索引和非聚集索引区别"><a class="markdownIt-Anchor" href="#9聚集索引和非聚集索引区别">#</a> <strong>9. 聚集索引和非聚集索引区别？</strong></h4><blockquote><p><strong>聚合索引 (clustered index):</strong></p><p>聚集索引 ** 表记录的排列顺序和索引的排列顺序一致，所以查询效率快，** 只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照 a~z 排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找 a,ai 两个读音的字，或是想一次寻找多个傻 (sha) 的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p><p><strong>非聚合索引 (nonclustered index):</strong></p><p>非聚集索引 ** 指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，** 两种索引都采用 B + 树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是 a~z 的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p><p><strong>根本区别：</strong></p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p></blockquote><h2 id="三-事务"><a class="markdownIt-Anchor" href="#三-事务">#</a> 三、事务</h2><h4 id="1什么是事务"><a class="markdownIt-Anchor" href="#1什么是事务">#</a> <strong>1. 什么是事务？</strong></h4><blockquote><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p></blockquote><h4 id="2事务四大特性acid原子性-一致性-隔离性-持久性"><a class="markdownIt-Anchor" href="#2事务四大特性acid原子性-一致性-隔离性-持久性">#</a> <strong>2. 事务四大特性（ACID）原子性、一致性、隔离性、持久性？</strong></h4><blockquote><p><strong>原子性（Atomicity）:</strong><br> 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong><br> 事务开始前和结束后，数据库的完整性约束没有被破坏。比如 A 向 B 转账，不可能 A 扣了钱，B 却没收到。</p><p><strong>隔离性（Isolation）:</strong><br> 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如 A 正在从一张银行卡中取钱，在 A 取钱的过程结束前，B 不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong><br> 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></blockquote><h4 id="3事务的并发事务隔离级别每个级别会引发什么问题mysql默认是哪个级别"><a class="markdownIt-Anchor" href="#3事务的并发事务隔离级别每个级别会引发什么问题mysql默认是哪个级别">#</a> <strong>3. 事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL 默认是哪个级别？</strong></h4><blockquote><p>从理论上来说，事务应该彼此完全隔离，以避免并发事务所导致的问题，然而，那样会对性能产生极大的影响，因为事务必须按顺序运行， 在实际开发中，为了提升性能，事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。<br><strong>事务的并发问题</strong></p><p>**1、脏读：** 事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</p><p>**2、不可重复读：** 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p>**3、幻读：** 幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p><p>例如：事务 T1 对一个表中所有的行的某个数据项做了从 “1” 修改为 “2” 的操作 这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为 “1” 并且提交给数据库。 而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p><p><strong>事务的隔离级别</strong></p><p><img src="https://i.imgur.com/xAeWTSp.png" alt="img"></p><p>** 读未提交：** 另一个事务修改了数据，但尚未提交，而本事务中的 SELECT 会读到这些未被提交的数据脏读</p><p>** 不可重复读：** 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p>** 可重复读：** 在同一个事务里，SELECT 的结果是事务开始时时间点的状态，因此，同样的 SELECT 操作读到的结果会是一致的。但是，会有幻读现象</p><p>** 串行化：** 最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p></blockquote><p><strong>特别注意：</strong></p><blockquote><p>MySQL 默认的事务隔离级别为 repeatable-read</p><p>MySQL 支持 4 中事务隔离级别.</p><p>事务的隔离级别要得到底层数据库引擎的支持，而不是应用程序或者框架的支持.</p><p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p><p>SQL 规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p><strong>MySQL 中默认事务隔离级别是 “可重复读” 时并不会锁住读取到的行</strong></p><p>** 事务隔离级别：** 未提交读时，写数据只会锁住相应的行。</p><p>** 事务隔离级别为：** 可重复读时，写数据会锁住整张表。</p><p>** 事务隔离级别为：** 串行化时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为 Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p></blockquote><h4 id="4事务传播行为"><a class="markdownIt-Anchor" href="#4事务传播行为">#</a> <strong>4. 事务传播行为</strong></h4><blockquote><p>**1.PROPAGATION_REQUIRED：** 如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p>**2.PROPAGATION_SUPPORTS：** 支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p>**3.PROPAGATION_MANDATORY：** 支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p>**4.PROPAGATION_REQUIRES_NEW：** 创建新事务，无论当前存不存在事务，都创建新事务。</p><p>**5.PROPAGATION_NOT_SUPPORTED：** 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>**6.PROPAGATION_NEVER：** 以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>**7.PROPAGATION_NESTED：** 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</p></blockquote><h4 id="5嵌套事务"><a class="markdownIt-Anchor" href="#5嵌套事务">#</a> <strong>5. 嵌套事务</strong></h4><blockquote><p><strong>什么是嵌套事务？</strong></p><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫 save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个 save point。看几个问题就明了了：</p><p><strong>如果子事务回滚，会发生什么？</strong></p><p>父事务会回滚到进入子事务前建立的 save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p><p><strong>事务的提交，是什么情况？</strong></p><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p></blockquote><p>参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p><h2 id="四-存储引擎"><a class="markdownIt-Anchor" href="#四-存储引擎">#</a> 四、存储引擎</h2><h4 id="1mysql常见的三种存储引擎innodb-myisam-memory的区别"><a class="markdownIt-Anchor" href="#1mysql常见的三种存储引擎innodb-myisam-memory的区别">#</a> <strong>1.MySQL 常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？</strong></h4><blockquote><p><strong>两种存储引擎的大致区别表现在：</strong></p><p>1.<strong>InnoDB 支持事务，MyISAM 不支持，</strong> ** 这一点是非常之重要。** 事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而 MyISAM 就不可以了。</p><p>2.MyISAM 适合查询以及插入为主的应用。</p><p>3.InnoDB 适合频繁修改以及涉及到安全性较高的应用。</p><p>4.InnoDB 支持外键，MyISAM 不支持。</p><p>5. 从 MySQL5.5.5 以后，InnoDB 是默认引擎。</p><p>6.InnoDB 不支持 FULLTEXT 类型的索引。</p><p>7.InnoDB 中不保存表的行数，如 select count (<em>) from table 时，InnoDB 需要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 count (</em>) 语句包含 where 条件时 MyISAM 也需要扫描整个表。</p><p>8. 对于自增长的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中可以和其他字段一起建立联合索引。</p><p>9.DELETE FROM table 时，InnoDB 不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM 则会重建表。</p><p>10.InnoDB 支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘% lee%’。</p></blockquote><h4 id="2mysql存储引擎myisam与innodb如何选择"><a class="markdownIt-Anchor" href="#2mysql存储引擎myisam与innodb如何选择">#</a> <strong>2.MySQL 存储引擎 MyISAM 与 InnoDB 如何选择</strong></h4><blockquote><p>MySQL 有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY (HEAP)、BDB (BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p>虽然 MySQL 里的存储引擎不只是 MyISAM 与 InnoDB 这两个，但常用的就是两个。<br>关于 MySQL 数据库提供的两种存储引擎，MyISAM 与 InnoDB 选择使用：</p></blockquote><ul><li>1.INNODB 会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM 不支持。</li><li>2.MyISAM 的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</li></ul><blockquote><p>如果你的应用程序一定要使用事务，毫无疑问你要选择 INNODB 引擎。但要注意，INNODB 的行级锁是有条件的。在 where 条件没有使用主键时，照样会锁全表。比如 DELETE FROM mytable 这样的删除语句。</p><p>如果你的应用程序对查询性能要求较高，就要使用 MyISAM 了。MyISAM 索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于 INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM 拥有全文索引的功能，这可以极大地优化 LIKE 查询的效率。</p><p>有人说 MyISAM 只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p><p>现在一般都是选用 innodb 了，主要是 MyISAM 的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM 对于读写密集型应用一般是不会去选用的。<br>MEMORY 存储引擎</p><p>MEMORY 是 MySQL 中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。<br>每个基于 MEMORY 存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为 frm 类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持 MEMORY 存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY 默认使用哈希索引。速度比使用 B 型树索引快。当然如果你想用 B 型树索引，可以在创建索引时指定。</p><p>注意，MEMORY 用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于 MEMORY 的表的生命周期很短，一般是一次性的。</p></blockquote><h4 id="3mysql的myisam与innodb两种存储引擎在事务-锁级别各自的适用场景"><a class="markdownIt-Anchor" href="#3mysql的myisam与innodb两种存储引擎在事务-锁级别各自的适用场景">#</a> <strong>3.MySQL 的 MyISAM 与 InnoDB 两种存储引擎在，事务、锁级别，各自的适用场景？</strong></h4><blockquote><p><strong>事务处理上方面</strong></p></blockquote><ul><li>MyISAM：强调的是性能，每次查询具有原子性，其执行数度比 InnoDB 类型更快，但是不提供事务支持。</li><li>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务 (commit)、回滚 (rollback) 和崩溃修复能力 (crash recovery capabilities) 的事务安全 (transaction-safe (ACID compliant)) 型表。</li></ul><blockquote><p><strong>锁级别</strong></p></blockquote><ul><li>MyISAM：只支持表级锁，用户在操作 MyISAM 表时，select，update，delete，insert 语句都会给表自动加锁，如果加锁以后的表满足 insert 并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB：支持事务和行级锁，是 innodb 的最大特色。行锁大幅度提高了多用户并发操作的新能。但是 InnoDB 的行锁，只是在 WHERE 的主键是有效的，非主键的 WHERE 都会锁全表的。</li></ul><blockquote><p><strong>关于存储引擎 MyISAM 和 InnoDB 的其他参考资料如下：</strong></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL 存储引擎中的 MyISAM 和 InnoDB 区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL 存储引擎之 MyISAM 和 Innodb 总结性梳理</a></p></blockquote><h2 id="五-优化"><a class="markdownIt-Anchor" href="#五-优化">#</a> 五、优化</h2><h4 id="1查询语句不同元素where-jion-limit-group-by-having等等执行先后顺序"><a class="markdownIt-Anchor" href="#1查询语句不同元素where-jion-limit-group-by-having等等执行先后顺序">#</a> <strong>1. 查询语句不同元素（where、jion、limit、group by、having 等等）执行先后顺序？</strong></h4><ul><li>1. 查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong></li></ul><blockquote><p><strong>其中 select 和 from 是必须的，其他关键词是可选的，这六个关键词的执行顺序 与 sql 语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong></p><p>**from:** 需要从哪个数据表检索数据</p></blockquote><blockquote><p>**where:** 过滤表中数据的条件</p><p>**group by:** 如何将上面过滤出的数据分组</p><p>**having:** 对上面已经分组的数据进行过滤的条件</p><p>**select:** 查看结果集中的哪个列，或列的计算结果</p><p>**order by 😗* 按照什么样的顺序来查看返回的数据</p></blockquote><ul><li>2.<strong>from 后面的表关联，是自右向左解析 而 where 条件的解析顺序是自下而上的。</strong></li></ul><blockquote><p>也就是说，在写 SQL 语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在 where 语句的最左边 （用小表去匹配大表）</p><p>其他参考资源：<br><a href="http://www.cnblogs.com/huminxxl/p/3149097.html">http://www.cnblogs.com/huminxxl/p/3149097.html</a></p></blockquote><h4 id="2使用explain优化sql和索引"><a class="markdownIt-Anchor" href="#2使用explain优化sql和索引">#</a> <strong>2. 使用 explain 优化 sql 和索引？</strong></h4><blockquote><p><strong>对于复杂、效率低的 sql 语句，我们通常是使用 explain sql 来分析 sql 语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong></p><p>**table：** 显示这一行的数据是关于哪张表的</p><p>**type：** 这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为 const、eq_reg、ref、range、index 和 ALL</p><p>**all:**full table scan ;MySQL 将遍历全表以找到匹配的行；</p><p><strong>index:</strong> index scan; index 和 all 的区别在于 index 类型只遍历索引；</p><p>**range：** 索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与 between ，等查询；</p><p>**ref：** 非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p><p>**eq_ref：** 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p><p>**const，system：** 当 MySQL 对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于 where 列表中，MySQL 就能将该查询转化为一个常量。</p><p>**possible_keys：** 显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从 WHERE 语句中选择一个合适的语句</p><p><strong>key：</strong> 实际使用的索引。如果为 NULL，则没有使用索引。很少的情况下，MySQL 会选择优化不足的索引。这种情况下，可以在 SELECT 语句中使用 USE INDEX（indexname）来强制使用一个索引或者用 IGNORE INDEX（indexname）来强制 MySQL 忽略索引</p><p>**key_len：** 使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>**ref：** 显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p>**rows：**MySQL 认为必须检查的用来返回请求数据的行数</p><p>**Extra：** 关于 MySQL 如何解析查询的额外信息。将在表 4.3 中讨论，但这里可以看到的坏的例子是 Using temporary 和 Using filesort，意思 MySQL 根本不能使用索引，结果是检索会很慢。</p></blockquote><h4 id="3mysql慢查询怎么解决"><a class="markdownIt-Anchor" href="#3mysql慢查询怎么解决">#</a> <strong>3.MySQL 慢查询怎么解决？</strong></h4><blockquote><ul><li>slow_query_log 慢查询开启状态。</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要 MySQL 的运行帐号的可写权限，一般设置为 MySQL 的数据存放目录）。</li><li>long_query_time 查询超过多少秒才记录。</li></ul></blockquote><h2 id="六-数据库锁"><a class="markdownIt-Anchor" href="#六-数据库锁">#</a> 六、数据库锁</h2><h4 id="1mysql都有什么锁死锁判定原理和具体场景死锁怎么解决"><a class="markdownIt-Anchor" href="#1mysql都有什么锁死锁判定原理和具体场景死锁怎么解决">#</a> <strong>1.mysql 都有什么锁，死锁判定原理和具体场景，死锁怎么解决？</strong></h4><blockquote><p>**MySQL 有三种锁的级别：** 页级、表级、行级。</p><ul><li>** 表级锁：** 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li><li>** 行级锁：** 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li><li>** 页面锁：** 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br><strong>什么情况下会造成死锁？</strong></li></ul><p><strong>什么是死锁？</strong></p><p><strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等竺的进程称为死锁进程。</p><p>表级锁不会产生死锁。所以解决死锁主要还是针对于最常用的 InnoDB。</p><p>** 死锁的关键在于：** 两个 (或以上) 的 Session 加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的 session 加锁有次序。</p><p><strong>死锁的解决办法？</strong></p><p>1. 查出的线程杀死 kill<br>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p><p>2. 设置锁的超时时间<br> Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 innodb_lock_wait_timeout 参数值<br>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout=1000; — 设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p>3. 指定获取锁的顺序</p></blockquote><h4 id="2有哪些锁乐观锁悲观锁select-时怎么加排它锁"><a class="markdownIt-Anchor" href="#2有哪些锁乐观锁悲观锁select-时怎么加排它锁">#</a> <strong>2. 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？</strong></h4><blockquote><p><strong>悲观锁（Pessimistic Lock）:</strong></p><p>** 悲观锁特点:** 先获取锁，再进行业务操作。</p><p>即 “悲观” 的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的 **“一锁二查三更新” 即指的是使用悲观锁。** 通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的 select … for update 操作来实现悲观锁。当数据库执行 select for update 时会获取被 select 中的数据行的行锁，因此其他并发执行的 select for update 如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update 获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>补充：</strong><br>不同的数据库对 select for update 的实现和支持都是有所区别的，</p><ul><li>oracle 支持 select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL 就没有 no wait 这个选项。</li><li>MySQL 还有个问题是 select for update 语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在 MySQL 中用悲观锁务必要确定走了索引，而不是全表扫描。</li></ul><p><strong>乐观锁（Optimistic Lock）:</strong></p><p>**1.** 乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p>**2.**** 乐观锁的特点先进行业务操作，不到万不得已不去拿锁。** 即 “乐观” 的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p><strong>3.<strong> 一般的做法是</strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p><p><strong>实现方式举例如下：</strong></p><p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p><ol><li>SELECT data AS old_data, version AS old_version FROM …;</li><li>根据获取的数据进行业务操作，得到 new_data 和 new_version</li><li>UPDATE SET data = new_data, version = new_version WHERE version = old_version</li></ol><p>if (updated row &gt; 0) {</p><p>// 乐观锁获取成功，操作完成</p><p>} else {</p><p>// 乐观锁获取失败，回滚并重试</p><p>}</p><p><strong>注意：</strong></p><ul><li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li><li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li></ul><p><strong>总结：</strong><br>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在 select … for update 前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><ul><li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’</li><li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li><li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li></ul></blockquote><h2 id="七-其他"><a class="markdownIt-Anchor" href="#七-其他">#</a> 七、其他</h2><h4 id="1数据库的主从复制"><a class="markdownIt-Anchor" href="#1数据库的主从复制">#</a> <strong>1. 数据库的主从复制</strong></h4><blockquote><p><strong>主从复制的几种方式:</strong></p><p><strong>同步复制:</strong></p><p>所谓的同步复制，意思是 master 的变化，必须等待 slave-1,slave-2,…,slave-n 完成后才能返回。 这样，显然不可取，也不是 MySQL 复制的默认设置。比如，在 WEB 前端页面上，用户增加了条记录，需要等待很长时间。</p><p><strong>异步复制:</strong></p><p>如同 AJAX 请求一样。master 只需要完成自己的数据库操作即可。至于 slaves 是否收到二进制日志，是否完成操作，不用关心，MySQL 的默认设置。</p><p><strong>半同步复制:</strong></p><p>master 只保证 slaves 中的一个操作成功，就返回，其他 slave 不管。 这个功能，是由 google 为 MySQL 引入的。</p></blockquote><h4 id="2数据库主从复制分析的-7-个问题"><a class="markdownIt-Anchor" href="#2数据库主从复制分析的-7-个问题">#</a> <strong>2. 数据库主从复制分析的 7 个问题？</strong></h4><p>** 问题 1：**master 的写操作，slaves 被动的进行一样的操作，保持数据一致性，那么 slave 是否可以主动的进行写操作？</p><blockquote><p>假设 slave 可以主动的进行写操作，slave 又无法通知 master，这样就导致了 master 和 slave 数据不一致了。因此 slave 不应该进行写操作，至少是 slave 上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p></blockquote><p>** 问题 2：** 主从复制中，可以有 N 个 slave, 可是这些 slave 又不能进行写操作，要他们干嘛？</p><blockquote><p><strong>实现数据备份:</strong><br> 类似于高可用的功能，一旦 master 挂了，可以让 slave 顶上去，同时 slave 提升为 master。</p><p>** 异地容灾:** 比如 master 在北京，地震挂了，那么在上海的 slave 还可以继续。<br>主要用于实现 scale out, 分担负载，可以将读的任务分散到 slaves 上。<br>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向 master，读操作发向 slaves 进行操作】</p></blockquote><p>** 问题 3：** 主从复制中有 master,slave1,slave2,… 等等这么多 MySQL 数据库，那比如一个 JAVA WEB 应用到底应该连接哪个数据库？</p><blockquote><p>我们在应用程序中可以这样，insert/delete/update 这些更新数据库的操作，用 connection (for master) 进行操作，</p><p>select 用 connection (for slaves) 进行操作。那我们的应用程序还要完成怎么从 slaves 选择一个来执行 select，例如使用简单的轮循算法。</p><p>这样的话，相当于应用程序完成了 SQL 语句的路由，而且与 MySQL 的主从复制架构非常关联，一旦 master 挂了，某些 slave 挂了，那么应用程序就要修改了。能不能让应用程序与 MySQL 的主从复制架构没有什么太多关系呢？<br>找一个组件，application program 只需要与它打交道，用它来完成 MySQL 的代理，实现 SQL 语句的路由。<br>MySQL proxy 并不负责，怎么从众多的 slaves 挑一个？可以交给另一个组件 (比如 haproxy) 来完成。</p><p>这就是所谓的 MySQL READ WRITE SPLITE，MySQL 的读写分离。</p></blockquote><p>** 问题 4：** 如果 MySQL proxy , direct , master 他们中的某些挂了怎么办？</p><blockquote><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p></blockquote><p>** 问题 5：** 当 master 的二进制日志每产生一个事件，都需要发往 slave，如果我们有 N 个 slave, 那是发 N 次，还是只发一次？如果只发一次，发给了 slave-1，那 slave-2,slave-3,… 它们怎么办？</p><blockquote><p>显 然，应该发 N 次。实际上，在 MySQL master 内部，维护 N 个线程，每一个线程负责将二进制日志文件发往对应的 slave。master 既要负责写操作，还的维护 N 个线程，负担会很重。可以这样，slave-1 是 master 的从，slave-1 又是 slave-2,slave-3,… 的主，同时 slave-1 不再负责 select。 slave-1 将 master 的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p></blockquote><p>** 问题 6：** 当一个 select 发往 MySQL proxy，可能这次由 slave-2 响应，下次由 slave-3 响应，这样的话，就无法利用查询缓存了。</p><blockquote><p>应该找一个共享式的缓存，比如 memcache 来解决。将 slave-2,slave-3,… 这些查询的结果都缓存至 mamcache 中。</p></blockquote><p>** 问题 7：** 随着应用的日益增长，读操作很多，我们可以扩展 slave，但是如果 master 满足不了写操作了，怎么办呢？</p><blockquote><p>scale on ? 更好的服务器？ 没有最好的，只有更好的，太贵了。。。<br>scale out ? 主从复制架构已经满足不了。<br>可以分库【垂直拆分】，分表【水平拆分】。</p></blockquote><h4 id="3mysql-高并发环境解决方案"><a class="markdownIt-Anchor" href="#3mysql-高并发环境解决方案">#</a> <strong>3.mysql 高并发环境解决方案？</strong></h4><blockquote><p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。</p><p>** 需求分析：** 互联网单位 每天大量数据读取，写入，并发性高。</p><p>** 现有解决方式：** 水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p><p>** 集群方案：** 解决 DB 宕机带来的单点 DB 不能访问问题。</p><p>** 读写分离策略：** 极大限度提高了应用中 Read 数据的速度和并发量。无法解决高写入压力。</p></blockquote><h4 id="4数据库崩溃时事务的恢复机制redo日志和undo日志"><a class="markdownIt-Anchor" href="#4数据库崩溃时事务的恢复机制redo日志和undo日志">#</a> <strong>4. 数据库崩溃时事务的恢复机制（REDO 日志和 UNDO 日志）?</strong></h4><p>转载：<a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html">MySQL REDO 日志和 UNDO 日志</a></p><blockquote><p><strong>Undo Log:</strong></p><p>Undo Log 是为了实现事务的原子性，在 MySQL 数据库 InnoDB 存储引擎中，还用了 Undo Log 来实现多版本并发控制 (简称：MVCC)。</p><p>事务的原子性 (Atomicity) 事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚 (Rollback) 到事务开始前的状态，就像这个事务从来没有执行过。<br>原理 Undo Log 的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了 ROLLBACK 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。</p><p>之所以能同时保证原子性和持久化，是因为以下<strong>特点：</strong></p><p>更新数据前记录 Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log 必须先于数据持久化到磁盘。如果在 G,H 之间系统崩溃，undo log 是完整的， 可以用来回滚事务。<br>如果在 A-F 之间系统崩溃，因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p><p>** 缺陷：** 每个事务提交前将数据和 Undo Log 写入磁盘，这样会导致大量的磁盘 IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少 IO 提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即 Redo Log。</p><p><strong>Redo Log:</strong></p><p>原理和 Undo Log 相反，Redo Log 记录的是新数据的备份。在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql问题</title>
      <link href="/2021/09/05/mysql%E9%A2%98%E7%9B%AE/"/>
      <url>/2021/09/05/mysql%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="事务特性"><a class="markdownIt-Anchor" href="#事务特性">#</a> 事务特性</h2><p>事务特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><ul><li>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。</li><li>一致性是指一个事务执行之前和执行之后都必须处于一致性状态。比如 a 与 b 账户共有 1000 块，两人之间转账之后无论成功还是失败，它们的账户总和还是 1000。</li><li>隔离性。跟隔离级别相关，如 read committed，一个事务只能读到已经提交的修改。</li><li>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h2 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别">#</a> 事务隔离级别</h2><p>先了解下几个概念：脏读、不可重复读、幻读。</p><ul><li>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li><li>不可重复读是指在对于数据库中的某行记录，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。</li><li>幻读是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样，这就是发生了幻读。</li></ul><p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。<br>幻读和不可重复读都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。</p><p>MySQL 数据库为我们提供的四种隔离级别：</p><ul><li>Serializable (串行化)：通过强制事务<a href="">排序</a>，使之不可能相互冲突，从而解决幻读问题。</li><li>Repeatable read (可重复读)：MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。</li><li>Read committed (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。</li><li>Read uncommitted (读未提交)：所有事务都可以看到其他未提交事务的执行结果。</li></ul><p>查看隔离级别：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`select` `@@transaction_isolation;`</span><br></pre></td></tr></table></figure><p>设置隔离级别：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`set` `session ``transaction` `isolation` `level` `read` `uncommitted``;`</span><br></pre></td></tr></table></figure><h2 id="索引"><a class="markdownIt-Anchor" href="#索引">#</a> 索引</h2><p>索引是存储引擎用于提高数据库表的访问速度的一种数据结构。</p><p>特点：1、避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页；提升查询语句的执行效率，但降低了新增、删除操作的速度，同时也会占用额外的存储空间。</p><h3 id="索引的作用"><a class="markdownIt-Anchor" href="#索引的作用">#</a> 索引的作用</h3><p>数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为 B + 树的高度一般在 2-4 层，最多只需要读取 2-4 次磁盘，查询速度大大提升。</p><p>什么情况下需要建索引：</p><ol><li>经常用于查询的字段</li><li>经常用于连接的字段（如外键）建立索引，可以加快连接的速度</li><li>经常需要<a href="">排序</a>的字段建立索引，因为索引已经排好序，可以加快<a href="">排序</a>查询速度</li></ol><p>什么情况下不建索引？</p><ol><li>where 条件中用不到的字段不适合建立索引</li><li>表记录较少</li><li>需要经常增删改</li><li>参与列计算的列不适合建索引</li><li>区分度不高的字段不适合建立索引，性别等</li></ol><h3 id="b-树"><a class="markdownIt-Anchor" href="#b-树">#</a> B+ 树</h3><p>B+ 树是基于 B 树和叶子节点顺序访问指针进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ 树中，节点中的 key 从左到右递增排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917423/image-20210821165019147.png" alt="img"></p><p>进行查找操作时，首先在根节点进行<a href="">二分查找</a>，找到 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行<a href="">二分查找</a>，找出 key 所对应的数据项。</p><p>MySQL 数据库使用最多的索引类型是 BTREE 索引，底层基于 B + 树数据结构来实现。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`mysql&gt; show ``index` `from` `blog\G;``*************************** 1. row ***************************``        ``Table``: blog``   ``Non_unique: 0``     ``Key_name: ``PRIMARY`` ``Seq_in_index: 1``  ``Column_name: blog_id``    ``Collation: A``  ``Cardinality: 4``     ``Sub_part: ``NULL``       ``Packed: ``NULL``         ``Null``:``   ``Index_type: BTREE``      ``Comment:``Index_comment:``      ``Visible: YES``   ``Expression: ``NULL`</span><br></pre></td></tr></table></figure><h3 id="索引实例"><a class="markdownIt-Anchor" href="#索引实例">#</a> 索引实例</h3><p>下面来看看一个索引的例子：</p><p>如下图，col1 是主键，col2 和 col3 是普通字段。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917471/image-20200520234137916.png" alt="img"></p><p>下图是主键索引对应的 B + 树结构，每个节点对应磁盘的一页。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917461/image-20200520234200868.png" alt="img"></p><p>对 col3 建立一个单列索引，对应的 B + 树结构：</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917509/image-20200520234231001.png" alt="img"></p><h3 id="索引分类"><a class="markdownIt-Anchor" href="#索引分类">#</a> 索引分类</h3><ol><li><p>主键索引：名为 primary 的唯一非空索引，不允许有空值。</p></li><li><p>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</p><p>唯一索引和主键索引的区别是：UNIQUE 约束的列可以为 null 且可以存在多个 null 值。UNIQUE KEY 的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。</p><p>创建唯一索引：</p><p><a href="#">复制代码</a></p><p><code>ALTER</code>   <code>TABLE</code>   <code>table_name``ADD</code>   <code>CONSTRAINT</code>   <code>constraint_name ``UNIQUE</code>   <code>KEY``(column_1,column_2,...);</code></p></li><li><p>组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀原则。</p></li><li><p>全文索引：全文索引，只有在 MyISAM 引擎上才能使用，只能在 CHAR,VARCHAR,TEXT 类型字段上使用全文索引。</p></li></ol><h3 id="最左匹配"><a class="markdownIt-Anchor" href="#最左匹配">#</a> 最左匹配</h3><p>如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询 (&gt;、&lt;、between、like) 就会停止匹配，后面的字段不会用到索引。</p><p>对 (a,b,c) 建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。</p><p>对 (a,b,c,d) 建立索引，查询条件为 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> ，那么，a,b,c 三个字段能用到索引，而 d 就匹配不到。因为遇到了范围查询！</p><p>对 (a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当 a 相等时，会对 b 进行比较<a href="">排序</a>）。直接执行 <code>b = 2</code>  这种查询条件没有办法利用索引。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917475/image-20210821103313578.png" alt="最左匹配"></p><p>从局部来看，当 a 的值确定的时候，b 是有序的。例如 a = 1 时，b 值为 1，2 是有序的状态。当 a=2 时候，b 的值为 1,4 也是有序状态。 因此，你执行 <code>a = 1 and b = 2</code>  是 a,b 字段能用到索引的。而你执行 <code>a &gt; 1 and b = 2</code>  时，a 字段能用到索引，b 字段用不到索引。因为 a 的值此时是一个范围，不是固定的，在这个范围内 b 值不是有序的，因此 b 字段用不上索引。</p><h3 id="聚集索引"><a class="markdownIt-Anchor" href="#聚集索引">#</a> 聚集索引</h3><p>InnoDB 使用表的主键构造主键索引树，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用双向<a href="">链表</a>连接，叶子节点按照主键的顺序<a href="">排序</a>，因此对于主键的<a href="">排序</a>查找和范围查找速度比较快。</p><p>聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917550/mysql-clustered-index.png" alt="img"></p><p>对于 InnoDB 来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引。如果没有主键也没有合适的唯一索引，那么 innodb 内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为 6 个字节，它的值会随着数据的插入自增。</p><h3 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引">#</a> 覆盖索引</h3><p>select 的数据列只用从索引中就能够取得，不需要到数据表进行二次查询，换句话说查询列要被所使用的索引覆盖。对于 innodb 表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</p><p>不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以 MySQL 只能使用 b + 树索引做覆盖索引。</p><p>对于使用了覆盖索引的查询，在查询前面使用 explain，输出的 extra 列会显示为 using index。</p><p>比如 user_like 用户点赞表，组合索引为 (user_id, blog_id)，user_id 和 blog_id 都不为 null。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`explain ``select` `blog_id ``from` `user_like ``where` `user_id = 13;`</span><br></pre></td></tr></table></figure><p>Extra 中为 <code>Using index</code> ，查询的列被索引覆盖，并且 where 筛选条件符合最左前缀原则，通过<strong>索引查找</strong>就能直接找到符合条件的数据，不需要回表查询数据。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`explain ``select` `user_id ``from` `user_like ``where` `blog_id = 1;`</span><br></pre></td></tr></table></figure><p>Extra 中为 <code>Using where; Using index</code> ， 查询的列被索引覆盖，where 筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过<strong>索引扫描</strong>找到符合条件的数据，也不需要回表查询数据。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917790/cover-index.png" alt="img"></p><h3 id="索引失效"><a class="markdownIt-Anchor" href="#索引失效">#</a> 索引失效</h3><p>导致索引失效的情况：</p><ul><li>对于组合索引，不是使用组合索引最左边的字段，则不会使用索引</li><li>以 % 开头的 like 查询如 <code>%abc</code> ，无法使用索引；非 % 开头的 like 查询如 <code>abc%</code> ，相当于范围查询，会使用索引</li><li>查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效</li><li>判断索引列是否不等于某个值时</li><li>对索引列进行运算</li><li>使用 or 连接的条件，如果左边的字段有索引，右边的字段没有索引，那么左边的索引会失效</li></ul><p>对于 Java 选手来说，基础知识非常重要，这里给大家分享一个超全面的 Java 知识总结，<strong>GitHub 标星 137k</strong>+，非常有用！</p><p><img src="https://uploadfiles.nowcoder.com/files/20210827/8683776_1630025317873/v2-cdfb49d3d6562191415ae9771055807a.jpg" alt="img"></p><p>有需要的小伙伴可以自行下载：</p><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg2OTY1NzY0MQ==&amp;mid=100000392&amp;idx=1&amp;sn=f6c8e84651ce48f6ef5b0d496f0f6adf&amp;chksm=4e98ffce79ef76d8dcebdc4787ae8b37760ec193574da9036e46954ae8954ebd56c78792726f#rd">Java 知识总结，GitHub 标星 137k+</a></p><h2 id="存储引擎"><a class="markdownIt-Anchor" href="#存储引擎">#</a> 存储引擎</h2><p>MySQL 5.5 版本后默认的存储引擎为 InnoDB。</p><h3 id="innodb"><a class="markdownIt-Anchor" href="#innodb">#</a> InnoDB</h3><p>InnoDB 是 MySQL 默认的事务型存储引擎，使用最广泛，基于聚簇索引建立的。InnoDB 内部做了很多优化，如能够自动在内存中创建自适应 hash 索引，以加速读操作。</p><p><strong>优点</strong>：支持事务和崩溃修复能力。InnoDB 引入了行级锁和外键约束。</p><p><strong>缺点</strong>：占用的数据空间相对较大。</p><p><strong>适用场景</strong>：需要事务支持，并且有较高的并发读写频率。</p><h3 id="myisam"><a class="markdownIt-Anchor" href="#myisam">#</a> MyISAM</h3><p>数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用 MyISAM 引擎。MyISAM 会将表存储在两个文件中，数据文件.MYD 和索引文件.MYI。</p><p><strong>优点</strong>：访问速度快。</p><p><strong>缺点</strong>：MyISAM 不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</p><p><strong>适用场景</strong>：对事务完整性没有要求；只读的数据，或者表比较小，可以忍受修复 repair 操作。</p><p>MyISAM 特性：</p><ol><li>MyISAM 对整张表加锁，而不是针对行。读取数据时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在读取表记录的同时，可以往表中插入新的记录（并法插入）。</li><li>对于 MyISAM 表，MySQL 可以手动或者自动执行检查和修复操作。执行表的修复可能会导致数据丢失，而且修复操作非常慢。可以通过 <code>CHECK TABLE tablename</code>  检查表的错误，如果有错误执行 <code>REPAIR TABLE tablename</code>  进行修复。</li></ol><h3 id="memory"><a class="markdownIt-Anchor" href="#memory">#</a> MEMORY</h3><p>MEMORY 引擎将数据全部放在内存中，访问速度较快，但是一旦系统奔溃的话，数据都会丢失。</p><p>MEMORY 引擎默认使用哈希索引，将键的哈希值和指向数据行的指针保存在哈希索引中。哈希索引使用拉链法来处理哈希冲突。</p><p><strong>优点</strong>：访问速度较快。</p><p><strong>缺点</strong>：</p><ol><li>哈希索引数据不是按照索引值顺序存储，无法用于<a href="">排序</a>。</li><li>不支持部分索引匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。</li><li>只支持等值比较，不支持范围查询。</li><li>当出现哈希冲突时，存储引擎需要遍历<a href="">链表</a>中所有的行指针，逐行进行比较，直到找到符合条件的行。</li></ol><h3 id="myisam和innodb区别"><a class="markdownIt-Anchor" href="#myisam和innodb区别">#</a> MyISAM 和 InnoDB 区别</h3><ol><li><p><strong>是否支持行级锁</strong> : MyISAM 只有表级锁，而 InnoDB 支持行级锁和表级锁，默认为行级锁。</p></li><li><p><strong>是否支持事务和崩溃后的安全恢复</strong>： MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 类型更快，但是不提供事务支持。但是 InnoDB 提供事务支持，具有事务、回滚和崩溃修复能力。</p></li><li><p><strong>是否支持外键：</strong> MyISAM 不支持，而 InnoDB 支持。</p></li><li><p><strong>是否支持 MVCC</strong> ：仅 InnoDB 支持。应对高并发事务，MVCC 比单纯的加锁更高效；MVCC 只在  <code>READ COMMITTED</code>  和  <code>REPEATABLE READ</code>  两个隔离级别下工作；MVCC 可以使用乐观锁和悲观锁来实现；各数据库中 MVCC 实现并不统一。</p></li><li><p>MyISAM 不支持聚集索引，InnoDB 支持聚集索引。</p><p>myisam 引擎主键索引和其他索引区别不大，叶子节点都包含索引值和行指针。<br>innodb 引擎二级索引叶子存储的是索引值和主键值（不是行指针），这样可以减少行移动和数据页分裂时二级索引的维护工作。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917803/myisam-innodb-index.png" alt="myisam-innodb-index"></p></li></ol><h2 id="mvcc"><a class="markdownIt-Anchor" href="#mvcc">#</a> MVCC</h2><p>MVCC( <code>Multiversion concurrency control</code> ) 就是同一份数据保留多版本的一种方式，进而实现并发控制。可以认为 MVCC 是行级锁的变种。在查询的时候，通过 read view 和版本链找到对应版本的数据。</p><p>MVCC 只适用于 read committed 和 repeatable read。使用事务更新行记录时，会生成一个新的版本的行记录。</p><p>作用：提升并发性能。对于高并发场景，MVCC 比行级锁更有效、开销更小。</p><h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理">#</a> 实现原理</h3><p>mvcc 实现依赖于版本链，版本链是通过表的三个隐藏字段实现。</p><ul><li>事务 id：data_trx_id，当前事务 id</li><li>回滚指针：data_roll_ptr，指向当前行记录的上一个版本，通过这个指针将数据的多个版本连接在一起构成 undo log 版本链</li><li>主键：db_row_id，如果数据表没有主键，InnoDB 会自动生成主键</li></ul><p>使用事务更新行记录的时候，就会生成版本链：</p><ol><li>用排他锁锁住该行；</li><li>将该行原本的值拷贝到 undo log，作为旧版本用于回滚；</li><li>修改当前行的值，生成一个新版本，更新事务 id，使回滚指针指向旧版本的记录，这样就形成一条版本链；</li><li>记录 redo log；</li></ol><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917857/mvcc-impl.png" alt="img"></p><h3 id="read-view"><a class="markdownIt-Anchor" href="#read-view">#</a> read view</h3><p>read view 就是在某一时刻给事务打 snapshot 快照。在 read_view 内部维护一个活跃事务<a href="">链表</a>，这个<a href="">链表</a>包含在创建 read view 之前还未提交的事务，不包含创建 read view 之后提交的事务。</p><p>不同隔离级别创建 read view 的时机不同。</p><p>read committed：每次执行 select 都会创建新的 read_view，保证能读取到其他事务已经提交的修改。</p><p>repeatable read：在一个事务范围内，第一次 select 时更新这个 read_view，以后不会再更新，后续所有的 select 都是复用之前的 read_view。这样可以保证事务范围内每次读取的内容都一样，即可重复读。</p><h3 id="数据访问流程"><a class="markdownIt-Anchor" href="#数据访问流程">#</a> 数据访问流程</h3><p>当访问数据行时，会先判断当前版本数据项是否可见，如果是不可见的，会通过版本链找到一个可见的版本。</p><ul><li>如果数据行的当前版本 &lt; read view 最早的活跃事务 id：说明在创建 read_view 时，修改该数据行的事务已提交，该版本的数据行可被当前事务读取到。</li><li>如果数据行的当前版本 &gt;= read view 最晚的活跃事务 id：说明当前版本的数据行的事务是在创建 read_view 之后生成的，该版本的数据行不可以被当前事务访问。此时需要通过版本链找到上一个版本，然后重新判断该版本数据对当前事务的可见性。</li><li>如果数据行的当前版本在最早的活跃事务 id 和最晚的活跃事务 id 之间：<ol><li>需要在活跃事务<a href="">链表</a>中查找是否包含该数据行的最新事务 id，即生成当前版本数据行的事务是否已经提交。</li><li>如果存在，说明生成当前版本数据行的事务未提交，所以该版本的数据行不能被当前事务访问。此时需要通过版本链找到上一个版本，然后重新判断该版本的可见性。</li><li>如果不存在，说明事务已经提交，可以直接读取该数据行。</li></ol></li></ul><p><strong>总结</strong>：通过比较 read view 和数据行的当前版本，找到当前事务可见的版本，进而实现 read commit 和 repeatable read 的事务隔离级别。</p><h3 id="快照读和当前读"><a class="markdownIt-Anchor" href="#快照读和当前读">#</a> 快照读和当前读</h3><p>记录的两种读取方式。</p><p>快照读：读取的是快照版本，也就是历史版本。普通的 SELECT 就是快照读。通过 MVCC 来进行控制的，不用加锁。</p><p>当前读：读取的是最新版本。UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE 是当前读。</p><p>快照读情况下，InnoDB 通过 mvcc 机制避免了幻读现象。而 mvcc 机制无法避免当前读情况下出现的幻读现象。</p><p>事务 a 和事务 b 同时开启事务，事务 a 插入数据然后提交，事务 b 执行全表的 update，然后执行查询，查到了事务 A 中添加的数据。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917795/%E5%B9%BB%E8%AF%BB1.png" alt="img"></p><p>MySQL 如何实现避免幻读:</p><ul><li>在快照读情况下，MySQL 通过 mvcc 来避免幻读。</li><li>在当前读情况下，MySQL 通过 next-key 来避免幻读（加行锁和间隙锁来实现的）。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905917832/current-read.png" alt="img"></p><p>next-key 包括两部分：行锁和间隙锁。行锁是加在索引上的锁，间隙锁是加在索引之间的。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`select` `* ``from` `table` `where` `id&lt;6 lock ``in` `share mode;``--共享锁 锁定的是小于6的行和等于6的行``select` `* ``from` `table` `where` `id&lt;6 ``for` `update``;``--排他锁`</span><br></pre></td></tr></table></figure><p>实际上很多的<a href="">项目</a>中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。</p><p>Serializable 隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般很少使用。</p><h3 id="select-读取锁定"><a class="markdownIt-Anchor" href="#select-读取锁定">#</a> select 读取锁定</h3><p>在 SELECT 的读取锁定主要分为两种方式：共享锁和排他锁。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`SELECT` `... LOCK ``IN` `SHARE MODE　``SELECT` `... ``FOR` `UPDATE`</span><br></pre></td></tr></table></figure><p>这两种方式主要的不同在于 LOCK IN SHARE MODE 多个事务同时更新同一个表单时很容易造成死锁。这种情况最好使用 SELECT …FOR UPDATE。</p><p><code>select * from goods where id = 1 for update</code> ：申请排他锁的前提是，没有线程对该结果集的任何行数据使用排它锁或者共享锁，否则申请会受到阻塞。在进行事务操作时，MySQL 会对查询结果集的每行数据添加排它锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被 commit 语句或 rollback 语句结束为止。</p><p>select… for update 使用注意事项</p><ol><li>for update 仅适用于 Innodb，且必须在事务范围内才能生效。</li><li>根据主键进行查询，查询条件为 like 或者不等于，主键字段产生表锁。</li><li>根据非索引字段进行查询，name 字段产生表锁。</li></ol><h2 id="分库分表"><a class="markdownIt-Anchor" href="#分库分表">#</a> 分库分表</h2><p>当单表的数据量达到 1000W 或 100G 以后，优化索引、添加从库等可能对数据库性能提升效果不明显，此时就要考虑对其进行切分了。切分的目的就在于减少数据库的负担，缩短查询的时间。</p><p>数据切分可以分为两种方式：垂直（纵向）划分和水平（横向）划分。</p><h3 id="垂直划分"><a class="markdownIt-Anchor" href="#垂直划分">#</a> 垂直划分</h3><p>垂直划分数据库是根据业务进行划分，例如将 shop 库中涉及商品、订单、用户的表分别划分出成一个库，通过降低单库的大小来提高性能，但这种方式并没有解决高数据量带来的性能损耗。同样的，分表的情况就是将一个大表根据业务功能拆分成一个个子表，例如商品基本信息和商品描述，商品基本信息一般会展示在商品列表，商品描述在商品详情页，可以将商品基本信息和商品描述拆分成两张表。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905918017/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="垂直划分"></p><p>优点：行记录变小，数据页可以存放更多记录，在查询时减少 I/O 次数。</p><p>缺点：</p><ul><li>主键出现冗余，需要管理冗余列；</li><li>会引起表连接 JOIN 操作，可以通过在业务服务器上进行 join 来减少数据库压力；</li><li>依然存在单表数据量过大的问题。</li></ul><h3 id="水平划分"><a class="markdownIt-Anchor" href="#水平划分">#</a> 水平划分</h3><p>水平划分是根据一定规则，例如时间或 id 序列值等进行数据的拆分。比如根据年份来拆分不同的数据库。每个数据库结构一致，但是数据得以拆分，从而提升性能。</p><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905918231/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="水平划分"></p><p>优点：单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。</p><p>缺点：</p><ul><li>分片事务一致性难以解决</li><li>跨节点 Join 性能差，逻辑复杂</li><li>数据分片在扩容时需要迁移</li></ul><h2 id="日志"><a class="markdownIt-Anchor" href="#日志">#</a> 日志</h2><p>MySQL 日志 主要包括查询日志、慢查询日志、事务日志、错误日志、二进制日志等。其中比较重要的是二进制日志 binlog 和事务日志 redo log（重做日志）和 undo log（回滚日志）。</p><h3 id="bin-log"><a class="markdownIt-Anchor" href="#bin-log">#</a> bin log</h3><p>二进制日志（bin log）是 MySQL 数据库级别的文件，记录对 MySQL 数据库执行修改的所有操作，不会记录 select 和 show 语句，主要用于恢复数据库和同步数据库。</p><p>查看 bin log 是否开启，以及保存位置：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`MySQL&gt; show variables ``like` `&#x27;%log_bin%&#x27;``;``+``---------------------------------+----------------------------------------------------+``| Variable_name                   | Value                                              |``+``---------------------------------+----------------------------------------------------+``| log_bin                         | ``ON`                                                 `|``| log_bin_basename                | F:\java\MySQL8\data\Data\DESKTOP-8F30VS1-bin       |``| log_bin_index                   | F:\java\MySQL8\data\Data\DESKTOP-8F30VS1-bin.``index` `|``| log_bin_trust_function_creators | ``OFF`                                                `|``| log_bin_use_v1_row_events       | ``OFF`                                                `|``| sql_log_bin                     | ``ON`                                                 `|``+``---------------------------------+----------------------------------------------------+`</span><br></pre></td></tr></table></figure><p>关闭 bin log，找到 /etc/my.cnf 文件，注释以下代码：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`log-bin=MySQL-bin``binlog_format=mixed`</span><br></pre></td></tr></table></figure><h3 id="redo-log"><a class="markdownIt-Anchor" href="#redo-log">#</a> redo log</h3><p>重做日志（redo log）是 Innodb 引擎级别，用来记录 Innodb 存储引擎的事务日志，不管事务是否提交都会记录下来，用于数据恢复。当数据库发生故障，InnoDB 存储引擎会使用 redo log 恢复到发生故障前的时刻，以此来保证数据的完整性。将参数 innodb_flush_log_at_tx_commit 设置为 1，那么在执行 commit 时将 redo log 同步写到磁盘。</p><p>bin log 和 redo log 区别：</p><ol><li>bin log 会记录所有日志记录，包括 innoDB、MyISAM 等存储引擎的日志；redo log 只记录 innoDB 自身的事务日志</li><li>bin log 只在事务提交前写入到磁盘，一个事务只写一次，无论事务多大；而在事务进行过程，会有 redo log 不断写入磁盘</li><li>binlog 是逻辑日志，记录的是 SQL 语句的原始逻辑；redo log 是物理日志，记录的是在某个数据页上做了什么修改。</li></ol><h3 id="undo-log"><a class="markdownIt-Anchor" href="#undo-log">#</a> undo Log</h3><p>除了记录 redo log 外，当进行数据修改时还会记录 undo log，undo log 用于数据的撤回操作，它保留了记录修改前的内容。通过 undo log 可以实现事务回滚，并且可以根据 undo log 回溯到某个特定的版本的数据，实现 MVCC。</p><h3 id="查询日志"><a class="markdownIt-Anchor" href="#查询日志">#</a> 查询日志</h3><p>记录所有对 MySQL 请求的信息，无论请求是否正确执行。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`MySQL&gt; show variables ``like` `&#x27;%general_log%&#x27;``;``+``------------------+----------------------------------+``| Variable_name    | Value                            |``+``------------------+----------------------------------+``| general_log      | ``OFF`                              `|``| general_log_file | /var/lib/MySQL/VM_0_7_centos.log |``+``------------------+----------------------------------+`</span><br></pre></td></tr></table></figure><h2 id="mysql架构"><a class="markdownIt-Anchor" href="#mysql架构">#</a> MySQL 架构</h2><p>MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li><li><strong>存储引擎</strong>： 主要负责数据的存储和读取。server 层通过 api 与存储引擎进行通信。</li></ul><p><img src="https://uploadfiles.nowcoder.com/files/20210825/8683776_1629905918396/mysql-archpng.png" alt="MySQL-archpng"></p><h3 id="server-层基本组件"><a class="markdownIt-Anchor" href="#server-层基本组件">#</a> Server 层基本组件</h3><ul><li><strong>连接器：</strong> 当<a href="">客户端</a>连接 MySQL 时，server 层会对其进行身份认证和权限校验。</li><li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除），先校验这个 sql 是否执行过，如果缓存 key （sql 语句）被命中，就会直接返回给<a href="">客户端</a>，如果没有命中，就会执行后续的操作。MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，不推荐使用。</li><li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。</li><li><strong>执行器：</strong> 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。</li></ul><h4 id="语法解析器和预处理"><a class="markdownIt-Anchor" href="#语法解析器和预处理">#</a> 语法解析器和预处理</h4><p>MySQL 通过关键字将 SQL 语句进行解析，生成解析树。</p><p>MySQL 解析器使用 MySQL 语法规则验证和解析查询，比如验证是否使用正确的关键字、关键字的次序是否正确和验证引号是否前后正确匹配。</p><p>预处理器会进一步检查解析树是否合法，如检查数据表和数据列是否存在，然后验证权限。</p><h4 id="查询优化器"><a class="markdownIt-Anchor" href="#查询优化器">#</a> 查询优化器</h4><p>优化器会找出一个它认为最优的执行计划。</p><p>MySQL 能够处理的优化类型：</p><ol><li>重新定义表的关联顺序。数据表的关联并不是总按照查询中指定的顺序进行的。</li><li>使用等价变换，简化表达式。比如将  <code>5=5 AND a &gt; 5</code>  转化为  <code>a &gt; 5</code> 。</li><li>优化 COUNT/MIN/MAX。MIN 查询最小值，对应的是 b + 树索引的第一行记录，优化器会将这个表达式作为一个常数对待。</li><li>列表 IN () 的比较。很多数据库系统，IN 完成等价于多个 OR 子句。MySQL 不一样，MySQL 将 IN 列表的数据先进行<a href="">排序</a>，然后通过<a href="">二分查找</a>的方式确定列表的值是否符合要求，时间复杂度为 O (logN)，而 OR 查询的时间复杂度为 O (N)。当 IN 列表有大量取值时，处理速度相比 OR 查询会更快。</li><li>覆盖索引扫描。</li><li>将外连接转化成内连接。某些情况下，外连接可能等价于一个内连接。</li></ol><h4 id="查询执行引擎"><a class="markdownIt-Anchor" href="#查询执行引擎">#</a> 查询执行引擎</h4><p>在解析和优化阶段，MySQL 将生成查询对应的执行计划，MySQL 的查询执行引擎则根据这个执行计划，调用存储引擎接口来完成整个查询。</p><h3 id="查询语句执行流程"><a class="markdownIt-Anchor" href="#查询语句执行流程">#</a> 查询语句执行流程</h3><p>查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。</p><p>查询语句：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`select` `* ``from` `user` `where` `id &gt; 1 ``and` `name` `= ``&#x27;大彬&#x27;``;`</span><br></pre></td></tr></table></figure><ol><li>检查权限，没有权限则返回错误；</li><li>MySQL 以前会查询缓存，缓存命中则直接返回，没有则执行下一步；</li><li>词法分析和语法分析。提取表名、查询条件，检查语法是否有错误；</li><li>两种执行方案，先查  <code>id &gt; 1</code>  还是  <code>name = '大彬'</code> ，优化器根据自己的优化<a href="">算法</a>选择执行效率最好的方案；</li><li>校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。</li></ol><h3 id="更新语句执行过程"><a class="markdownIt-Anchor" href="#更新语句执行过程">#</a> 更新语句执行过程</h3><p>更新语句执行流程如下：分析器、权限校验、执行器、引擎、redo log (prepare 状态)、binlog、redo log (commit 状态)</p><p>更新语句：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`update` `user` `set` `name` `= ``&#x27;大彬&#x27;` `where` `id = 1;`</span><br></pre></td></tr></table></figure><ol><li>先查询到 id 为 1 的记录，有缓存会使用缓存</li><li>拿到查询结果，将 name 更新为 大彬，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ol><p>为什么记录完 redo log，不直接提交，先进入 prepare 状态？</p><p>假设先写 redo log 直接提交，然后写 binlog，写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p><p>假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p><h2 id="慢查询"><a class="markdownIt-Anchor" href="#慢查询">#</a> 慢查询</h2><p>sql 语句查询时间超过（不包括等于） long_query_time，称为慢查询。</p><p>查看慢查询配置：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`show variables  ``like` `&#x27;%slow_query_log%&#x27;``; #查看慢查询配置``set` `global` `slow_query_log=1; #开启慢查询`</span><br></pre></td></tr></table></figure><p>使用 <code>set global slow_query_log=1</code>  开启了慢查询日志只对当前数据库生效，如果 MySQL 重启后则会失效。如果要永久生效，就必须修改配置文件 my.cnf。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`slow_query_log =``1``slow_query_log_file=/tmp/MySQL_slow.log #系统默认会给一个缺省的文件host_name-slow.log`</span><br></pre></td></tr></table></figure><p>默认情况下 long_query_time 的值为 10 秒，可以使用命令修改，也可以在 my.cnf 参数里面修改。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`show variables ``like` `&#x27;long_query_time%&#x27;``;``set` `global` `long_query_time=4; #需要重新连接或新开一个会话才能看到修改值或者使用show ``global` `variables ``like` `&#x27;long_query_time&#x27;`</span><br></pre></td></tr></table></figure><p>MySQL 数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=‘FILE,TABLE’。</p><p>日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。</p><h3 id="mysqldumpslow"><a class="markdownIt-Anchor" href="#mysqldumpslow">#</a> mysqldumpslow</h3><p>如果自己手动查找、分析 SQL，显然是个体力活，MySQL 提供了日志分析工具 mysqldumpslow。</p><p>获取执行时间最长的 10 条 sql 语句：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`mysqldumpslow -s al -n 10 /usr/``local``/MySQL/data/slow.log`</span><br></pre></td></tr></table></figure><h2 id="分区表"><a class="markdownIt-Anchor" href="#分区表">#</a> 分区表</h2><p>分区表是一个独立的逻辑表，但是底层由多个物理子表组成。</p><p>当查询条件的数据分布在某一个分区的时候，查询引擎只会去某一个分区查询，而不是遍历整个表。在管理层面，如果需要删除某一个分区的数据，只需要删除对应的分区即可。</p><h3 id="分区表类型"><a class="markdownIt-Anchor" href="#分区表类型">#</a> 分区表类型</h3><ol><li><p>按照范围分区。</p><p><a href="#">复制代码</a></p><p><code>CREATE</code>   <code>TABLE</code>   <code>test_range_partition(``    ``id ``INT</code>   <code>auto_increment,``    ``createdate DATETIME,``    ``primary</code>   <code>key</code>   <code>(id,createdate)``) ``PARTITION ``BY</code>   <code>RANGE (TO_DAYS(createdate) ) (``   ``PARTITION p201801 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210201'``) ),``   ``PARTITION p201802 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210301'``) ),``   ``PARTITION p201803 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210401'``) ),``   ``PARTITION p201804 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210501'``) ),``   ``PARTITION p201805 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210601'``) ),``   ``PARTITION p201806 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210701'``) ),``   ``PARTITION p201807 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210801'``) ),``   ``PARTITION p201808 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20210901'``) ),``   ``PARTITION p201809 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20211001'``) ),``   ``PARTITION p201810 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20211101'``) ),``   ``PARTITION p201811 ``VALUES</code>   <code>LESS THAN ( TO_DAYS(``'20211201'``) )``);</code>   <code>insert</code>   <code>into</code>   <code>test_range_partition (createdate) ``values</code>   <code>(``'20210105'``);``insert</code>   <code>into</code>   <code>test_range_partition (createdate) ``values</code>   <code>(``'20210205'``);</code></p><p>在 <code>/var/lib/mysql/data/</code>  可以找到对应的数据文件，每个分区表都有一个使用 #分隔命名的表文件：</p><p><a href="#">复制代码</a></p><p><code>-rw-rw---- ``1</code>   <code>mysql mysql    ``65</code>   <code>Aug ``21</code>   <code>09``:``24</code>   <code>db.opt``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201801.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201802.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201803.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201804.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201805.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201806.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201807.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201808.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201809.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201810.ibd``-rw-rw---- ``1</code>   <code>mysql mysql ``98304</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition#P#p201811.ibd``-rw-rw---- ``1</code>   <code>mysql mysql  ``8598</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition.frm``-rw-rw---- ``1</code>   <code>mysql mysql   ``116</code>   <code>Aug ``21</code>   <code>09``:``27</code>   <code>test_range_partition.par</code></p></li><li><p>list 分区。对于 List 分区，分区字段必须是已知的，如果插入的字段不在分区时枚举值中，将无法插入。</p><p><a href="#">复制代码</a></p><p><code>create</code>   <code>table</code>   <code>test_list_partiotion``(``    ``id ``int</code>   <code>auto_increment,``    ``data_type tinyint,``    ``primary</code>   <code>key``(id,data_type)``)partition ``by</code>   <code>list(data_type)``(``    ``partition p0 ``values</code>   <code>in</code>   <code>(0,1,2,3,4,5,6),``    ``partition p1 ``values</code>   <code>in</code>   <code>(7,8,9,10,11,12),``    ``partition p2 ``values</code>   <code>in</code>   <code>(13,14,15,16,17)``);</code></p></li><li><p>hash 分区，可以将数据均匀地分布到预先定义的分区中。</p><p><a href="#">复制代码</a></p><p><code>drop</code>   <code>table</code>   <code>test_hash_partiotion;``create</code>   <code>table</code>   <code>test_hash_partiotion``(``    ``id ``int</code>   <code>auto_increment,``    ``create_date datetime,``    ``primary</code>   <code>key``(id,create_date)``)partition ``by</code>   <code>hash(``year``(create_date)) partitions 10;</code></p></li></ol><h3 id="分区的问题"><a class="markdownIt-Anchor" href="#分区的问题">#</a> 分区的问题</h3><ol><li>打开和锁住所有底层表的成本可能很高。当查询访问分区表时，MySQL 需要打开并锁住所有的底层表，这个操作在分区过滤之前发生，所以无法通过分区过滤来降低此开销，会影响到查询速度。可以通过批量操作来降低此类开销，比如批量插入、LOAD DATA INFILE 和一次删除多行数据。</li><li>维护分区的成本可能很高。例如重组分区，会先创建一个临时分区，然后将数据复制到其中，最后再删除原分区。</li><li>所有分区必须使用相同的存储引擎。</li></ol><h3 id="查询优化"><a class="markdownIt-Anchor" href="#查询优化">#</a> 查询优化</h3><p>分区最大的优点就是优化器可以根据分区函数过滤掉一些分区，可以让查询扫描更少的数据。在查询条件中加入分区列，就可以让优化器过滤掉无需访问的分区。如果查询条件没有分区列，MySQL 会让存储引擎访问这个表的所有分区。需要注意的是，查询条件中的分区列不能使用表达式。</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他">#</a> 其他</h2><h3 id="processlist"><a class="markdownIt-Anchor" href="#processlist">#</a> processlist</h3><p><code>select *</code>  会查询出不需要的、额外的数据，那么这些额外的数据在网络上进行传输，带来了额外的网络开销。</p><p><code>show processlist</code>  或  <code>show full processlist</code>  可以查看当前 MySQL 是否有压力，正在运行的 sql，有没有慢 SQL 正在执行。</p><ul><li><p><strong>id</strong> - 线程 ID，可以用： <code>kill id;</code>  杀死一个线程，很有用</p></li><li><p><strong>db</strong> - 数据库</p></li><li><p><strong>user</strong> - 用户</p></li><li><p><strong>host</strong> - 连库的主机 IP</p></li><li><p><strong>command</strong> - 当前执行的命令，比如最常见的：Sleep，Query，Connect 等</p></li><li><p><strong>time</strong> - 消耗时间，单位秒，很有用</p></li><li><p><strong>state</strong> - 执行状态</p><p>sleep，线程正在等待<a href="">客户端</a>发送新的请求</p><p>query，线程正在查询或者正在将结果发送到<a href="">客户端</a></p><p>Sorting result，线程正在对结果集进行<a href="">排序</a></p><p>Locked，线程正在等待锁</p></li><li><p><strong>info</strong> - 执行的 SQL 语句，很有用</p></li></ul><h3 id="exist和in"><a class="markdownIt-Anchor" href="#exist和in">#</a> exist 和 in</h3><p>exists 用于对外表记录做筛选。</p><p>exists 会遍历外表，将外查询表的每一行，代入内查询进行判断。当 exists 里的条件语句能够返回记录行时，条件就为真，返回外表当前记录。反之如果 exists 里的条件语句不能返回记录行，条件为假，则外表当前记录被丢弃。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`select` `a.* ``from` `A a``where` `exists(``select` `1 ``from` `B b ``where` `a.id=b.id)`</span><br></pre></td></tr></table></figure><p>in 是先把后边的语句查出来放到临时表中，然后遍历临时表，将临时表的每一行，代入外查询去查找。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`select` `* ``from` `A``where` `id ``in``(``select` `id ``from` `B)`</span><br></pre></td></tr></table></figure><p>子查询的表大的时候，使用 EXISTS 可以有效减少总的循环次数来提升速度；当外查询的表大的时候，使用 IN 可以有效减少对外查询表循环遍历来提升速度。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合问题</title>
      <link href="/2021/09/05/%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/"/>
      <url>/2021/09/05/%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="arraylist和linkedlist有什么区别"><a class="markdownIt-Anchor" href="#arraylist和linkedlist有什么区别">#</a> ArrayList 和 LinkedList 有什么区别？</h2><p>首先，他们的底层数据结构不同，ArrayList 底层是基于数组实现的，LinkedList 底层是基于链表实现的<br>由于底层数据结构不同，他们所适用的场景也不同，ArrayList 更适合随机查找，LinkedList 更适合删除和添加，查询、添加、删除的时间复杂度不同<br>另外 ArrayList 和 LinkedList 都实现了 List 接口，但是 LinkedList 还额外实现了 Deque 接口，所以 LinkedList 还可以当做队列来使用。</p><h2 id="arraylist的sublist修改是否影响list本身"><a class="markdownIt-Anchor" href="#arraylist的sublist修改是否影响list本身">#</a> ArrayList 的 sublist 修改是否影响 list 本身？</h2><p>方法实现</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// fromIndex: 集合开始的索引，toIndex:集合结束的索引，左开右闭</span><br><span class="line">public List&lt;E&gt; subList(int fromIndex， int toIndex) &#123;</span><br><span class="line">// 边界校验</span><br><span class="line">subListRangeCheck(fromIndex， toIndex， size);</span><br><span class="line">// subList 返回是一个视图</span><br><span class="line">return new SubList(this， 0， fromIndex， toIndex);</span><br><span class="line">&#125;</span><br><span class="line">// ArrayList 的内部类，这个类中单独定义了 set、get、size、add、remove 等方法</span><br><span class="line">private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123;</span><br><span class="line">private final AbstractList&lt;E&gt; parent; // parent的具体实现类是 ArrayList</span><br><span class="line">private final int parentOffset;</span><br><span class="line">private final int offset;</span><br><span class="line">int size;</span><br><span class="line">SubList(AbstractList&lt;E&gt; parent，int offset， int fromIndex， int toIndex) &#123;</span><br><span class="line">this.parent = parent;</span><br><span class="line">this.parentOffset = fromIndex;</span><br><span class="line">this.offset = offset + fromIndex;</span><br><span class="line">this.size = toIndex - fromIndex;</span><br><span class="line">this.modCount = ArrayList.this.modCount;</span><br><span class="line">&#125;</span><br><span class="line">public E set(int index, E e) &#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          E oldValue = ArrayList.this.elementData(offset + index);</span><br><span class="line">          ArrayList.this.elementData[offset + index] = e;</span><br><span class="line">          return oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      public E get(int index) &#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          return ArrayList.this.elementData(offset + index);</span><br><span class="line">      &#125;</span><br><span class="line">      public int size() &#123;</span><br><span class="line">          checkForComodification();</span><br><span class="line">          return this.size;</span><br><span class="line">      &#125;</span><br><span class="line">      public void add(int index, E e) &#123;</span><br><span class="line">          rangeCheckForAdd(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">// 添加直接调用父类的添加元素的方法</span><br><span class="line">          parent.add(parentOffset + index, e);</span><br><span class="line">// subList 添加的元素后，会同步父集合的modCount 修改到 subList的modCount，</span><br><span class="line">          this.modCount = parent.modCount;</span><br><span class="line">          this.size++;</span><br><span class="line">      &#125;</span><br><span class="line">      public E remove(int index) &#123;</span><br><span class="line">          rangeCheck(index);</span><br><span class="line">          checkForComodification();</span><br><span class="line">          E result = parent.remove(parentOffset + index);</span><br><span class="line">          this.modCount = parent.modCount;</span><br><span class="line">          this.size--;</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">private void checkForComodification() &#123;</span><br><span class="line">          if (ArrayList.this.modCount != this.modCount)</span><br><span class="line">              throw new ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>ubList 可以做集合的任何操作</p></li><li><p>调用该方法后的生成的新的集合的操作都会对原集合有影响，在 subList 集合后面添加元素，添加的第一个元素的位置就是上述 toIndex 的值，而原始集合中 toIndex 的元素往后移动。其 add 方法调用过程：</p><p><code>add(element) --&gt; AbstractList.add(e) --&gt; SubList.add(index， e) --&gt; parent.add(index + parentOffset， e) --&gt; ArrayList.add(newIndex， e)</code></p></li><li><p>List 的 subList 方法并没有创建一个新的 List，而是使用了 原 List 的视图，这个视图使用内部类 SubList 表示；不能把 subList 方法返回的 List 强制转换成 ArrayList 等类，因为他 们之间没有继承关系；</p></li></ul><p>视图和原 List 的修改还需要注意几点，尤其是他们之间的相互影响：</p><ul><li>对 父 (sourceList) 子 (subList) List 做 的 非 结 构 性 修 改 (non-structural changes)，都会影响到彼此；</li><li>对 <code>子List</code>  做结构性修改，操作同样会反映到 <code>父List</code>  上；子 List 的 add 是直接调用父集合的 add 方法来添加的元素的：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void add(int index, E e) &#123;</span><br><span class="line">rangeCheckForAdd(index);</span><br><span class="line">checkForComodification();</span><br><span class="line">parent.add(parentOffset + index, e);</span><br><span class="line">this.modCount = parent.modCount;</span><br><span class="line">this.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>父List</code>  做结构性修改（增加、删除），均会导致 <code>子List</code>  的遍历、增加、删除抛出异常 ConcurrentModificationException；因为其迭代的时候会对比 <code>父List的modCount</code>  和 <code>子集合的modCount</code> ：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void checkForComodification() &#123;</span><br><span class="line">// ArrayList.this.modCount 表示父List的 modCount，this.modCount表示 子List的modCount</span><br><span class="line">if (ArrayList.this.modCount != this.modCount)</span><br><span class="line">throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronizedlist-vector有什么区别"><a class="markdownIt-Anchor" href="#synchronizedlist-vector有什么区别">#</a> SynchronizedList、Vector 有什么区别？</h2><ul><li>SynchronizedList 是 java.util.Collections 的静态内部类；Vector 是 java.util 包中的一个类；</li><li>使用 add 方法时，扩容机制不一样；</li><li>SynchronizedList 有很好的扩展和兼容功能，可以将所有的 List 的子类转成线程安全的类；</li><li>使用 SynchronizedList 的时候，进行遍历时需要手动进行同步处理；</li><li>SynchronizedList 可以指定锁的对象</li></ul><h2 id="arraysaslisttargs获得的list特点"><a class="markdownIt-Anchor" href="#arraysaslisttargs获得的list特点">#</a> Arrays.asList (T…args) 获得的 List 特点？</h2><ul><li>其返回的 List 是 Arrays 的一个内部类，是原来数组的视图，不支持增删操作；</li><li>如果需要对其进行操作的话，可以通过 ArrayList 的构造器将其转为 ArrayList；</li></ul><h2 id="iterator和listiterator区别"><a class="markdownIt-Anchor" href="#iterator和listiterator区别">#</a> Iterator 和 ListIterator 区别？</h2><ul><li>都是用于遍历集合的，Iterator 可以用于遍历 Set、List；ListIterator 只可用于 List；</li><li>ListIterator 实现的 Iterator 接口；</li><li>ListIterator 可向前和向后遍历；Iterator 只可向后遍历；</li></ul><h2 id="arraylist是怎么扩容的"><a class="markdownIt-Anchor" href="#arraylist是怎么扩容的">#</a> ArrayList 是怎么扩容的？</h2><p>ArrayList 内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList 不会进行缩容；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        int oldCapacity = elementData.length;</span><br><span class="line">        // 新容量为旧容量的1.5倍</span><br><span class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">        // 如果新容量发现比需要的容量还小，则以需要的容量为准</span><br><span class="line">        if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        // 如果新容量已经超过最大容量了，则使用最大容量</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        // 以新容量拷贝出来一个新数组</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="arraylist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#arraylist插入-删除-查询元素的时间复杂度各是多少">#</a> ArrayList 插入、删除、查询元素的时间复杂度各是多少？</h2><p>ArrayList 支持随机访问，通过索引访问元素极快，时间复杂度为 O (1)；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public E get(int index) &#123;</span><br><span class="line">        // 检查是否越界</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        // 返回数组index位置的元素</span><br><span class="line">        return elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果根据比较对象的话时间复杂度就是 O (n)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (elementData[i]==null)</span><br><span class="line">                    return i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int i = 0; i &lt; size; i++)</span><br><span class="line">                if (o.equals(elementData[i]))</span><br><span class="line">                    return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 添加元素到尾部极快，平均时间复杂度为 O (1)；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        // 检查是否需要扩容</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        // 把元素插入到最后一位</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为 O (n)；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public void add(int index, E element) &#123;</span><br><span class="line">        // 检查是否越界</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        // 检查是否需要扩容</span><br><span class="line">        ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">        // 将index及其之后的元素往后挪一位，则index位置处就空出来了</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">                         size - index);</span><br><span class="line">        // 将元素插入到index的位置</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        // 大小加</span><br><span class="line">        size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 从尾部删除元素极快，时间复杂度为 O (1)；</p><p>ArrayList 从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为 O (n)；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public boolean remove(Object o) &#123;</span><br><span class="line">        if (o == null) &#123;</span><br><span class="line">            // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                // 如果要删除的元素为null，则以null进行比较，使用==</span><br><span class="line">                if (elementData[index] == null) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br><span class="line">            for (int index = 0; index &lt; size; index++)</span><br><span class="line">                // 如果要删除的元素不为null，则进行比较，使用equals()方法</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line">private void fastRemove(int index) &#123;</span><br><span class="line">        // 少了一个越界的检查</span><br><span class="line">        modCount++;</span><br><span class="line">        // 如果index不是最后一位，则将index之后的元素往前挪一位</span><br><span class="line">        int numMoved = size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        // 将最后一个元素删除，帮助GC</span><br><span class="line">        elementData[--size] = null; // clear to let GC do its work</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怎么求两个集合的并集-交集-差集"><a class="markdownIt-Anchor" href="#怎么求两个集合的并集-交集-差集">#</a> 怎么求两个集合的并集、交集、差集？</h2><p>ArrayList 支持求并集，调用 addAll (Collection&lt;? extends E&gt; c) 方法即可；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        // 将集合c转为数组</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        int numNew = a.length;</span><br><span class="line">        // 检查是否需要扩容</span><br><span class="line">        ensureCapacityInternal(size + numNew);  // Increments modCount</span><br><span class="line">        // 将c中元素全部拷贝到数组的最后</span><br><span class="line">        System.arraycopy(a, 0, elementData, size, numNew);</span><br><span class="line">        // 大小增加c的大小</span><br><span class="line">        size += numNew;</span><br><span class="line">        // 如果c不为空就返回true，否则返回false</span><br><span class="line">        return numNew != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 支持求交集，调用 retainAll (Collection&lt;? extends E&gt; c) 方法即可；<br>ArrayList 支持求单向差集，调用 removeAll (Collection&lt;? extends E&gt; c) 方法即可；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">     * 批量删除元素</span><br><span class="line">     * complement为true表示删除c中不包含的元素</span><br><span class="line">     * complement为false表示删除c中包含的元素</span><br><span class="line">     */</span><br><span class="line">    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;</span><br><span class="line">        final Object[] elementData = this.elementData;</span><br><span class="line">        // 使用读写两个指针同时遍历数组</span><br><span class="line">        // 读指针每次自增1，写指针放入元素的时候才加1</span><br><span class="line">        // 这样不需要额外的空间，只需要在原有的数组上操作就可以了</span><br><span class="line">        int r = 0, w = 0;</span><br><span class="line">        boolean modified = false;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 遍历整个数组，如果c中包含该元素，则把该元素放到写指针的位置（以complement为准）</span><br><span class="line">            for (; r &lt; size; r++)</span><br><span class="line">                if (c.contains(elementData[r]) == complement)</span><br><span class="line">                    elementData[w++] = elementData[r];</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 正常来说r最后是等于size的，除非c.contains()抛出了异常</span><br><span class="line">            if (r != size) &#123;</span><br><span class="line">                System.arraycopy(elementData, r,</span><br><span class="line">                                 elementData, w,</span><br><span class="line">                                 size - r);</span><br><span class="line">                w += size - r;</span><br><span class="line">            &#125;</span><br><span class="line">            /**</span><br><span class="line">             * 原有的:a:1 3 4</span><br><span class="line">             * 比较的:b:1 3 2</span><br><span class="line">             */</span><br><span class="line">            if (w != size) &#123;</span><br><span class="line">                // 将写指针之后的元素置为空，帮助GC</span><br><span class="line">                for (int i = w; i &lt; size; i++)</span><br><span class="line">                    elementData[i] = null;</span><br><span class="line">                modCount += size - w;</span><br><span class="line">                // 新大小等于写指针的位置（因为每写一次写指针就加1，所以新大小正好等于写指针的位置）</span><br><span class="line">                size = w;</span><br><span class="line">                modified = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="arraylist是怎么实现序列化和反序列化的"><a class="markdownIt-Anchor" href="#arraylist是怎么实现序列化和反序列化的">#</a> ArrayList 是怎么实现序列化和反序列化的？</h2><p>序列化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">       throws java.io.IOException&#123;</span><br><span class="line">       // 防止序列化期间被修改</span><br><span class="line">       int expectedModCount = modCount;</span><br><span class="line">       // 写出非transient非static属性（会写出size属性）</span><br><span class="line">       s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">       // 写出元素个数</span><br><span class="line">       s.writeInt(size);</span><br><span class="line"></span><br><span class="line">       // 依次写出元素</span><br><span class="line">       for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">           s.writeObject(elementData[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       // 如果有修改，抛出异常</span><br><span class="line">       if (modCount != expectedModCount) &#123;</span><br><span class="line">           throw new ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>反序列化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">       throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">       // 声明为空数组</span><br><span class="line">       elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">       // 读入非transient非static属性（会读取size属性）</span><br><span class="line">       s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">       // 读入元素个数，没什么用，只是因为写出的时候写了size属性，读的时候也要按顺序来读</span><br><span class="line">       s.readInt(); // ignored</span><br><span class="line"></span><br><span class="line">       if (size &gt; 0) &#123;</span><br><span class="line">           // 计算容量</span><br><span class="line">           ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">           Object[] a = elementData;</span><br><span class="line">           //  // 依次读取元素到数组中</span><br><span class="line">           for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">               a[i] = s.readObject();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>查看 writeObject () 方法可知，先调用 s.defaultWriteObject () 方法，再把 size 写入到流中，再把元素一个一个的写入到流中。</p><p>一般地，只要实现了 Serializable 接口即可自动序列化，writeObject () 和 readObject () 是为了自己控制序列化的方式，这两个方法必须声明为 private，在 java.io.ObjectStreamClass#getPrivateMethod () 方法中通过反射获取到 writeObject () 这个方法。</p><p>在 ArrayList 的 writeObject () 方法中先调用了 s.defaultWriteObject () 方法，这个方法是写入非 static 非 transient 的属性，在 ArrayList 中也就是 size 属性。同样地，在 readObject () 方法中先调用了 s.defaultReadObject () 方法解析出了 size 属性。</p><p>elementData 定义为 transient 的优势，自己根据 size 序列化真实的元素，而不是根据数组的长度序列化元素，减少了空间占用。</p><h2 id="集合的方法toarray有什么问题"><a class="markdownIt-Anchor" href="#集合的方法toarray有什么问题">#</a> 集合的方法 toArray () 有什么问题？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ArrayTest &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           Father[] fathers = new Son[]&#123;&#125;;</span><br><span class="line">           // 打印结果为class [Lcom.coolcoding.code.Son;</span><br><span class="line">           System.out.println(fathers.getClass());</span><br><span class="line">   </span><br><span class="line">           List&lt;String&gt; strList = new MyList();</span><br><span class="line">           // 打印结果为class [Ljava.lang.String;</span><br><span class="line">           System.out.println(strList.toArray().getClass());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   class Father &#123;&#125;</span><br><span class="line">   </span><br><span class="line">   class Son extends Father &#123;&#125;</span><br><span class="line">   </span><br><span class="line">   class MyList extends ArrayList&lt;String&gt; &#123;</span><br><span class="line">       /**</span><br><span class="line">        * 子类重写父类的方法，返回值可以不一样</span><br><span class="line">        * 但这里只能用数组类型，换成Object就不行</span><br><span class="line">        * 应该算是java本身的bug</span><br><span class="line">        */</span><br><span class="line">       @Override</span><br><span class="line">       public String[] toArray() &#123;</span><br><span class="line">           // 为了方便举例直接写死</span><br><span class="line">           return new String[]&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;&#125;;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2 id="什么是fail-fast"><a class="markdownIt-Anchor" href="#什么是fail-fast">#</a> 什么是 fail-fast？</h2><h3 id="定义"><a class="markdownIt-Anchor" href="#定义">#</a> 定义</h3><p>“快速失败” 也就是 fail-fast，它是 Java 集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程 1、线程 2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。</p><h3 id="例子"><a class="markdownIt-Anchor" href="#例子">#</a> 例子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class FailFastTest &#123;</span><br><span class="line">        private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        private static class threadOne extends Thread&#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">                while(iterator.hasNext())&#123;</span><br><span class="line">                    int i = iterator.next();</span><br><span class="line">                    System.out.println(&quot;ThreadOne 遍历:&quot; + i);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(10);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">      </span><br><span class="line">        private static class threadTwo extends Thread&#123;</span><br><span class="line">            public void run()&#123;</span><br><span class="line">                int i = 0 ;</span><br><span class="line">                while(i &lt; 6)&#123;</span><br><span class="line">                    System.out.println(&quot;ThreadTwo run：&quot; + i);</span><br><span class="line">                    if(i == 3)&#123;</span><br><span class="line">                        list.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            for(int i = 0 ; i &lt; 10;i++)&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            new threadOne().start();</span><br><span class="line">            new threadTwo().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817152045.png" alt="image-20210817152038167"></p><p>通过上面的示例和讲解，我初步知道 fail-fast 产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。</p><p>要了解 fail-fast 机制，我们首先要对 ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。</p><p>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出 ConcurrentModificationException 异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以 ArrayList 为例进一步分析 fail-fast 产生的原因。</p><h3 id="fail-fast解决办法"><a class="markdownIt-Anchor" href="#fail-fast解决办法">#</a> fail-fast 解决办法</h3><ul><li><strong>方案一：</strong> 在遍历过程中所有涉及到改变 modCount 值得地方全部加上 synchronized 或者直接使用 Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li><li><strong>方案二：</strong> 使用 CopyOnWriteArrayList 来替换 ArrayList。推荐使用该方案。</li></ul><h2 id="linkedlist是单链表还是双链表实现的"><a class="markdownIt-Anchor" href="#linkedlist是单链表还是双链表实现的">#</a> LinkedList 是单链表还是双链表实现的？</h2><p>LinkedList 是一个以双链表实现的 List；</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817152520.png" alt="image-20210817152520441"></p><h2 id="linkedlist除了作为list还有什么用处"><a class="markdownIt-Anchor" href="#linkedlist除了作为list还有什么用处">#</a> LinkedList 除了作为 List 还有什么用处？</h2><p>LinkedList 还是一个双端队列，具有队列、双端队列、栈的特性；</p><p>看一下它继承了哪些接口</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817152719.png" alt="image-20210817152719416"></p><h2 id="linkedlist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#linkedlist插入-删除-查询元素的时间复杂度各是多少">#</a> LinkedList 插入、删除、查询元素的时间复杂度各是多少？</h2><p>LinkedList 在队列首尾添加、删除元素非常高效，时间复杂度为 O (1)；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 从队列首添加元素</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">        // 从队列首添加元素</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        // 创建新节点，新节点的next是首节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">        // 让新节点作为新的首节点</span><br><span class="line">        first = newNode;</span><br><span class="line">        // 判断是不是第一个添加的元素</span><br><span class="line">        // 如果是就把last也置为新节点</span><br><span class="line">        // 否则把原首节点的prev指针置为新节点</span><br><span class="line">        if (f == null)</span><br><span class="line">            last = newNode;</span><br><span class="line">        else</span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line">// 从队尾添加元素</span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">        // 队列尾节点</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        // 创建新节点，新节点的prev是尾节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">        // 让新节点成为新的尾节点</span><br><span class="line">        last = newNode;</span><br><span class="line">        // 判断是不是第一个添加的元素</span><br><span class="line">        // 如果是就把first也置为新节点</span><br><span class="line">        // 否则把原尾节点的next指针置为新节点</span><br><span class="line">        if (l == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line">JAVA</span><br><span class="line"> // 删除首节点</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">        // 首节点的元素值</span><br><span class="line">        final E element = f.item;</span><br><span class="line">        // 首节点的next指针</span><br><span class="line">        final Node&lt;E&gt; next = f.next;</span><br><span class="line">        // 添加首节点的内容，协助GC</span><br><span class="line">        f.item = null;</span><br><span class="line">        f.next = null; // help GC</span><br><span class="line">        // 把首节点的next作为新的首节点</span><br><span class="line">        first = next;</span><br><span class="line">        // 如果只有一个元素，删除了，把last也置为空</span><br><span class="line">        // 否则把next的前置指针置为空</span><br><span class="line">        if (next == null)</span><br><span class="line">            last = null;</span><br><span class="line">        else</span><br><span class="line">            next.prev = null;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        size--;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return element;</span><br><span class="line">&#125;</span><br><span class="line">// 删除尾节点</span><br><span class="line"> private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">        // 尾节点的元素值</span><br><span class="line">        final E element = l.item;</span><br><span class="line">        // 尾节点的前置指针</span><br><span class="line">        final Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        // 清空尾节点的内容，协助GC</span><br><span class="line">        l.item = null;</span><br><span class="line">        l.prev = null; // help GC</span><br><span class="line">        // 让前置节点成为新的尾节点</span><br><span class="line">        last = prev;</span><br><span class="line">        // 如果只有一个元素，删除了把first置为空</span><br><span class="line">        // 否则把前置节点的next置为空</span><br><span class="line">        if (prev == null)</span><br><span class="line">            first = null;</span><br><span class="line">        else</span><br><span class="line">            prev.next = null;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        size--;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedList 在中间添加、删除元素比较低效，时间复杂度为 O (n)；</p><p>中间添加</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 在节点succ之前添加元素</span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">        // succ是待添加节点的后继节点</span><br><span class="line">        // 找到待添加节点的前置节点</span><br><span class="line">        final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        // 在其前置节点和后继节点之间创建一个新节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        // 修改后继节点的前置指针指向新节点</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        // 判断前置节点是否为空</span><br><span class="line">        // 如果为空，说明是第一个添加的元素，修改first指针</span><br><span class="line">        // 否则修改前置节点的next为新节点</span><br><span class="line">        if (pred == null)</span><br><span class="line">            first = newNode;</span><br><span class="line">        else</span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        // 修改元素个数</span><br><span class="line">        size++;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 寻找index位置的节点</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">        // 因为是双链表</span><br><span class="line">        // 所以根据index是在前半段还是后半段决定从前遍历还是从后遍历</span><br><span class="line">        // 这样index在后半段的时候可以少遍历一半的元素</span><br><span class="line">        if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">            // 如果是在前半段</span><br><span class="line">            // 就从前遍历</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            for (int i = 0; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            return x;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果是在后半段</span><br><span class="line">            // 就从后遍历</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// 在指定index位置处添加元素</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">        // 判断是否越界</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line">        // 如果index是在队列尾节点之后的一个位置</span><br><span class="line">        // 把新节点直接添加到尾节点之后</span><br><span class="line">        // 否则调用linkBefore()方法在中间添加节点</span><br><span class="line">        if (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        else</span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中间删除或者删除指定节点 x</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 删除指定节点x</span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">        // x的元素值</span><br><span class="line">        final E element = x.item;</span><br><span class="line">        // x的前置节点</span><br><span class="line">        final Node&lt;E&gt; next = x.next;</span><br><span class="line">        // x的后置节点</span><br><span class="line">        final Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        // 如果前置节点为空</span><br><span class="line">        // 说明是首节点，让first指向x的后置节点</span><br><span class="line">        // 否则修改前置节点的next为x的后置节点</span><br><span class="line">        if (prev == null) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果后置节点为空</span><br><span class="line">        // 说明是尾节点，让last指向x的前置节点</span><br><span class="line">        // 否则修改后置节点的prev为x的前置节点</span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 清空x的元素值，协助GC</span><br><span class="line">        x.item = null;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        size--;</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        modCount++;</span><br><span class="line">        // 返回删除的元素</span><br><span class="line">        return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// remove的时候如果没有元素抛出异常</span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        if (f == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// remove的时候如果没有元素抛出异常</span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        if (l == null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// poll的时候如果没有元素返回null</span><br><span class="line">public E pollFirst() &#123;</span><br><span class="line">        final Node&lt;E&gt; f = first;</span><br><span class="line">        return (f == null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// poll的时候如果没有元素返回null</span><br><span class="line">public E pollLast() &#123;</span><br><span class="line">        final Node&lt;E&gt; l = last;</span><br><span class="line">        return (l == null) ? null : unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除中间节点</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">        // 检查是否越界</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        // 删除指定index位置的节点</span><br><span class="line">        return unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是随机访问"><a class="markdownIt-Anchor" href="#什么是随机访问">#</a> 什么是随机访问？</h2><p>java 集合类中元素的访问分为随机访问和顺序访问。随机访问一般是通过 index 下标访问，行为类似数组的访问。而顺序访问类似于链表的访问，通常为迭代器遍历。<br>以 List 接口及其实例为例。ArrayList 是典型的随机访问型，而 LinkedList 则是顺序访问型。List 接口既定义了下标访问方法又定义了迭代器方法。所以其实例既可使用下标随机访问也可以使用迭代器进行遍历。但这两种方式的性能差异很明显。</p><p>随机访问是说你可以随意访问该数据结构中的任意一个节点，假设该数据结构有 10 个节点，你可以随意访问第 1 个到第 10 个节点。<br>对于列表而言，如果其存在 10 个节点，如果你要访问第 5 个节点，你只能从列表的头或者尾，依次遍历相邻的每一个节点；</p><h4 id="randomaccess接口"><a class="markdownIt-Anchor" href="#randomaccess接口">#</a> RandomAccess 接口</h4><p>JDK 中的 RandomAccess 接口是一个标记接口，它并未定义方法。其目的是用于指示实现类具有随机访问特性，在遍历时使用下标访问较迭代器更快。如果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">for(int i = 0, n = list.size(); i &lt; n; i++)</span><br><span class="line">    list.get(i);</span><br></pre></td></tr></table></figure><p>的运行比</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">for(Interator i = list.iterator();i.hasNext();)</span><br><span class="line">    i.next();</span><br></pre></td></tr></table></figure><p>快，则应实现 RandomAccess 接口。</p><h2 id="哪些集合支持随机访问他们都有哪些共性"><a class="markdownIt-Anchor" href="#哪些集合支持随机访问他们都有哪些共性">#</a> 哪些集合支持随机访问？他们都有哪些共性？</h2><p>ArrayList、HashMap、TreeMap 和 HashTable 类提供对元素的随机访问。</p><h2 id="copyonwritearraylist是怎么保证并发安全的"><a class="markdownIt-Anchor" href="#copyonwritearraylist是怎么保证并发安全的">#</a> CopyOnWriteArrayList 是怎么保证并发安全的？</h2><p>CopyOnWriteArrayList 使用 ReentrantLock 重入锁加锁，保证线程安全；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/** 用于修改时加锁 */</span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">/** 真正存储元素的地方，只能通过getArray()/setArray()访问 */</span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure><h2 id="copyonwritearraylist的实现采用了什么思想"><a class="markdownIt-Anchor" href="#copyonwritearraylist的实现采用了什么思想">#</a> CopyOnWriteArrayList 的实现采用了什么思想？</h2><p>CopyOnWriteArrayList 采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合；它不存在扩容的概念，每次写操作都要复制一个副本，在副本的基础上修改后改变 Array 引用。CopyOnWriteArrayList 中写操作需要大面积复制数组，所以性能肯定很差。</p><h2 id="copyonwritearraylist是不是强一致性的"><a class="markdownIt-Anchor" href="#copyonwritearraylist是不是强一致性的">#</a> CopyOnWriteArrayList 是不是强一致性的？</h2><p>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的，虽然 CopyOnWriteArrayList 能做到最终一致性，但是还是没法满足实时性一致性要求；</p><h2 id="copyonwritearraylistaddifabsente-e了解吗"><a class="markdownIt-Anchor" href="#copyonwritearraylistaddifabsente-e了解吗">#</a> CopyOnWriteArrayListaddIfAbsent (E e) 了解吗？</h2><p>添加一个元素如果这个元素不存在于集合中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean addIfAbsent(E e) &#123;</span><br><span class="line">        // 获取元素数组, 取名为快照</span><br><span class="line">        Object[] snapshot = getArray();</span><br><span class="line">        // 检查如果元素不存在,直接返回false</span><br><span class="line">        // 如果存在再调用addIfAbsent()方法添加元素</span><br><span class="line">        return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false :</span><br><span class="line">            addIfAbsent(e, snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean addIfAbsent(E e, Object[] snapshot) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 重新获取旧数组</span><br><span class="line">            Object[] current = getArray();</span><br><span class="line">            int len = current.length;</span><br><span class="line">            // 如果快照与刚获取的数组不一致</span><br><span class="line">            // 说明有修改</span><br><span class="line">            if (snapshot != current) &#123;</span><br><span class="line">                // 重新检查元素是否在刚获取的数组里</span><br><span class="line">                int common = Math.min(snapshot.length, len);</span><br><span class="line">                for (int i = 0; i &lt; common; i++)</span><br><span class="line">                    // 到这个方法里面了, 说明元素不在快照里面</span><br><span class="line">                    if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                        return false;</span><br><span class="line">                if (indexOf(e, current, common, len) &gt;= 0)</span><br><span class="line">                        return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 拷贝一份n+1的数组</span><br><span class="line">            Object[] newElements = Arrays.copyOf(current, len + 1);</span><br><span class="line">            // 将元素放在最后一位</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（1）检查这个元素是否存在于数组快照中；</p><p>（2）如果存在直接返回 false，如果不存在调用 addIfAbsent (E e, Object [] snapshot) 处理；</p><p>（3）加锁；</p><p>（4）如果当前数组不等于传入的快照，说明有修改，检查待添加的元素是否存在于当前数组中，如果存在直接返回 false;</p><p>（5）拷贝一个新数组，长度等于原数组长度加 1，并把原数组元素拷贝到新数组中；</p><p>（6）把新元素添加到数组最后一位；</p><p>（7）把新数组赋值给当前对象的 array 属性，覆盖原数组；</p><p>（8）解锁；</p><h2 id="copyonwritearraylist适用于什么样的场景"><a class="markdownIt-Anchor" href="#copyonwritearraylist适用于什么样的场景">#</a> CopyOnWriteArrayList 适用于什么样的场景？</h2><p>CopyOnWriteArrayList 采用读写分离的思想，读操作不加锁，写操作加锁，且写操作占用较大内存空间，所以适用于读多写少的场合，比如缓存；不过这类慎用 ，因为谁也没法保证 CopyOnWriteArrayList 到底要放置多少数据，万一数据稍微有点多，每次 add/set 都要重新复制数组，这个代价实在太高昂了。在高性能的互联网应用中，这种操作分分钟引起故障。</p><h2 id="copyonwritearraylist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#copyonwritearraylist插入-删除-查询元素的时间复杂度各是多少">#</a> CopyOnWriteArrayList 插入、删除、查询元素的时间复杂度各是多少？</h2><p>CopyOnWriteArrayList 的写操作都要先拷贝一份新数组，在新数组中做修改，修改完了再用新数组替换老数组，所以空间复杂度是 O (n)，性能比较低下；</p><p>CopyOnWriteArrayList 的读操作支持随机访问，时间复杂度为 O (1)；</p><p>添加一个元素到末尾。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public boolean add(E e) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取旧数组</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            int len = elements.length;</span><br><span class="line">            // 将旧数组元素拷贝到新数组中</span><br><span class="line">            // 新数组大小是旧数组大小加1</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">            // 将元素放在最后一位</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 释放锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个元素在指定索引处</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line">       // 加锁</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           // 获取旧数组</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           int len = elements.length;</span><br><span class="line">           // 检查是否越界, 可以等于len</span><br><span class="line">           if (index &gt; len || index &lt; 0)</span><br><span class="line">               throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+</span><br><span class="line">                                                   &quot;, Size: &quot;+len);</span><br><span class="line">           Object[] newElements;</span><br><span class="line">           int numMoved = len - index;</span><br><span class="line">           if (numMoved == 0)</span><br><span class="line">               // 如果插入的位置是最后一位</span><br><span class="line">               // 那么拷贝一个n+1的数组, 其前n个元素与旧数组一致</span><br><span class="line">               newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">           else &#123;</span><br><span class="line">               // 如果插入的位置不是最后一位</span><br><span class="line">               // 那么新建一个n+1的数组</span><br><span class="line">               newElements = new Object[len + 1];</span><br><span class="line">               // 拷贝旧数组前index的元素到新数组中</span><br><span class="line">               System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">               // 将index及其之后的元素往后挪一位拷贝到新数组中</span><br><span class="line">               // 这样正好index位置是空出来的</span><br><span class="line">               System.arraycopy(elements, index, newElements, index + 1,</span><br><span class="line">                                numMoved);</span><br><span class="line">           &#125;</span><br><span class="line">           // 将元素放置在index处</span><br><span class="line">           newElements[index] = element;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // 释放锁</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>删除指定索引位置的元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">       final ReentrantLock lock = this.lock;</span><br><span class="line">       // 加锁</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           // 获取旧数组</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           int len = elements.length;</span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line">           int numMoved = len - index - 1;</span><br><span class="line">           if (numMoved == 0)</span><br><span class="line">               // 如果移除的是最后一位</span><br><span class="line">               // 那么直接拷贝一份n-1的新数组, 最后一位就自动删除了</span><br><span class="line">               setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">           else &#123;</span><br><span class="line">               // 如果移除的不是最后一位</span><br><span class="line">               // 那么新建一个n-1的新数组</span><br><span class="line">               Object[] newElements = new Object[len - 1];</span><br><span class="line">               // 将前index的元素拷贝到新数组中</span><br><span class="line">               System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">               // 将index后面(不包含)的元素往前挪一位</span><br><span class="line">               // 这样正好把index位置覆盖掉了, 相当于删除了</span><br><span class="line">               System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">               setArray(newElements);</span><br><span class="line">           &#125;</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           // 释放锁</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>获取指定索引的元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">        // 获取元素不需要加锁</span><br><span class="line">        // 直接返回index位置的元素</span><br><span class="line">        // 这里是没有做越界检查的, 因为数组本身会做越界检查</span><br><span class="line">        return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final Object[] getArray() &#123;</span><br><span class="line">        return array;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">        return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copyonwritearraylist为什么没有size属性"><a class="markdownIt-Anchor" href="#copyonwritearraylist为什么没有size属性">#</a> CopyOnWriteArrayList 为什么没有 size 属性？</h2><p>因为每次修改都是拷贝一份正好可以存储目标个数元素的数组，所以不需要 size 属性了，数组的长度就是集合的大小，而不像 ArrayList 数组的长度实际是要大于集合的大小的。</p><p>比如，add (E e) 操作，先拷贝一份 n+1 个元素的数组，再把新元素放到新数组的最后一位，这时新数组的长度为 len+1 了，也就是集合的 size 了。</p><h2 id="比较古老的集合vector和stack有什么缺陷"><a class="markdownIt-Anchor" href="#比较古老的集合vector和stack有什么缺陷">#</a> 比较古老的集合 Vector 和 Stack 有什么缺陷？</h2><p>Vector：线程安全的动态数组</p><p>Stack：继承 Vector，基于动态数组实现的一个线程安全的栈；</p><p>Vector 与 ArrayList 基本是一致的，不同的是 Vector 是线程安全的，会在可能出现线程安全的方法前面加上 synchronized 关键字；</p><p>Vector：随机访问速度快，插入和移除性能较差 (数组的特点)；支持 null 元素；有顺序；元素可以重复；线程安全；</p><p>Stack：后进先出，实现了一些栈基本操作的方法（其实并不是只能后进先出，因为继承自 Vector，可以有很多操作，从某种意义上来讲，不是一个栈）；</p><p>所以基本上来说 vector 因为线程安全的实现方法比较粗暴效率较低。</p><h2 id="什么是散列表"><a class="markdownIt-Anchor" href="#什么是散列表">#</a> 什么是散列表？</h2><p><a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>（Hash table，也叫哈希表），是根据关键码值 (Key value) 而直接进行访问的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">散列函数</a>，存放记录的<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">数组</a>叫做<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">散列表</a>。</p><p>给定表 M，存在函数 f (key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希 (Hash）表，函数 f (key) 为哈希 (Hash) 函数。</p><p><strong>hash 就是找到一种数据内容和数据存放地址之间的映射关系。</strong></p><h2 id="常见的散列函数"><a class="markdownIt-Anchor" href="#常见的散列函数">#</a> 常见的散列函数？</h2><ul><li>直接定址法：直接以关键字 k 或者 k 加上某个常数 (k+c) 作为哈希地址；</li><li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址；</li><li>除留余数法：用关键字 k 除以某个不大于哈希表长度 m 的数 p，将所得余数作为哈希表地址；</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址；</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求去中间几位作为哈希表地址；</li><li>伪随机数法：采用一个伪随机数作为哈希函数</li></ul><p><a href="https://blog.csdn.net/yyyljw/article/details/80903391">有兴趣的可以访问</a></p><h2 id="碰撞解决方案"><a class="markdownIt-Anchor" href="#碰撞解决方案">#</a> 碰撞解决方案？</h2><p>衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本无法彻底避免碰撞。</p><p>常见解决碰撞的方法有以下几种：</p><ul><li>开发定址法：就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入；</li><li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表尾部；</li><li>再哈希法：当哈希地址发生冲突用其他的函数计算另一个哈希地址，直到冲突不在产生为止；</li><li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li></ul><h2 id="怎么实现一个散列表"><a class="markdownIt-Anchor" href="#怎么实现一个散列表">#</a> 怎么实现一个散列表？</h2><p><a href="https://www.bilibili.com/video/BV1K54y147TB?p=211">推荐小码哥的恋上数据结构与算法</a></p><h2 id="java中hashmap实现方式的演进"><a class="markdownIt-Anchor" href="#java中hashmap实现方式的演进">#</a> java 中 HashMap 实现方式的演进？</h2><p>JDK1.7 中底层是数组 + 链表，JDK1.8 中底层是数组 + 链表 + 红黑树，加红黑树的目的是提高 HashMap 插入和查询整体效率 JDK1.7 中链表插入使用的是头插法，1.8 中链表插入使用的是尾插法，因为 1.8 中插入 key 和 value 时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使用尾插法 JDK1.7 中哈希算法比较复杂，存在各种右移与异或运算，JDK1.8 中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提供 HashMap 的整体效率，而 1.8 中新增了红黑树，所以可以适当的简化哈希算法，节省 CPU 资源。</p><h2 id="hashmap的容量有什么特点"><a class="markdownIt-Anchor" href="#hashmap的容量有什么特点">#</a> HashMap 的容量有什么特点？</h2><p>默认情况下，当我们设置 HashMap 的初始化容量时，实际上 HashMap 会采用第一个大于该数值的 2 的幂作为初始化容量。HashMap 默认容量为 16, 每次超过阀值时，按照两倍大小进行自动扩容，所以容量总是 2^N 次方。并且，底层的  <code>table</code>  数组是延迟初始化，在首次添加 key-value 键值对才进行初始化。在 HashMap 中，哈希桶数组 table 的长度 length 大小必须为 2 的 n 次方 (一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="https://link.zhihu.com/?target=http://blog.csdn.net/liuqiyao_01/article/details/14475159"> http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable 初始化桶大小为 11，就是桶大小设计为素数的应用（Hashtable 扩容后不能保证还是素数）。HashMap 采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap 定位哈希桶索引位置时，也加入了高位参与运算的过程。</p><h2 id="hashmap如何确定哈希桶数组索引位置"><a class="markdownIt-Anchor" href="#hashmap如何确定哈希桶数组索引位置">#</a> HashMap 如何确定哈希桶数组索引位置？</h2><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过 HashMap 的数据结构是数组和链表的结合，所以我们当然希望这个 HashMap 里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用 hash 算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap 定位数组索引位置，直接决定了 hash 方法的离散性能。先看看源码的实现 (方法一 + 方法二):</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">方法一：</span><br><span class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span><br><span class="line">     return h &amp; (length-1);  //第三步 取模运算</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 Hash 算法本质上就是三步：<strong>取 key 的 hashCode 值、高位运算、取模运算</strong>。</p><p>对于任意给定的对象，只要它的 hashCode () 返回值相同，那么程序调用方法一所计算得到的 Hash 码值总是相同的。我们首先想到的就是把 hash 值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在 HashMap 中是这样做的：调用方法二来计算该对象应该保存在 table 数组的哪个索引处。</p><p>这个方法非常巧妙，它通过 h &amp; (table.length -1) 来得到该对象的保存位，而 HashMap 底层数组的长度总是 2 的 n 次方，这是 HashMap 在速度上的优化。当 length 总是 2 的 n 次方时，h&amp; (length-1) 运算等价于对 length 取模，也就是 h% length，但是 &amp; 比 % 具有更高的效率。</p><p>在 JDK1.8 的实现中，优化了高位运算的算法，通过 hashCode () 的高 16 位异或低 16 位实现的：(h = k.hashCode ()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组 table 的 length 比较小的时候，也能保证考虑到高低 Bit 都参与到 Hash 的计算中，同时不会有太大的开销。</p><p>下面举例说明下，n 为 table 的长度。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817164145.png" alt="img"></p><h2 id="hashmap是怎么进行扩容的"><a class="markdownIt-Anchor" href="#hashmap是怎么进行扩容的">#</a> HashMap 是怎么进行扩容的？</h2><p>扩容 (resize) 就是重新计算容量，向 HashMap 对象里不停的添加元素，而 HashMap 对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p><p>我们分析下 resize 的源码，鉴于 JDK1.8 融入了红黑树，较复杂，为了便于理解我们仍然使用 JDK1.7 的代码，好理解一些，本质上区别不大，具体区别后文再说。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">void resize(int newCapacity) &#123;   //传入新的容量</span><br><span class="line">    Entry[] oldTable = table;    //引用扩容前的Entry数组</span><br><span class="line">   int oldCapacity = oldTable.length;         </span><br><span class="line">     if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //扩容前的数组大小如果已经达到最大(2^30)了</span><br><span class="line">        threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组</span><br><span class="line">    transfer(newTable);                         //！！将数据转移到新的Entry数组里</span><br><span class="line">     table = newTable;                           //HashMap的table属性引用新的Entry数组</span><br><span class="line">    threshold = (int)(newCapacity * loadFactor);//修改阈值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer () 方法将原有 Entry 数组的元素拷贝到新的 Entry 数组里。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">    Entry[] src = table;                   //src引用了旧的Entry数组</span><br><span class="line">     int newCapacity = newTable.length;</span><br><span class="line">    for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组</span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素</span><br><span class="line">        if (e != null) &#123;</span><br><span class="line">            src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span><br><span class="line">            do &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置</span><br><span class="line">                 e.next = newTable[i]; //标记[1]</span><br><span class="line">                 newTable[i] = e;      //将元素放在数组上</span><br><span class="line">                 e = next;             //访问下一个Entry链上的元素</span><br><span class="line">             &#125; while (e != null);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newTable [i] 的引用赋给了 e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到 Entry 链的尾部 (如果发生了 hash 冲突的话），这一点和 Jdk1.8 有区别，下文详解。在旧数组中同一条 Entry 链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>下面举个例子说明下扩容过程。假设了我们的 hash 算法就是简单的用 key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组 table 的 size=2， 所以 key = 3、7、5，put 顺序依次为 5、7、3。在 mod 2 以后都冲突在 table [1] 这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小 size 大于 table 的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165435.png" alt="img"></p><p>下面我们讲解下 JDK1.8 做了哪些优化。经过观测可以发现，我们使用的是 2 次幂的扩展 (指长度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。看下图可以明白这句话的意思，n 为 table 的长度，图（a）表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图（b）表示扩容后 key1 和 key2 两种 key 确定索引位置的示例，其中 hash1 是 key1 对应的哈希与高位运算结果。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165518.png" alt="img"></p><p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit (红色)，因此新的 index 就会发生这样的变化：</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165540.png" alt="img"></p><p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成 “原索引 + oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图：</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817165555.png" alt="img"></p><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。有一点注意区别，JDK1.7 中 rehash 的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8 不会倒置。JDK1.8 扩容步骤为:</p><p>（1）如果使用是默认构造方法，则第一次插入元素时初始化为默认值，容量为 16，扩容门槛为 12；</p><p>（2）如果使用的是非默认构造方法，则第一次插入元素时初始化容量等于扩容门槛，扩容门槛在构造方法里等于传入容量向上最近的 2 的 n 次方；</p><p>（3）如果旧容量大于 0，则新容量等于旧容量的 2 倍，但不超过最大容量 2 的 30 次方，新扩容门槛为旧扩容门槛的 2 倍；</p><p>（4）创建一个新容量的桶；</p><p>（5）搬移元素，原链表分化成两个链表，低位链表存储在原来桶的位置，高位链表搬移到原来桶的位置加旧容量的位置；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">final Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       // 旧数组</span><br><span class="line">       Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">       // 旧容量</span><br><span class="line">       int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">       // 旧扩容门槛</span><br><span class="line">       int oldThr = threshold;</span><br><span class="line">       int newCap, newThr = 0;</span><br><span class="line">       if (oldCap &gt; 0) &#123;</span><br><span class="line">           if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               // 如果旧容量达到了最大容量，则不再进行扩容</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               return oldTab;</span><br><span class="line">           &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                   oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               // 如果旧容量的两倍小于最大容量并且旧容量大于默认初始容量（16），则容量扩大为两部，扩容门槛也扩大为两倍</span><br><span class="line">               newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">       &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">           // 使用非默认构造方法创建的map，第一次插入元素会走到这里</span><br><span class="line">           // 如果旧容量为0且旧扩容门槛大于0，则把新容量赋值为旧门槛</span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">           // 调用默认构造方法创建的map，第一次插入元素会走到这里</span><br><span class="line">           // 如果旧容量旧扩容门槛都是0，说明还未初始化过，则初始化容量为默认容量，扩容门槛为默认容量*默认装载因子</span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (int) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       if (newThr == 0) &#123;</span><br><span class="line">           // 如果新扩容门槛为0，则计算为容量*装载因子，但不能超过最大容量</span><br><span class="line">           float ft = (float) newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float) MAXIMUM_CAPACITY ?</span><br><span class="line">                   (int) ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       // 赋值扩容门槛为新门槛</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       // 新建一个新容量的数组</span><br><span class="line">       @SuppressWarnings(&#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="line">       Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) new Node[newCap];</span><br><span class="line">       // 把桶赋值为新数组</span><br><span class="line">       table = newTab;</span><br><span class="line">       // 如果旧数组不为空，则搬移元素</span><br><span class="line">       if (oldTab != null) &#123;</span><br><span class="line">           // 遍历旧数组</span><br><span class="line">           for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K, V&gt; e;</span><br><span class="line">               // 如果桶中第一个元素不为空，赋值给e</span><br><span class="line">               if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                   // 清空旧桶，便于GC回收  </span><br><span class="line">                   oldTab[j] = null;</span><br><span class="line">                   // 如果这个桶中只有一个元素，则计算它在新桶中的位置并把它搬移到新桶中</span><br><span class="line">                   // 因为每次都扩容两倍，所以这里的第一个元素搬移到新桶的时候新桶肯定还没有元素</span><br><span class="line">                   if (e.next == null)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                   else if (e instanceof TreeNode)</span><br><span class="line">                       // 如果第一个元素是树节点，则把这颗树打散成两颗树插入到新桶中去</span><br><span class="line">                       ((TreeNode&lt;K, V&gt;) e).split(this, newTab, j, oldCap);</span><br><span class="line">                   else &#123; // preserve order</span><br><span class="line">                       // 如果这个链表不止一个元素且不是一颗树</span><br><span class="line">                       // 则分化成两个链表插入到新的桶中去</span><br><span class="line">                       // 比如，假如原来容量为4，3、7、11、15这四个元素都在三号桶中</span><br><span class="line">                       // 现在扩容到8，则3和11还是在三号桶，7和15要搬移到七号桶中去</span><br><span class="line">                       // 也就是分化成了两个链表</span><br><span class="line">                       Node&lt;K, V&gt; loHead = null, loTail = null;</span><br><span class="line">                       Node&lt;K, V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                       Node&lt;K, V&gt; next;</span><br><span class="line">                       do &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           // (e.hash &amp; oldCap) == 0的元素放在低位链表中</span><br><span class="line">                           // 比如，3 &amp; 4 == 0</span><br><span class="line">                           if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                               if (loTail == null)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               else</span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               // (e.hash &amp; oldCap) != 0的元素放在高位链表中</span><br><span class="line">                               // 比如，7 &amp; 4 != 0</span><br><span class="line">                               if (hiTail == null)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               else</span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; while ((e = next) != null);</span><br><span class="line">                       // 遍历完成分化成两个链表了</span><br><span class="line">                       // 低位链表在新桶中的位置与旧桶一样（即3和11还在三号桶中）</span><br><span class="line">                       if (loTail != null) &#123;</span><br><span class="line">                           loTail.next = null;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       // 高位链表在新桶中的位置正好是原来的位置加上旧容量（即7和15搬移到七号桶了）</span><br><span class="line">                       if (hiTail != null) &#123;</span><br><span class="line">                           hiTail.next = null;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return newTab;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h2 id="hashmap的put方法"><a class="markdownIt-Anchor" href="#hashmap的put方法">#</a> HashMap 的 put 方法？</h2><p>先说 HashMap 的 Put 方法的大体流程：<br>1 根据 Key 通过哈希算法与与运算得出数组下标<br> 2 如果数组下标位置元素为空，则将 key 和 value 封装为 Entry 对象（JDK1.7 中是 Entry 对象，JDK1.8 中是 Node 对象）并放入该位置<br> 3 如果数组下标位置元素不为空，则要分情况讨论<br> a 如果是 JDK1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成 Entry 对象，并使用头插法添加到当前位置的链表中<br> b 如果是 JDK1.8，则会先判断当前位置上的 Node 的类型，看是红黑树 Node，还是链表 Node<br>ⅰ 如果是红黑树 Node，则将 key 和 value 封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前 key，如果存在则更新 value<br>ⅱ 如果此位置上的 Node 对象是链表节点，则将 key 和 value 封装为一个链表 Node 并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前 key，如果存在则更新 value，当遍历完链表后，将新链表 Node 插入到链表中，插入到链表后，会看当前链表的节点个数，如果大于等于 8，那么则会将该链表转成红黑树<br> ⅲ 将 key 和 value 封装为 Node 插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就扩容，如果不需要就结束 PUT 方法</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817162307.png" alt="HashMap的put方法过程"></p><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        // 调用hash(key)计算出key的hash值</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        // 如果key为null，则hash值为0，否则调用key的hashCode()方法</span><br><span class="line">        // 并让高16位与整个hash异或，这样做是为了使计算出的hash更分散</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        Node&lt;K, V&gt;[] tab;</span><br><span class="line">        Node&lt;K, V&gt; p;</span><br><span class="line">        int n, i;</span><br><span class="line">        // 如果桶的数量为0，则初始化</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            // 调用resize()初始化</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        // (n - 1) &amp; hash 计算元素在哪个桶中</span><br><span class="line">        // 如果这个桶中还没有元素，则把这个元素放在桶中的第一个位置</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            // 新建一个节点放在桶中</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果桶中已经有元素存在了</span><br><span class="line">            Node&lt;K, V&gt; e;</span><br><span class="line">            K k;</span><br><span class="line">            // 如果桶中第一个元素的key与待插入元素的key相同，保存到e中用于后续修改value值</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                // 如果第一个元素是树节点，则调用树节点的putTreeVal插入元素</span><br><span class="line">                e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                // 遍历这个桶对应的链表，binCount用于存储链表中元素的个数</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                    // 如果链表遍历完了都没有找到相同key的元素，说明该key对应的元素不存在，则在链表最后插入一个新节点</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                        // 如果插入新节点后链表长度大于8，则判断是否需要树化，因为第一个元素没有加到binCount中，所以这里-1</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果待插入的key在链表中找到了，则退出循环</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果找到了对应key的元素</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                // 记录下旧值</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                // 判断是否需要替换旧值</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    // 替换旧值为新值</span><br><span class="line">                    e.value = value;</span><br><span class="line">                // 在节点被访问后做点什么事，在LinkedHashMap中用到</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                // 返回旧值</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 到这里了说明没有找到元素</span><br><span class="line">        // 修改次数加1</span><br><span class="line">        ++modCount;</span><br><span class="line">        // 元素数量加1，判断是否需要扩容</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            // 扩容</span><br><span class="line">            resize();</span><br><span class="line">        // 在节点插入后做点什么事，在LinkedHashMap中用到</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        // 没找到元素返回null</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hashmap中的元素是否是有序的"><a class="markdownIt-Anchor" href="#hashmap中的元素是否是有序的">#</a> HashMap 中的元素是否是有序的？</h2><p>HashMap 中的元素是无序的</p><h2 id="hashmap何时进行树化何时进行反树化"><a class="markdownIt-Anchor" href="#hashmap何时进行树化何时进行反树化">#</a> HashMap 何时进行树化？何时进行反树化？</h2><p>如果冲突的节点数已经达到 8 个，看是否需要改变冲突节点的存储结构，treeifyBin 首先判断当前 hashMap 的长度，如果不足 64，只进行 resize，扩容 table，如果达到 64，那么将冲突的存储结构为红黑树。</p><p>当链表的元素大于 8 时进行树化，小于 6 时进行反树化。</p><p><strong>选择 8 作为阀值和加载因子为 0.75 的原因是参考 泊松概率函数 (Poisson distribution)</strong></p><p>在 hashCode 离散性很好的情况下，红黑树用到的概率非常小，因为数据均匀分布在每个桶中，几乎不会有桶中链表长度会达到阈值 (8)。但是在随机 hashCode 下，离散性可能会变差，然而 JDK 又不能阻止用户实现这种不好的 hash 算法，因此就可能导致不均匀的数据分布。<br>事实上，随机 hashCode 算法下所有桶中节点的分布频率遵循如下的泊松分布。在扩容阈值为 0.75 的情况下，（即使因为扩容而方差很大）遵循着参数平均为 0.5 的泊松分布。一个桶中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件。之所以选择 8，是时间和空间的权衡 (trade-off)，是根据概率统计决定的，是非常严谨和科学的。</p><p>通俗点将就是 put 进去的 key 进行计算 hashCode 时 只要选择计算 hash 值的算法足够好 (hash 碰撞率极低)，从而遵循泊松分布，使得桶中挂载的 bin 的数量等于 8 的概率非常小，从而转换为红黑树的概率也小，反之则概率大。</p><p><strong>为什么转化为红黑树的阈值 8 和转化为链表的阈值 6 不一样？</strong></p><p>为了避免频繁来回转化。</p><h2 id="泊松分布与指数分布"><a class="markdownIt-Anchor" href="#泊松分布与指数分布">#</a> 泊松分布与指数分布</h2><h3 id="泊松分布"><a class="markdownIt-Anchor" href="#泊松分布">#</a> 泊松分布</h3><p>Poisson 分布，是一种统计与概率论中常见的离散概率分布，其适合于描述单位时间内随机事件发生的次数的概率分布。</p><p>如某一服务设施在一定时间内受到的服务请求的次数，电话交换机接到呼叫的次数、汽车站台的候客人数、机器出现的故障数、自然灾害发生的次数、DNA 序列的变异数、放射性原子核的衰变数、激光的光子数分布等等；</p><h3 id="指数分布"><a class="markdownIt-Anchor" href="#指数分布">#</a> 指数分布</h3><p>指数分布（Exponential distribution）是一种连续概率分布。指数分配可以用来表示独立随机事件发生的时间间隔，比如旅客进入机场的时间间隔、打进客服中心电话的时间间隔、中文维基百科新条目出现的时间间隔等等；</p><p>与泊松分布相比，其最大的差异就是指数分布是针对连续随机变量定义，即时间这个变量。时间必须是连续的。而泊松分布是针对随机事件发生次数定义的，发生次数是离散的。粗略地可以认为这两个分布之间有一种 “倒数” 的关系</p><h2 id="hashmap是怎么进行缩容的"><a class="markdownIt-Anchor" href="#hashmap是怎么进行缩容的">#</a> HashMap 是怎么进行缩容的？</h2><p>它不会动态地进行缩容，也就是说，你不应该保留一个已经删除过大量 Entry 的 HashMap（如果不打算继续添加元素的话），此时它的 buckets 数组经过多次扩容已经变得非常大了，这会占用非常多的无用内存，这样做的好处是不用多次对数组进行扩容或缩容操作。不过一般也不会出现这种情况，如果遇见了，请毫不犹豫地丢掉它，或者把数据转移到一个新的 HashMap。</p><h2 id="hashmap插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#hashmap插入-删除-查询元素的时间复杂度各是多少">#</a> HashMap 插入、删除、查询元素的时间复杂度各是多少？</h2><p>因为 HashMap 很少出现 hash 冲突了，因为哈希算法足够优秀，那么全是 o（1）</p><p>但是当有链表的时候，那么就是 o（n）的复杂度</p><p>如果转成红黑树 也就是二叉树的一种，那么应该是 o（logN）的平均复杂度</p><h2 id="hashmap中的红黑树实现部分可以用其它数据结构代替吗"><a class="markdownIt-Anchor" href="#hashmap中的红黑树实现部分可以用其它数据结构代替吗">#</a> HashMap 中的红黑树实现部分可以用其它数据结构代替吗？</h2><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构 (这就跟原来使用链表结构一样了，造成很深的问题)，遍历查找会非常慢。</p><p>而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持 “平衡” 是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于 8 的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p><h2 id="linkedhashmap是怎么实现的"><a class="markdownIt-Anchor" href="#linkedhashmap是怎么实现的">#</a> LinkedHashMap 是怎么实现的？</h2><p>LinkedHashMap 内部维护了一个双向链表，能保证元素按插入的顺序访问，也能以访问顺序访问，可以用来实现 LRU 缓存策略。</p><p>LinkedHashMap 可以看成是 LinkedList + HashMap。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817171707.png" alt="202105091520406812.png"></p><h2 id="linkedhashmap是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#linkedhashmap是有序的吗怎么个有序法">#</a> LinkedHashMap 是有序的吗？怎么个有序法？</h2><p>如果 accessOrder 为 false，则可以按插入元素的顺序遍历元素；</p><p>如果 accessOrder 为 true，则可以按访问元素的顺序遍历元素；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">   * 双向链表头节点</span><br><span class="line">   */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">   * 双向链表尾节点</span><br><span class="line">   */</span><br><span class="line">   transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">   </span><br><span class="line">   /**</span><br><span class="line">   * 是否按访问顺序排序</span><br><span class="line">   */</span><br><span class="line">   final boolean accessOrder;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LinkedHashMap 通过重写 HashMap 提供的回调方法，从而实现其对<strong>顺序</strong>的特性的处理。同时，因为 LinkedHashMap 的<strong>顺序</strong>特性，需要重写  <code>#keysToArray(T[] a)</code>  等<strong>遍历</strong>相关的方法。</p><h2 id="linkedhashmap如何实现lru缓存淘汰策略"><a class="markdownIt-Anchor" href="#linkedhashmap如何实现lru缓存淘汰策略">#</a> LinkedHashMap 如何实现 LRU 缓存淘汰策略？</h2><p>首先，我们先来看看 LRU 是个什么鬼。LRU，Least Recently Used，最近最少使用，也就是优先淘汰最近最少使用的元素。</p><p>如果使用 LinkedHashMap，我们把 accessOrder 设置为 true 是不是就差不多能实现这个策略了呢？答案是肯定的。请看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">import java.util.LinkedHashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class LRUTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个只有5个元素的缓存</span><br><span class="line">        LRU&lt;Integer, Integer&gt; lru = new LRU&lt;&gt;(5, 0.75f);</span><br><span class="line">        lru.put(1, 1);</span><br><span class="line">        lru.put(2, 2);</span><br><span class="line">        lru.put(3, 3);</span><br><span class="line">        lru.put(4, 4);</span><br><span class="line">        lru.put(5, 5);</span><br><span class="line">        lru.put(6, 6);</span><br><span class="line">        lru.put(7, 7);</span><br><span class="line"></span><br><span class="line">        System.out.println(lru.get(4));</span><br><span class="line"></span><br><span class="line">        lru.put(6, 666);</span><br><span class="line"></span><br><span class="line">        // 输出: &#123;3=3, 5=5, 7=7, 4=4, 6=666&#125;</span><br><span class="line">        // 可以看到最旧的元素被删除了</span><br><span class="line">        // 且最近访问的4被移到了后面</span><br><span class="line">        System.out.println(lru);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LRU&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 保存缓存的容量</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    public LRU(int capacity, float loadFactor) &#123;</span><br><span class="line">        super(capacity, loadFactor, true);</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写removeEldestEntry()方法设置何时移除旧元素</span><br><span class="line">     * @param eldest</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;</span><br><span class="line">        // 当元素个数大于了缓存的容量, 就移除元素</span><br><span class="line">        return size() &gt; this.capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="weakhashmap使用的数据结构"><a class="markdownIt-Anchor" href="#weakhashmap使用的数据结构">#</a> WeakHashMap 使用的数据结构？</h2><p>WeakHashMap 因为 gc 的时候会把没有强引用的 key 回收掉，所以注定了它里面的元素不会太多，因此也就不需要像 HashMap 那样元素多的时候转化为红黑树来处理了。</p><p>因此，WeakHashMap 的存储结构只有（数组 + 链表）。</p><h2 id="weakhashmap具有什么特性"><a class="markdownIt-Anchor" href="#weakhashmap具有什么特性">#</a> WeakHashMap 具有什么特性？</h2><p>WeakHashMap 是一种弱引用 map，内部的 key 会存储为弱引用，当 jvm gc 的时候，如果这些 key 没有强引用存在的话，会被 gc 回收掉，下一次当我们操作 map 的时候会把对应的 Entry 整个删除掉，基于这种特性，WeakHashMap 特别适用于缓存处理。</p><h2 id="weakhashmap通常用来做什么"><a class="markdownIt-Anchor" href="#weakhashmap通常用来做什么">#</a> WeakHashMap 通常用来做什么？</h2><p>任何事物都有他存在的道理，WeakHashmap 业务场景就是缓存，可以有效的节省内存，缓存丢失也不会出太大问题，可以再次获取。许多开源框架，例如 tomcat 等都使用了 weakHashmap 做为缓存处理。</p><h2 id="weakhashmap使用string作为key是需要注意些什么为什么"><a class="markdownIt-Anchor" href="#weakhashmap使用string作为key是需要注意些什么为什么">#</a> WeakHashMap 使用 String 作为 key 是需要注意些什么？为什么？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.WeakHashMap;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @description:</span><br><span class="line"> * @author: LvXueYang</span><br><span class="line"> * @creat:2021-08-17 09:29</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class WeakHashMapTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = new WeakHashMap&lt;&gt;();</span><br><span class="line">        map.put(new String(&quot;1&quot;), 1);</span><br><span class="line">        map.put(new String(&quot;2&quot;), 2);</span><br><span class="line">        map.put(new String(&quot;3&quot;), 3);</span><br><span class="line"></span><br><span class="line">        // 放入不用new String()声明的字符串</span><br><span class="line">        map.put(&quot;6&quot;, 6);</span><br><span class="line">        String key = null;</span><br><span class="line">        for (String s : map.keySet()) &#123;</span><br><span class="line">            // 这个&quot;3&quot;和new String(&quot;3&quot;)不是一个引用</span><br><span class="line">            if (s.equals(&quot;3&quot;)) &#123;</span><br><span class="line">                key = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        // gc一下</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 放一个new String()声明的字符串</span><br><span class="line">        map.put(new String(&quot;4&quot;), 4);</span><br><span class="line"></span><br><span class="line">        // 输出&#123;4=4, 6=6, 3=3&#125;，gc后放入的值和强引用的key可以打印出来</span><br><span class="line">        System.out.println(map);</span><br><span class="line"></span><br><span class="line">        // key与&quot;3&quot;的引用断裂</span><br><span class="line">        key = null;</span><br><span class="line"></span><br><span class="line">        // gc一下</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        // 输出&#123;6=6&#125;，gc后强引用的key可以打印出来</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="什么是强引用-软引用-弱引用-虚引用"><a class="markdownIt-Anchor" href="#什么是强引用-软引用-弱引用-虚引用">#</a> 什么是强引用、软引用、弱引用、虚引用？</h2><p>（1）强引用</p><p>使用最普遍的引用。如果一个对象具有强引用，它绝对不会被 gc 回收。如果内存空间不足了，gc 宁愿抛出 OutOfMemoryError，也不是会回收具有强引用的对象。</p><p>（2）软引用</p><p>如果一个对象只具有软引用，则内存空间足够时不会回收它，但内存空间不够时就会回收这部分对象。只要这个具有软引用对象没有被回收，程序就可以正常使用。</p><p>（3）弱引用</p><p>如果一个对象只具有弱引用，则不管内存空间够不够，当 gc 扫描到它时就会回收它。</p><p>（4）虚引用</p><p>如果一个对象只具有虚引用，那么它就和没有任何引用一样，任何时候都可能被 gc 回收。</p><p>软（弱、虚）引用必须和一个引用队列（ReferenceQueue）一起使用，当 gc 回收这个软（弱、虚）引用引用的对象时，会把这个软（弱、虚）引用放到这个引用队列中。</p><h2 id="红黑树具有哪些特性"><a class="markdownIt-Anchor" href="#红黑树具有哪些特性">#</a> 红黑树具有哪些特性？</h2><p>红黑树具有以下 5 种性质：</p><p>（1）节点是红色或黑色。</p><p>（2）根节点是黑色。</p><p>（3）每个叶节点（NIL 节点，空节点）是黑色的。</p><p>（4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p>红黑树的时间复杂度为 O (log n)，与树的高度成正比。</p><p>红黑树每次的插入、删除操作都需要做平衡，平衡时有可能会改变根节点的位置，颜色转换，左旋，右旋等</p><h2 id="treemap就有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#treemap就有序的吗怎么个有序法">#</a> TreeMap 就有序的吗？怎么个有序法？</h2><p>TreeMap 中的元素是有序的，按 key 的顺序排列；</p><h2 id="treemap是否需要扩容"><a class="markdownIt-Anchor" href="#treemap是否需要扩容">#</a> TreeMap 是否需要扩容？</h2><p>TreeMap 因为采用树结构，所以无需初始考虑像 HashMap 考虑<strong>容量</strong>问题，也不存在扩容问题。</p><p>,TreeMap 的存储结构只有一颗红黑树</p><h2 id="什么是左旋什么是右旋"><a class="markdownIt-Anchor" href="#什么是左旋什么是右旋">#</a> 什么是左旋？什么是右旋？</h2><p>左旋，就是以某个节点为支点向左旋转。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173626.png" alt="202105091520433963.png"></p><p>整个左旋过程如下：</p><p>（1）将 y 的左节点 设为 x 的右节点，即将 β 设为 x 的右节点；</p><p>（2）将 x 设为 y 的左节点的父节点，即将 β 的父节点 设为 x；</p><p>（3）将 x 的父节点 设为 y 的父节点；</p><p>（4）如果 x 的父节点 为空节点，则将 y 设置为根节点；如果 x 是它父节点的左（右）节点，则将 y 设置为 x 父节点的左（右）节点；</p><p>（5）将 x 设为 y 的左节点；</p><p>（6）将 x 的父节点 设为 y；</p><p>让我们来看看 TreeMap 中的实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">   * 以p为支点进行左旋</span><br><span class="line">   * 假设p为图中的x</span><br><span class="line">   */</span><br><span class="line">  private void rotateLeft(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">      if (p != null) &#123;</span><br><span class="line">          // p的右节点，即y</span><br><span class="line">          Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">  </span><br><span class="line">          // （1）将 y的左节点 设为 x的右节点</span><br><span class="line">          p.right = r.left;</span><br><span class="line">  </span><br><span class="line">          // （2）将 x 设为 y的左节点的父节点（如果y的左节点存在的话）</span><br><span class="line">          if (r.left != null)</span><br><span class="line">              r.left.parent = p;</span><br><span class="line">  </span><br><span class="line">          // （3）将 x的父节点 设为 y的父节点</span><br><span class="line">          r.parent = p.parent;</span><br><span class="line">  </span><br><span class="line">          // （4）...</span><br><span class="line">          if (p.parent == null)</span><br><span class="line">              // 如果 x的父节点 为空，则将y设置为根节点</span><br><span class="line">              root = r;</span><br><span class="line">          else if (p.parent.left == p)</span><br><span class="line">              // 如果x是它父节点的左节点，则将y设置为x父节点的左节点</span><br><span class="line">              p.parent.left = r;</span><br><span class="line">          else</span><br><span class="line">              // 如果x是它父节点的右节点，则将y设置为x父节点的右节点</span><br><span class="line">              p.parent.right = r;</span><br><span class="line">  </span><br><span class="line">          // （5）将 x 设为 y的左节点</span><br><span class="line">          r.left = p;</span><br><span class="line">  </span><br><span class="line">          // （6）将 x的父节点 设为 y</span><br><span class="line">          p.parent = r;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>右旋，就是以某个节点为支点向右旋转。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173656.png" alt="202105091520436904.png"></p><p>整个右旋过程如下：</p><p>（1）将 x 的右节点 设为 y 的左节点，即 将 β 设为 y 的左节点；</p><p>（2）将 y 设为 x 的右节点的父节点，即 将 β 的父节点 设为 y；</p><p>（3）将 y 的父节点 设为 x 的父节点；</p><p>（4）如果 y 的父节点 是 空节点，则将 x 设为根节点；如果 y 是它父节点的左（右）节点，则将 x 设为 y 的父节点的左（右）节点；</p><p>（5）将 y 设为 x 的右节点；</p><p>（6）将 y 的父节点 设为 x；</p><p>让我们来看看 TreeMap 中的实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">    * 以p为支点进行右旋</span><br><span class="line">    * 假设p为图中的y</span><br><span class="line">    */</span><br><span class="line">   private void rotateRight(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">       if (p != null) &#123;</span><br><span class="line">           // p的左节点，即x</span><br><span class="line">           Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">   </span><br><span class="line">           // （1）将 x的右节点 设为 y的左节点</span><br><span class="line">           p.left = l.right;</span><br><span class="line">   </span><br><span class="line">           // （2）将 y 设为 x的右节点的父节点（如果x有右节点的话）</span><br><span class="line">           if (l.right != null) l.right.parent = p;</span><br><span class="line">   </span><br><span class="line">           // （3）将 y的父节点 设为 x的父节点</span><br><span class="line">           l.parent = p.parent;</span><br><span class="line">   </span><br><span class="line">           // （4）...</span><br><span class="line">           if (p.parent == null)</span><br><span class="line">               // 如果 y的父节点 是 空节点，则将x设为根节点</span><br><span class="line">               root = l;</span><br><span class="line">           else if (p.parent.right == p)</span><br><span class="line">               // 如果y是它父节点的右节点，则将x设为y的父节点的右节点</span><br><span class="line">               p.parent.right = l;</span><br><span class="line">           else</span><br><span class="line">               // 如果y是它父节点的左节点，则将x设为y的父节点的左节点</span><br><span class="line">               p.parent.left = l;</span><br><span class="line">   </span><br><span class="line">           // （5）将 y 设为 x的右节点</span><br><span class="line">           l.right = p;</span><br><span class="line">   </span><br><span class="line">           // （6）将 y的父节点 设为 x</span><br><span class="line">           p.parent = l;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="红黑树怎么插入元素"><a class="markdownIt-Anchor" href="#红黑树怎么插入元素">#</a> 红黑树怎么插入元素？</h2><p>插入元素，如果元素在树中存在，则替换 value；如果元素不存在，则插入到对应的位置，再平衡树。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">     Entry&lt;K,V&gt; t = root;</span><br><span class="line">     if (t == null) &#123;</span><br><span class="line">         // 如果没有根节点，直接插入到根节点</span><br><span class="line">         compare(key, key); // type (and possibly null) check</span><br><span class="line">         root = new Entry&lt;&gt;(key, value, null);</span><br><span class="line">         size = 1;</span><br><span class="line">         modCount++;</span><br><span class="line">         return null;</span><br><span class="line">     &#125;</span><br><span class="line">     // key比较的结果</span><br><span class="line">     int cmp;</span><br><span class="line">     // 用来寻找待插入节点的父节点</span><br><span class="line">     Entry&lt;K,V&gt; parent;</span><br><span class="line">     // 根据是否有comparator使用不同的分支</span><br><span class="line">     Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">     if (cpr != null) &#123;</span><br><span class="line">         // 如果使用的是comparator方式，key值可以为null，只要在comparator.compare()中允许即可</span><br><span class="line">         // 从根节点开始遍历寻找</span><br><span class="line">         do &#123;</span><br><span class="line">             parent = t;</span><br><span class="line">             cmp = cpr.compare(key, t.key);</span><br><span class="line">             if (cmp &lt; 0)</span><br><span class="line">                 // 如果小于0从左子树寻找</span><br><span class="line">                 t = t.left;</span><br><span class="line">             else if (cmp &gt; 0)</span><br><span class="line">                 // 如果大于0从右子树寻找</span><br><span class="line">                 t = t.right;</span><br><span class="line">             else</span><br><span class="line">                 // 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span><br><span class="line">                 return t.setValue(value);</span><br><span class="line">         &#125; while (t != null);</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         // 如果使用的是Comparable方式，key不能为null</span><br><span class="line">         if (key == null)</span><br><span class="line">             throw new NullPointerException();</span><br><span class="line">         @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">         Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">         // 从根节点开始遍历寻找</span><br><span class="line">         do &#123;</span><br><span class="line">             parent = t;</span><br><span class="line">             cmp = k.compareTo(t.key);</span><br><span class="line">             if (cmp &lt; 0)</span><br><span class="line">                 // 如果小于0从左子树寻找</span><br><span class="line">                 t = t.left;</span><br><span class="line">             else if (cmp &gt; 0)</span><br><span class="line">                 // 如果大于0从右子树寻找</span><br><span class="line">                 t = t.right;</span><br><span class="line">             else</span><br><span class="line">                 // 如果等于0，说明插入的节点已经存在了，直接更换其value值并返回旧值</span><br><span class="line">                 return t.setValue(value);</span><br><span class="line">         &#125; while (t != null);</span><br><span class="line">     &#125;</span><br><span class="line">     // 如果没找到，那么新建一个节点，并插入到树中</span><br><span class="line">     Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</span><br><span class="line">     if (cmp &lt; 0)</span><br><span class="line">         // 如果小于0插入到左子节点</span><br><span class="line">         parent.left = e;</span><br><span class="line">     else</span><br><span class="line">         // 如果大于0插入到右子节点</span><br><span class="line">         parent.right = e;</span><br><span class="line"> </span><br><span class="line">     // 插入之后的平衡</span><br><span class="line">     fixAfterInsertion(e);</span><br><span class="line">     // 元素个数加1（不需要扩容）</span><br><span class="line">     size++;</span><br><span class="line">     // 修改次数加1</span><br><span class="line">     modCount++;</span><br><span class="line">     // 如果插入了新节点返回空</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="插入再平衡"><a class="markdownIt-Anchor" href="#插入再平衡">#</a> 插入再平衡</h3><p>插入的元素默认都是红色，因为插入红色元素只违背了第 4 条特性，那么我们只要根据这个特性来平衡就容易多了。</p><p>根据不同的情况有以下几种处理方式：</p><ol><li>插入的元素如果是根节点，则直接涂成黑色即可，不用平衡；</li><li>插入的元素的父节点如果为黑色，不需要平衡；</li><li>插入的元素的父节点如果为红色，则违背了特性 4，需要平衡，平衡时又分成下面三种情况：</li></ol><p><strong>（如果父节点是祖父节点的左节点）</strong></p><table><thead><tr><th>情况</th><th>策略</th></tr></thead><tbody><tr><td>1）父节点为红色，叔叔节点也为红色</td><td>（1）将父节点设为黑色；（2）将叔叔节点设为黑色；（3）将祖父节点设为红色；（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td></tr><tr><td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td><td>（1）将父节点作为新的当前节点；（2）以新当节点为支点进行左旋，进入情况 3）；</td></tr><tr><td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td><td>（1）将父节点设为黑色；（2）将祖父节点设为红色；（3）以祖父节点为支点进行右旋，进入下一次循环判断；</td></tr></tbody></table><p><strong>（如果父节点是祖父节点的右节点，则正好与上面反过来）</strong></p><table><thead><tr><th>情况</th><th>策略</th></tr></thead><tbody><tr><td>1）父节点为红色，叔叔节点也为红色</td><td>（1）将父节点设为黑色；（2）将叔叔节点设为黑色；（3）将祖父节点设为红色；（4）将祖父节点设为新的当前节点，进入下一次循环判断；</td></tr><tr><td>2）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的左节点</td><td>（1）将父节点作为新的当前节点；（2）以新当节点为支点进行右旋；</td></tr><tr><td>3）父节点为红色，叔叔节点为黑色，且当前节点是其父节点的右节点</td><td>（1）将父节点设为黑色；（2）将祖父节点设为红色；（3）以祖父节点为支点进行左旋，进入下一次循环判断；</td></tr></tbody></table><p>让我们来看看 TreeMap 中的实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">    * 插入再平衡</span><br><span class="line">    *（1）每个节点或者是黑色，或者是红色。</span><br><span class="line">    *（2）根节点是黑色。</span><br><span class="line">    *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span><br><span class="line">    *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line">    *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span><br><span class="line">    */</span><br><span class="line">   private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123;</span><br><span class="line">       // 插入的节点为红节点，x为当前节点</span><br><span class="line">       x.color = RED;</span><br><span class="line">   </span><br><span class="line">       // 只有当插入节点不是根节点且其父节点为红色时才需要平衡（违背了特性4）</span><br><span class="line">       while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">           if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">               // a）如果父节点是祖父节点的左节点</span><br><span class="line">               // y为叔叔节点</span><br><span class="line">               Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">               if (colorOf(y) == RED) &#123;</span><br><span class="line">                   // 情况1）如果叔叔节点为红色</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将叔叔节点设为黑色</span><br><span class="line">                   setColor(y, BLACK);</span><br><span class="line">                   // （3）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （4）将祖父节点设为新的当前节点</span><br><span class="line">                   x = parentOf(parentOf(x));</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // 如果叔叔节点为黑色</span><br><span class="line">                   // 情况2）如果当前节点为其父节点的右节点</span><br><span class="line">                   if (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                       // （1）将父节点设为当前节点</span><br><span class="line">                       x = parentOf(x);</span><br><span class="line">                       // （2）以新当前节点左旋</span><br><span class="line">                       rotateLeft(x);</span><br><span class="line">                   &#125;</span><br><span class="line">                   // 情况3）如果当前节点为其父节点的左节点（如果是情况2）则左旋之后新当前节点正好为其父节点的左节点了）</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （3）以祖父节点为支点进行右旋</span><br><span class="line">                   rotateRight(parentOf(parentOf(x)));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // b）如果父节点是祖父节点的右节点</span><br><span class="line">               // y是叔叔节点</span><br><span class="line">               Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">               if (colorOf(y) == RED) &#123;</span><br><span class="line">                   // 情况1）如果叔叔节点为红色</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将叔叔节点设为黑色</span><br><span class="line">                   setColor(y, BLACK);</span><br><span class="line">                   // （3）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （4）将祖父节点设为新的当前节点</span><br><span class="line">                   x = parentOf(parentOf(x));</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // 如果叔叔节点为黑色</span><br><span class="line">                   // 情况2）如果当前节点为其父节点的左节点</span><br><span class="line">                   if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                       // （1）将父节点设为当前节点</span><br><span class="line">                       x = parentOf(x);</span><br><span class="line">                       // （2）以新当前节点右旋</span><br><span class="line">                       rotateRight(x);</span><br><span class="line">                   &#125;</span><br><span class="line">                   // 情况3）如果当前节点为其父节点的右节点（如果是情况2）则右旋之后新当前节点正好为其父节点的右节点了）</span><br><span class="line">                   // （1）将父节点设为黑色</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   // （2）将祖父节点设为红色</span><br><span class="line">                   setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                   // （3）以祖父节点为支点进行左旋</span><br><span class="line">                   rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 平衡完成后将根节点设为黑色</span><br><span class="line">       root.color = BLACK;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="红黑树怎么删除元素"><a class="markdownIt-Anchor" href="#红黑树怎么删除元素">#</a> 红黑树怎么删除元素？</h2><p>删除元素本身比较简单，就是采用二叉树的删除规则。</p><p>（1）如果删除的位置有两个叶子节点，则从其右子树中取最小的元素放到删除的位置，然后把删除位置移到替代元素的位置，进入下一步。</p><p>（2）如果删除的位置只有一个叶子节点（有可能是经过第一步转换后的删除位置），则把那个叶子节点作为替代元素，放到删除的位置，然后把这个叶子节点删除。</p><p>（3）如果删除的位置没有叶子节点，则直接把这个删除位置的元素删除即可。</p><p>（4）针对红黑树，如果删除位置是黑色节点，还需要做再平衡。</p><p>（5）如果有替代元素，则以替代元素作为当前节点进入再平衡。</p><p>（6）如果没有替代元素，则以删除的位置的元素作为当前节点进入再平衡，平衡之后再删除这个节点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">       // 获取节点</span><br><span class="line">       Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">       if (p == null)</span><br><span class="line">           return null;</span><br><span class="line">   </span><br><span class="line">       V oldValue = p.value;</span><br><span class="line">       // 删除节点</span><br><span class="line">       deleteEntry(p);</span><br><span class="line">       // 返回删除的value</span><br><span class="line">       return oldValue;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private void deleteEntry(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">       // 修改次数加1</span><br><span class="line">       modCount++;</span><br><span class="line">       // 元素个数减1</span><br><span class="line">       size--;</span><br><span class="line">   </span><br><span class="line">       if (p.left != null &amp;&amp; p.right != null) &#123;</span><br><span class="line">           // 如果当前节点既有左子节点，又有右子节点</span><br><span class="line">           // 取其右子树中最小的节点</span><br><span class="line">           Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">           // 用右子树中最小节点的值替换当前节点的值</span><br><span class="line">           p.key = s.key;</span><br><span class="line">           p.value = s.value;</span><br><span class="line">           // 把右子树中最小节点设为当前节点</span><br><span class="line">           p = s;</span><br><span class="line">           // 这种情况实际上并没有删除p节点，而是把p节点的值改了，实际删除的是p的后继节点</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 如果原来的当前节点（p）有2个子节点，则当前节点已经变成原来p的右子树中的最小节点了，也就是说其没有左子节点了</span><br><span class="line">       // 到这一步，p肯定只有一个子节点了</span><br><span class="line">       // 如果当前节点有子节点，则用子节点替换当前节点</span><br><span class="line">       Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);</span><br><span class="line">   </span><br><span class="line">       if (replacement != null) &#123;</span><br><span class="line">           // 把替换节点直接放到当前节点的位置上（相当于删除了p，并把替换节点移动过来了）</span><br><span class="line">           replacement.parent = p.parent;</span><br><span class="line">           if (p.parent == null)</span><br><span class="line">               root = replacement;</span><br><span class="line">           else if (p == p.parent.left)</span><br><span class="line">               p.parent.left  = replacement;</span><br><span class="line">           else</span><br><span class="line">               p.parent.right = replacement;</span><br><span class="line">   </span><br><span class="line">           // 将p的各项属性都设为空</span><br><span class="line">           p.left = p.right = p.parent = null;</span><br><span class="line">   </span><br><span class="line">           // 如果p是黑节点，则需要再平衡</span><br><span class="line">           if (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(replacement);</span><br><span class="line">       &#125; else if (p.parent == null) &#123;</span><br><span class="line">           // 如果当前节点就是根节点，则直接将根节点设为空即可</span><br><span class="line">           root = null;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           // 如果当前节点没有子节点且其为黑节点，则把自己当作虚拟的替换节点进行再平衡</span><br><span class="line">           if (p.color == BLACK)</span><br><span class="line">               fixAfterDeletion(p);</span><br><span class="line">   </span><br><span class="line">           // 平衡完成后删除当前节点（与父节点断绝关系）</span><br><span class="line">           if (p.parent != null) &#123;</span><br><span class="line">               if (p == p.parent.left)</span><br><span class="line">                   p.parent.left = null;</span><br><span class="line">               else if (p == p.parent.right)</span><br><span class="line">                   p.parent.right = null;</span><br><span class="line">               p.parent = null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过上面的处理，真正删除的肯定是黑色节点才会进入到再平衡阶段。</p><p>因为删除的是黑色节点，导致整颗树不平衡了，所以这里我们假设把删除的黑色赋予当前节点，这样当前节点除了它自已的颜色还多了一个黑色，那么：</p><p>（1）如果当前节点是根节点，则直接涂黑即可，不需要再平衡；</p><p>（2）如果当前节点是红 + 黑节点，则直接涂黑即可，不需要平衡；</p><p>（3）如果当前节点是黑 + 黑节点，则我们只要通过旋转把这个多出来的黑色不断的向上传递到一个红色节点即可，这又可能会出现以下四种情况：</p><p><strong>（假设当前节点为父节点的左子节点）</strong></p><table><thead><tr><th>情况</th><th>策略</th></tr></thead><tbody><tr><td>1）x 是黑 + 黑节点，x 的兄弟是红节点</td><td>（1）将兄弟节点设为黑色；（2）将父节点设为红色；（3）以父节点为支点进行左旋；（4）重新设置 x 的兄弟节点，进入下一步；</td></tr><tr><td>2）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td><td>（1）将兄弟节点设置为红色；（2）将 x 的父节点作为新的当前节点，进入下一次循环；</td></tr><tr><td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的右子节点为黑色，左子节点为红色</td><td>（1）将兄弟节点的左子节点设为黑色；（2）将兄弟节点设为红色；（3）以兄弟节点为支点进行右旋；（4）重新设置 x 的兄弟节点，进入下一步；</td></tr><tr><td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的右子节点为红色，左子节点任意颜色</td><td>（1）将兄弟节点的颜色设为父节点的颜色；（2）将父节点设为黑色；（3）将兄弟节点的右子节点设为黑色；（4）以父节点为支点进行左旋；（5）将 root 作为新的当前节点（退出循环）；</td></tr></tbody></table><p><strong>（假设当前节点为父节点的右子节点，正好反过来）</strong></p><table><thead><tr><th>情况</th><th>策略</th></tr></thead><tbody><tr><td>1）x 是黑 + 黑节点，x 的兄弟是红节点</td><td>（1）将兄弟节点设为黑色；（2）将父节点设为红色；（3）以父节点为支点进行右旋；（4）重新设置 x 的兄弟节点，进入下一步；</td></tr><tr><td>2）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的两个子节点都是黑色</td><td>（1）将兄弟节点设置为红色；（2）将 x 的父节点作为新的当前节点，进入下一次循环；</td></tr><tr><td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的左子节点为黑色，右子节点为红色</td><td>（1）将兄弟节点的右子节点设为黑色；（2）将兄弟节点设为红色；（3）以兄弟节点为支点进行左旋；（4）重新设置 x 的兄弟节点，进入下一步；</td></tr><tr><td>3）x 是黑 + 黑节点，x 的兄弟是黑节点，且兄弟节点的左子节点为红色，右子节点任意颜色</td><td>（1）将兄弟节点的颜色设为父节点的颜色；（2）将父节点设为黑色；（3）将兄弟节点的左子节点设为黑色；（4）以父节点为支点进行右旋；（5）将 root 作为新的当前节点（退出循环）；</td></tr></tbody></table><p>让我们来看看 TreeMap 中的实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">/**</span><br><span class="line">     * 删除再平衡</span><br><span class="line">     *（1）每个节点或者是黑色，或者是红色。</span><br><span class="line">     *（2）根节点是黑色。</span><br><span class="line">     *（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！）</span><br><span class="line">     *（4）如果一个节点是红色的，则它的子节点必须是黑色的。</span><br><span class="line">     *（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</span><br><span class="line">*/</span><br><span class="line">private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123;</span><br><span class="line">        // 只有当前节点不是根节点且当前节点是黑色时才进入循环</span><br><span class="line">        while (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">            if (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                // 如果当前节点是其父节点的左子节点</span><br><span class="line">                // sib是当前节点的兄弟节点</span><br><span class="line">                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">    </span><br><span class="line">                // 情况1）如果兄弟节点是红色</span><br><span class="line">                if (colorOf(sib) == RED) &#123;</span><br><span class="line">                    // （1）将兄弟节点设为黑色</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    // （2）将父节点设为红色</span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    // （3）以父节点为支点进行左旋</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    // （4）重新设置x的兄弟节点，进入下一步</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                if (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                        colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    // 情况2）如果兄弟节点的两个子节点都是黑色</span><br><span class="line">                    // （1）将兄弟节点设置为红色</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    // （2）将x的父节点作为新的当前节点，进入下一次循环</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                        // 情况3）如果兄弟节点的右子节点为黑色</span><br><span class="line">                        // （1）将兄弟节点的左子节点设为黑色</span><br><span class="line">                        setColor(leftOf(sib), BLACK);</span><br><span class="line">                        // （2）将兄弟节点设为红色</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        // （3）以兄弟节点为支点进行右旋</span><br><span class="line">                        rotateRight(sib);</span><br><span class="line">                        // （4）重新设置x的兄弟节点</span><br><span class="line">                        sib = rightOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 情况4）</span><br><span class="line">                    // （1）将兄弟节点的颜色设为父节点的颜色</span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    // （2）将父节点设为黑色</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    // （3）将兄弟节点的右子节点设为黑色</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    // （4）以父节点为支点进行左旋</span><br><span class="line">                    rotateLeft(parentOf(x));</span><br><span class="line">                    // （5）将root作为新的当前节点（退出循环）</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // symmetric</span><br><span class="line">                // 如果当前节点是其父节点的右子节点</span><br><span class="line">                // sib是当前节点的兄弟节点</span><br><span class="line">                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">    </span><br><span class="line">                // 情况1）如果兄弟节点是红色</span><br><span class="line">                if (colorOf(sib) == RED) &#123;</span><br><span class="line">                    // （1）将兄弟节点设为黑色</span><br><span class="line">                    setColor(sib, BLACK);</span><br><span class="line">                    // （2）将父节点设为红色</span><br><span class="line">                    setColor(parentOf(x), RED);</span><br><span class="line">                    // （3）以父节点为支点进行右旋</span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    // （4）重新设置x的兄弟节点</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                if (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                        colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    // 情况2）如果兄弟节点的两个子节点都是黑色</span><br><span class="line">                    // （1）将兄弟节点设置为红色</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    // （2）将x的父节点作为新的当前节点，进入下一次循环</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                        // 情况3）如果兄弟节点的左子节点为黑色</span><br><span class="line">                        // （1）将兄弟节点的右子节点设为黑色</span><br><span class="line">                        setColor(rightOf(sib), BLACK);</span><br><span class="line">                        // （2）将兄弟节点设为红色</span><br><span class="line">                        setColor(sib, RED);</span><br><span class="line">                        // （3）以兄弟节点为支点进行左旋</span><br><span class="line">                        rotateLeft(sib);</span><br><span class="line">                        // （4）重新设置x的兄弟节点</span><br><span class="line">                        sib = leftOf(parentOf(x));</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 情况4）</span><br><span class="line">                    // （1）将兄弟节点的颜色设为父节点的颜色</span><br><span class="line">                    setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                    // （2）将父节点设为黑色</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    // （3）将兄弟节点的左子节点设为黑色</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    // （4）以父节点为支点进行右旋</span><br><span class="line">                    rotateRight(parentOf(x));</span><br><span class="line">                    // （5）将root作为新的当前节点（退出循环）</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 退出条件为多出来的黑色向上传递到了根节点或者红节点</span><br><span class="line">        // 则将x设为黑色即可满足红黑树规则</span><br><span class="line">        setColor(x, BLACK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="为什么要进行平衡"><a class="markdownIt-Anchor" href="#为什么要进行平衡">#</a> 为什么要进行平衡？</h2><p>因为违背了红黑树的性质，必须保证红黑树的五大性质。</p><p>（1）节点是红色或黑色。</p><p>（2）根节点是黑色。</p><p>（3）每个叶节点（NIL 节点，空节点）是黑色的。</p><p>（4）每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>（5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><h2 id="如何实现红黑树的遍历"><a class="markdownIt-Anchor" href="#如何实现红黑树的遍历">#</a> 如何实现红黑树的遍历？</h2><p>（1）从 root 遍历整个树；</p><p>（2）如果待查找的 key 比当前遍历的 key 小，则在其左子树中查找；</p><p>（3）如果待查找的 key 比当前遍历的 key 大，则在其右子树中查找；</p><p>（4）如果待查找的 key 与当前遍历的 key 相等，则找到了该元素，直接返回；</p><p>（5）从这里可以看出是否有 comparator 分化成了两个方法，但是内部逻辑一模一样，因此可见笔者 <code>comparator = (k1, k2) -&gt; ((Comparable&lt;? super K&gt;)k1).compareTo(k2);</code>  这种改造的必要性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">        // 根据key查找元素</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">        // 找到了返回value值，没找到返回null</span><br><span class="line">        return (p==null ? null : p.value);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">        // 如果comparator不为空，使用comparator的版本获取元素</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            return getEntryUsingComparator(key);</span><br><span class="line">        // 如果key为空返回空指针异常</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        // 将key强转为Comparable</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">        // 从根元素开始遍历</span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        while (p != null) &#123;</span><br><span class="line">            int cmp = k.compareTo(p.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                // 如果小于0从左子树查找</span><br><span class="line">                p = p.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                // 如果大于0从右子树查找</span><br><span class="line">                p = p.right;</span><br><span class="line">            else</span><br><span class="line">                // 如果相等说明找到了直接返回</span><br><span class="line">                return p;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没找到返回null</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K k = (K) key;</span><br><span class="line">        Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">        if (cpr != null) &#123;</span><br><span class="line">            // 从根元素开始遍历</span><br><span class="line">            Entry&lt;K,V&gt; p = root;</span><br><span class="line">            while (p != null) &#123;</span><br><span class="line">                int cmp = cpr.compare(k, p.key);</span><br><span class="line">                if (cmp &lt; 0)</span><br><span class="line">                    // 如果小于0从左子树查找</span><br><span class="line">                    p = p.left;</span><br><span class="line">                else if (cmp &gt; 0)</span><br><span class="line">                    // 如果大于0从右子树查找</span><br><span class="line">                    p = p.right;</span><br><span class="line">                else</span><br><span class="line">                    // 如果相等说明找到了直接返回</span><br><span class="line">                    return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 没找到返回null</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="treemap为什么不允许key为null"><a class="markdownIt-Anchor" href="#treemap为什么不允许key为null">#</a> TreeMap 为什么不允许 key 为 null?</h2><p>TreeMap 的 <strong>key</strong> 不允许为空 (  <code>null</code>  )，可能是因为红黑树是一颗二叉查找树，需要对 key 进行排序。</p><h2 id="treemap中是怎么遍历的"><a class="markdownIt-Anchor" href="#treemap中是怎么遍历的">#</a> TreeMap 中是怎么遍历的？</h2><h2 id="treemap插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#treemap插入-删除-查询元素的时间复杂度各是多少">#</a> TreeMap 插入、删除、查询元素的时间复杂度各是多少？</h2><p>TreeMap 的查找、添加、删除 key-value 键值对的<strong>平均</strong>时间复杂度为  <code>O(logN)</code>  。原因是，TreeMap 采用红黑树，操作都需要经过二分查找，而二分查找的时间复杂度是  <code>O(logN)</code>  。</p><h2 id="hashmap在多线程环境中什么时候会出现问题"><a class="markdownIt-Anchor" href="#hashmap在多线程环境中什么时候会出现问题">#</a> HashMap 在多线程环境中什么时候会出现问题？</h2><p>在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，下面举例子说明在并发的多线程使用场景中使用 HashMap 可能造成死循环。代码例子如下 (便于理解，仍然使用 JDK1.7 的环境)：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class HashMapInfiniteLoop &#123;  </span><br><span class="line"></span><br><span class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f);  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        map.put(5， &quot;C&quot;);  </span><br><span class="line"></span><br><span class="line">        new Thread(&quot;Thread1&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(7, &quot;B&quot;);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        new Thread(&quot;Thread2&quot;) &#123;  </span><br><span class="line">            public void run() &#123;  </span><br><span class="line">                map.put(3, &quot;A);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();        </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，map 初始化为一个长度为 2 的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当 put 第二个 key 的时候，map 就需要进行 resize。</p><p>通过设置断点让线程 1 和线程 2 同时 debug 到 transfer 方法 (3.3 小节代码块) 的首行。注意此时两个线程已经成功添加数据。放开 thread1 的断点至 transfer 方法的 “Entry next = e.next;” 这一行；然后放开线程 2 的的断点，让线程 2 进行 resize。结果如下图。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173358.png" alt="img"></p><p>注意，Thread1 的 e 指向了 key (3)，而 next 指向了 key (7)，其在线程二 rehash 后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe [i] = e， 然后是 e = next，导致了 e 指向了 key (7)，而下一次循环的 next = e.next 导致了 next 指向了 key (3)。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817173416.png" alt="img"></p><p>于是，当我们用线程一调用 map.get (11) 时，悲剧就出现了 ——Infinite Loop。</p><h2 id="concurrenthashmap的存储结构"><a class="markdownIt-Anchor" href="#concurrenthashmap的存储结构">#</a> ConcurrentHashMap 的存储结构？</h2><p>ConcurrentHashMap 采用（数组 + 链表 + 红黑树）的结构存储元素；</p><h2 id="concurrenthashmap是怎么保证并发安全的"><a class="markdownIt-Anchor" href="#concurrenthashmap是怎么保证并发安全的">#</a> ConcurrentHashMap 是怎么保证并发安全的？</h2><p>ConcurrentHashMap 采用的锁有 synchronized，CAS，自旋锁，分段锁，volatile 等</p><h2 id="concurrenthashmap是怎么扩容的"><a class="markdownIt-Anchor" href="#concurrenthashmap是怎么扩容的">#</a> ConcurrentHashMap 是怎么扩容的？</h2><p>1. 每次添加元素后，元素数量加 1，并判断是否达到扩容门槛，达到了则进行扩容或协助扩容。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> private final void addCount(long x, int check) &#123;</span><br><span class="line">        CounterCell[] as; long b, s;</span><br><span class="line">        // 这里使用的思想跟LongAdder类是一模一样的（后面会讲）</span><br><span class="line">        // 把数组的大小存储根据不同的线程存储到不同的段上（也是分段锁的思想）</span><br><span class="line">        // 并且有一个baseCount，优先更新baseCount，如果失败了再更新不同线程对应的段</span><br><span class="line">        // 这样可以保证尽量小的减少冲突</span><br><span class="line">    </span><br><span class="line">        // 先尝试把数量加到baseCount上，如果失败再加到分段的CounterCell上</span><br><span class="line">        if ((as = counterCells) != null ||</span><br><span class="line">                !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            CounterCell a; long v; int m;</span><br><span class="line">            boolean uncontended = true;</span><br><span class="line">            // 如果as为空</span><br><span class="line">            // 或者长度为0</span><br><span class="line">            // 或者当前线程所在的段为null</span><br><span class="line">            // 或者在当前线程的段上加数量失败</span><br><span class="line">            if (as == null || (m = as.length - 1) &lt; 0 ||</span><br><span class="line">                    (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</span><br><span class="line">                    !(uncontended =</span><br><span class="line">                            U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                // 强制增加数量（无论如何数量是一定要加上的，并不是简单地自旋）</span><br><span class="line">                // 不同线程对应不同的段都更新失败了</span><br><span class="line">                // 说明已经发生冲突了，那么就对counterCells进行扩容</span><br><span class="line">                // 以减少多个线程hash到同一个段的概率</span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (check &lt;= 1)</span><br><span class="line">                return;</span><br><span class="line">            // 计算元素个数</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        if (check &gt;= 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            // 如果元素个数达到了扩容门槛，则进行扩容</span><br><span class="line">            // 注意，正常情况下sizeCtl存储的是扩容门槛，即容量的0.75倍</span><br><span class="line">            while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">                    (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                // rs是扩容时的一个邮戳标识</span><br><span class="line">                int rs = resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    // sc&lt;0说明正在扩容中</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                            sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                            transferIndex &lt;= 0)</span><br><span class="line">                        // 扩容已经完成了，退出循环</span><br><span class="line">                        // 正常应该只会触发nextTable==null这个条件，其它条件没看出来何时触发</span><br><span class="line">                        break;</span><br><span class="line">    </span><br><span class="line">                    // 扩容未完成，则当前线程加入迁移元素中</span><br><span class="line">                    // 并把扩容线程数加1</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                        (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    // 这里是触发扩容的那个线程进入的地方</span><br><span class="line">                    // sizeCtl的高16位存储着rs这个扩容邮戳</span><br><span class="line">                    // sizeCtl的低16位存储着扩容线程数加1，即(1+nThreads)</span><br><span class="line">                    // 所以官方说的扩容时sizeCtl的值为 -(1+nThreads)是错误的</span><br><span class="line">    </span><br><span class="line">                    // 进入迁移元素</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                // 重新计算元素个数</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）元素个数的存储方式类似于 LongAdder 类，存储在不同的段上，减少不同线程同时更新 size 时的冲突；</p><p>（2）计算元素个数时把这些段的值及 baseCount 相加算出总的元素个数；</p><p>（3）正常情况下 sizeCtl 存储着扩容门槛，扩容门槛为容量的 0.75 倍；</p><p>（4）扩容时 sizeCtl 高位存储扩容邮戳 (resizeStamp)，低位存储扩容线程数加 1（1+nThreads）；</p><p>（5）其它线程添加元素后如果发现存在扩容，也会加入的扩容行列中来；</p><p>2. 线程添加元素时发现正在扩容且当前元素所在的桶元素已经迁移完成了，则协助迁移其它桶的元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">        // 如果桶数组不为空，并且当前桶第一个元素为ForwardingNode类型，并且nextTab不为空</span><br><span class="line">        // 说明当前桶已经迁移完毕了，才去帮忙迁移其它桶的元素</span><br><span class="line">        // 扩容时会把旧桶的第一个元素置为ForwardingNode，并让其nextTab指向新桶数组</span><br><span class="line">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">                (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">            int rs = resizeStamp(tab.length);</span><br><span class="line">            // sizeCtl&lt;0，说明正在扩容</span><br><span class="line">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                    (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                // 扩容线程数加1</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                    // 当前线程帮忙迁移元素</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        return table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当前桶元素迁移完成了才去协助迁移其它桶元素；</p><p>3. 扩容时容量变为两倍，并把部分元素迁移到其它桶中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">        int n = tab.length, stride;</span><br><span class="line">        if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br><span class="line">        if (nextTab == null) &#123;            // initiating</span><br><span class="line">            // 如果nextTab为空，说明还没开始迁移</span><br><span class="line">            // 就新建一个新桶数组</span><br><span class="line">            try &#123;</span><br><span class="line">                // 新桶数组是原桶的两倍</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        // 新桶数组大小</span><br><span class="line">        int nextn = nextTab.length;</span><br><span class="line">        // 新建一个ForwardingNode类型的节点，并把新桶数组存储在里面</span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">        boolean advance = true;</span><br><span class="line">        boolean finishing = false; // to ensure sweep before committing nextTab</span><br><span class="line">        for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int fh;</span><br><span class="line">            // 整个while循环就是在算i的值，过程太复杂，不用太关心</span><br><span class="line">            // i的值会从n-1依次递减，感兴趣的可以打下断点就知道了</span><br><span class="line">            // 其中n是旧桶数组的大小，也就是说i从15开始一直减到1这样去迁移元素</span><br><span class="line">            while (advance) &#123;</span><br><span class="line">                int nextIndex, nextBound;</span><br><span class="line">                if (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = false;</span><br><span class="line">                else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">                    i = -1;</span><br><span class="line">                    advance = false;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt</span><br><span class="line">                        (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                                nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                        nextIndex - stride : 0))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - 1;</span><br><span class="line">                    advance = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                // 如果一次遍历完成了</span><br><span class="line">                // 也就是整个map所有桶中的元素都迁移完成了</span><br><span class="line">                int sc;</span><br><span class="line">                if (finishing) &#123;</span><br><span class="line">                    // 如果全部迁移完成了，则替换旧桶数组</span><br><span class="line">                    // 并设置下一次扩容门槛为新桶数组容量的0.75倍</span><br><span class="line">                    nextTable = null;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</span><br><span class="line">                    // 当前线程扩容完成，把扩容线程数-1</span><br><span class="line">                    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        // 扩容完成两边肯定相等</span><br><span class="line">                        return;</span><br><span class="line">                    // 把finishing设置为true</span><br><span class="line">                    // finishing为true才会走到上面的if条件</span><br><span class="line">                    finishing = advance = true;</span><br><span class="line">                    // i重新赋值为n</span><br><span class="line">                    // 这样会再重新遍历一次桶数组，看看是不是都迁移完成了</span><br><span class="line">                    // 也就是第二次遍历都会走到下面的(fh = f.hash) == MOVED这个条件</span><br><span class="line">                    i = n; // recheck before commit</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((f = tabAt(tab, i)) == null)</span><br><span class="line">                // 如果桶中无数据，直接放入ForwardingNode标记该桶已迁移</span><br><span class="line">                advance = casTabAt(tab, i, null, fwd);</span><br><span class="line">            else if ((fh = f.hash) == MOVED)</span><br><span class="line">                // 如果桶中第一个元素的hash值为MOVED</span><br><span class="line">                // 说明它是ForwardingNode节点</span><br><span class="line">                // 也就是该桶已迁移</span><br><span class="line">                advance = true; // already processed</span><br><span class="line">            else &#123;</span><br><span class="line">                // 锁定该桶并迁移元素</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    // 再次判断当前桶第一个元素是否有修改</span><br><span class="line">                    // 也就是可能其它线程先一步迁移了元素</span><br><span class="line">                    if (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        // 把一个链表分化成两个链表</span><br><span class="line">                        // 规则是桶中各元素的hash与桶大小n进行与操作</span><br><span class="line">                        // 等于0的放到低位链表(low)中，不等于0的放到高位链表(high)中</span><br><span class="line">                        // 其中低位链表迁移到新桶中的位置相对旧桶不变</span><br><span class="line">                        // 高位链表迁移到新桶中位置正好是其在旧桶的位置加n</span><br><span class="line">                        // 这也正是为什么扩容时容量在变成两倍的原因</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        if (fh &gt;= 0) &#123;</span><br><span class="line">                            // 第一个元素的hash值大于等于0</span><br><span class="line">                            // 说明该桶中元素是以链表形式存储的</span><br><span class="line">                            // 这里与HashMap迁移算法基本类似</span><br><span class="line">                            // 唯一不同的是多了一步寻找lastRun</span><br><span class="line">                            // 这里的lastRun是提取出链表后面不用处理再特殊处理的子链表</span><br><span class="line">                            // 比如所有元素的hash值与桶大小n与操作后的值分别为 0 0 4 4 0 0 0</span><br><span class="line">                            // 则最后后面三个0对应的元素肯定还是在同一个桶中</span><br><span class="line">                            // 这时lastRun对应的就是倒数第三个节点</span><br><span class="line">                            // 至于为啥要这样处理，我也没太搞明白</span><br><span class="line">                            int runBit = fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</span><br><span class="line">                                int b = p.hash &amp; n;</span><br><span class="line">                                if (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 看看最后这几个元素归属于低位链表还是高位链表</span><br><span class="line">                            if (runBit == 0) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = null;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = null;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 遍历链表，把hash&amp;n为0的放在低位链表中</span><br><span class="line">                            // 不为0的放在高位链表中</span><br><span class="line">                            for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                int ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                if ((ph &amp; n) == 0)</span><br><span class="line">                                    ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                else</span><br><span class="line">                                    hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 低位链表的位置不变</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            // 高位链表的位置是原位置加n</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            // 标记当前桶已迁移</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            // advance为true，返回上面进行--i操作</span><br><span class="line">                            advance = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123;</span><br><span class="line">                            // 如果第一个元素是树节点</span><br><span class="line">                            // 也是一样，分化成两颗树</span><br><span class="line">                            // 也是根据hash&amp;n为0放在低位树中</span><br><span class="line">                            // 不为0放在高位树中</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = null, loTail = null;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = null, hiTail = null;</span><br><span class="line">                            int lc = 0, hc = 0;</span><br><span class="line">                            // 遍历整颗树，根据hash&amp;n是否为0分化成两颗树</span><br><span class="line">                            for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;</span><br><span class="line">                                int h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</span><br><span class="line">                                        (h, e.key, e.val, null, null);</span><br><span class="line">                                if ((h &amp; n) == 0) &#123;</span><br><span class="line">                                    if ((p.prev = loTail) == null)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    else</span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                else &#123;</span><br><span class="line">                                    if ((p.prev = hiTail) == null)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    else</span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 如果分化的树中元素个数小于等于6，则退化成链表</span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                    (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                    (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            // 低位树的位置不变</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            // 高位树的位置是原位置加n</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            // 标记该桶已迁移</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            // advance为true，返回上面进行--i操作</span><br><span class="line">                            advance = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）新桶数组大小是旧桶数组的两倍；</p><p>（2）迁移元素先从靠后的桶开始；</p><p>（3）迁移完成的桶在里面放置一 ForwardingNode 类型的元素，标记该桶迁移完成；</p><p>（4）迁移时根据 hash&amp;n 是否等于 0 把桶中元素分化成两个链表或树；</p><p>（5）低位链表（树）存储在原来的位置；</p><p>（6）高们链表（树）存储在原来的位置加 n 的位置；</p><p>（7）迁移元素时会锁住当前桶，也是分段锁的思想；</p><h2 id="concurrenthashmap的size方法的实现知道多少"><a class="markdownIt-Anchor" href="#concurrenthashmap的size方法的实现知道多少">#</a> ConcurrentHashMap 的 size () 方法的实现知道多少？</h2><p>元素个数的存储也是采用分段的思想，获取元素个数时需要把所有段加起来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public int size() &#123;</span><br><span class="line">        // 调用sumCount()计算元素个数</span><br><span class="line">        long n = sumCount();</span><br><span class="line">        return ((n &lt; 0L) ? 0 :</span><br><span class="line">                (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                        (int)n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    final long sumCount() &#123;</span><br><span class="line">        // 计算CounterCell所有段及baseCount的数量之和</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        long sum = baseCount;</span><br><span class="line">        if (as != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; as.length; ++i) &#123;</span><br><span class="line">                if ((a = as[i]) != null)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）元素的个数依据不同的线程存在在不同的段里；（见 addCounter () 分析）</p><p>（2）计算 CounterCell 所有段及 baseCount 的数量之和；</p><p>（3）获取元素个数没有加锁；</p><h2 id="concurrenthashmap是强一致性的吗"><a class="markdownIt-Anchor" href="#concurrenthashmap是强一致性的吗">#</a> ConcurrentHashMap 是强一致性的吗？</h2><p>查询操作是不会加锁的，所以 ConcurrentHashMap 不是强一致性的；</p><h2 id="concurrenthashmap不能解决什么问题"><a class="markdownIt-Anchor" href="#concurrenthashmap不能解决什么问题">#</a> ConcurrentHashMap 不能解决什么问题？</h2><p>ConcurrentHashMap 中不能存储 key 或 value 为 null 的元素；</p><p>例子:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private static final Map&lt;Integer, Integer&gt; map = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">public void unsafeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        if (oldValue == null) &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里如果有多个线程同时调用 unsafeUpdate () 这个方法，ConcurrentHashMap 还能保证线程安全吗？</p><p>答案是不能。因为 get () 之后 if 之前可能有其它线程已经 put () 了这个元素，这时候再 put () 就把那个线程 put () 的元素覆盖了。</p><p>那怎么修改呢？</p><p>答案也很简单，使用 putIfAbsent () 方法，它会保证元素不存在时才插入元素，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void safeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        map.putIfAbsent(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么，如果上面 oldValue 不是跟 null 比较，而是跟一个特定的值比如 1 进行比较怎么办？也就是下面这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void unsafeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        if (oldValue == 1) &#123;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样的话就没办法使用 putIfAbsent () 方法了。</p><p>其实，ConcurrentHashMap 还提供了另一个方法叫 replace (K key, V oldValue, V newValue) 可以解决这个问题。</p><p>replace (K key, V oldValue, V newValue) 这个方法可不能乱用，如果传入的 newValue 是 null，则会删除元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void safeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        map.replace(key, 1, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么，如果 if 之后不是简单的 put () 操作，而是还有其它业务操作，之后才是 put ()，比如下面这样，这该怎么办呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void unsafeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        Integer oldValue = map.get(key);</span><br><span class="line">        if (oldValue == 1) &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">            /**</span><br><span class="line">             * 其它业务操作</span><br><span class="line">             */</span><br><span class="line">            System.out.println(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">            map.put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候就没办法使用 ConcurrentHashMap 提供的方法了，只能业务自己来保证线程安全了，比如下面这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void safeUpdate(Integer key, Integer value) &#123;</span><br><span class="line">        synchronized (map) &#123;</span><br><span class="line">            Integer oldValue = map.get(key);</span><br><span class="line">            if (oldValue == null) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">                /**</span><br><span class="line">                 * 其它业务操作</span><br><span class="line">                 */</span><br><span class="line">                System.out.println(System.currentTimeMillis());</span><br><span class="line">    </span><br><span class="line">                map.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样虽然不太友好，但是最起码能保证业务逻辑是正确的。</p><p>当然，这里使用 ConcurrentHashMap 的意义也就不大了，可以换成普通的 HashMap 了。</p><p>上面只是举一个简单的例子，我们不能听说 ConcurrentHashMap 是线程安全的，就认为它无论什么情况下都是线程安全的，还是那句话尽信书不如无书。</p><h2 id="concurrenthashmap的sizectl知道吗"><a class="markdownIt-Anchor" href="#concurrenthashmap的sizectl知道吗">#</a> ConcurrentHashMap 的 sizeCtl 知道吗？</h2><p>ConcurrentHashMap 中没有 threshold 和 loadFactor 这两个字段，而是采用 sizeCtl 来控制；</p><p>sizeCtl = -1，表示正在进行初始化；</p><p>sizeCtl = 0，默认值，表示后续在真正初始化的时候使用默认容量；</p><p>sizeCtl &gt; 0，在初始化之前存储的是传入的容量，在初始化或扩容后存储的是下一次的扩容门槛；</p><p>sizeCtl = (resizeStamp &lt;&lt; 16) + (1 + nThreads)，表示正在进行扩容，高位存储扩容邮戳，低位存储扩容线程数加 1；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">        if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">                MAXIMUM_CAPACITY :</span><br><span class="line">                tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        this.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">        this(initialCapacity, loadFactor, 1);</span><br><span class="line">&#125;</span><br><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                             float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">        if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">            initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">        long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">        int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">                MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">        this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="concurrenthashmap中哪些地方运用到分段锁的思想"><a class="markdownIt-Anchor" href="#concurrenthashmap中哪些地方运用到分段锁的思想">#</a> ConcurrentHashMap 中哪些地方运用到分段锁的思想？</h2><p>分段锁，是一种锁的设计思路，它细化了锁的粒度，主要运用在 ConcurrentHashMap 中，实现高效的并发操作，当操作不需要更新整个数组时，就只锁数组中的一项就可以了。</p><h2 id="什么是伪共享为何会出现伪共享怎么避免伪共享"><a class="markdownIt-Anchor" href="#什么是伪共享为何会出现伪共享怎么避免伪共享">#</a> 什么是伪共享？为何会出现伪共享？怎么避免伪共享？</h2><h3 id="什么是伪共享"><a class="markdownIt-Anchor" href="#什么是伪共享">#</a> 什么是伪共享？</h3><p>计算机系统中为了解决主内存与 CPU 运行速度的差距，在 CPU 与主内存之间添加了一级或者多级高速缓冲存储器（Cache），这个 Cache 一般是集成到 CPU 内部的，所以也叫 CPU Cache，如下图是两级 cache 结构：</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817175342.jpg" alt="img"></p><p>Cache 内部是按行存储的，其中每一行称为一个 cache 行，cache 行是 Cache 与主内存进行数据交换的单位，cache 行的大小一般为 2 的幂次数字节。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817175402.png" alt="img"></p><p>当 CPU 访问某一个变量时候，首先会去看 CPU Cache 内是否有该变量，如果有则直接从中获取，否者就去主内存里面获取该变量，然后把该变量所在内存区域的一个 Cache 行大小的内存拷贝到 Cache（cache 行是 Cache 与主内存进行数据交换的单位）。由于存放到 Cache 行的的是内存块而不是单个变量，所以可能会把多个变量存放到了一个 cache 行。当多个线程同时修改一个缓存行里面的多个变量时候，由于同时只能有一个线程操作缓存行，所以相比每个变量放到一个缓存行性能会有所下降，这就是伪共享。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817175419.png" alt="img"></p><p>如上图变量 x,y 同时被放到了 CPU 的一级和二级缓存，当线程 1 使用 CPU1 对变量 x 进行更新时候，首先会修改 cpu1 的一级缓存变量 x 所在缓存行，这时候缓存一致性协议会导致 cpu2 中变量 x 对应的缓存行失效，那么线程 2 写入变量 x 的时候就只能去二级缓存去查找，这就破坏了一级缓存，而一级缓存比二级缓存更快。更坏的情况下如果 cpu 只有一级缓存，那么会导致频繁的直接访问主内存。</p><h3 id="为何会出现伪共享"><a class="markdownIt-Anchor" href="#为何会出现伪共享">#</a> 为何会出现伪共享</h3><p>伪共享的产生是因为多个变量被放入了一个缓存行，并且多个线程同时去写入缓存行中不同变量。那么为何多个变量会被放入一个缓存行那。其实是因为 Cache 与内存交换数据的单位就是 Cache，当 CPU 要访问的变量没有在 Cache 命中时候，根据程序运行的局部性原理会把该变量在内存中大小为 Cache 行的内存放如缓存行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">long a;</span><br><span class="line">long b;</span><br><span class="line">long c;</span><br><span class="line">long d;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上代码，声明了四个 long 变量，假设 cache 行的大小为 32 个字节，那么当 cpu 访问变量 a 时候发现该变量没有在 cache 命中，那么就会去主内存把变量 a 以及内存地址附近的 b,c,d 放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中，当创建数组时候，数组里面的多个元素就会被放入到同一个缓存行。那么单线程下多个变量放入缓存行对性能有影响？其实正常情况下单线程访问时候由于数组元素被放入到了一个或者多个 cache 行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p><h4 id="如何解决伪共享"><a class="markdownIt-Anchor" href="#如何解决伪共享">#</a> 如何解决伪共享</h4><p>@Contended 注解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="line">public @interface Contended &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Contended 注解可以用于类型上和属性上，加上这个注解之后虚拟机会自动进行填充，从而避免伪共享。这个注解在 Java8 ConcurrentHashMap、ForkJoinPool 和 Thread 等类中都有应用。我们来看一下 Java8 中 ConcurrentHashMap 中如何运用 Contended 这个注解来解决伪共享问题。以下说的 ConcurrentHashMap 都是 Java8 版本。</p><p><strong>注意</strong>：在 Java8 中提供了 **@sun.misc.Contended<strong> 来避免伪共享时，在运行时需要设置 JVM 启动参数</strong> - XX:-RestrictContended** 否则可能不生效。</p><p>缓存行填充的威力</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 缓存行测试</span><br><span class="line"> */</span><br><span class="line">public class CacheLineTest &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 是否启用缓存行填充</span><br><span class="line">     */</span><br><span class="line">    private final boolean isDataPadding = false;</span><br><span class="line">    /**</span><br><span class="line">     * 正常定义的变量</span><br><span class="line">     */</span><br><span class="line">    private volatile long x = 0;</span><br><span class="line">    private volatile long y = 0;</span><br><span class="line">    private volatile long z = 0;</span><br><span class="line">    /**</span><br><span class="line">     * 通过缓存行填充的变量</span><br><span class="line">     */</span><br><span class="line">    private volatile VolatileData volatileDataX = new VolatileData(0);</span><br><span class="line">    private volatile VolatileData volatileDataY = new VolatileData(0);</span><br><span class="line">    private volatile VolatileData volatileDataZ = new VolatileData(0);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 循环次数</span><br><span class="line">     */</span><br><span class="line">    private final long size = 100000000;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行累加操作</span><br><span class="line">     */</span><br><span class="line">    public void accumulationX() &#123;</span><br><span class="line">        //计算耗时</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        long value = 0;</span><br><span class="line">        //循环累加</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            //使用缓存行填充的方式</span><br><span class="line">            if (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataX.accumulationAdd();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //不使用缓存行填充的方式 因为时单线程操作不需要加锁</span><br><span class="line">                value = (++x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //打印</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        //打印耗时</span><br><span class="line">        System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行累加操作</span><br><span class="line">     */</span><br><span class="line">    public void accumulationY() &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        long value = 0;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataY.accumulationAdd();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                value = ++y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行累加操作</span><br><span class="line">     */</span><br><span class="line">    public void accumulationZ() &#123;</span><br><span class="line">        long currentTime = System.currentTimeMillis();</span><br><span class="line">        long value = 0;</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            if (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataZ.accumulationAdd();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                value = ++z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(&quot;耗时：&quot; + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建对象</span><br><span class="line">        CacheLineTest cacheRowTest = new CacheLineTest();</span><br><span class="line">        //创建线程池</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class="line">        //启动三个线程个调用他们各自的方法</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationX());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationY());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationZ());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当多个线程同时对共享的缓存行进行写操作的时候，因为缓存系统自身的缓存一致性原则，会引发伪共享问题，解决的常用办法是将共享变量根据缓存行大小进行补充对齐，使其加载到缓存时能够独享缓存行，避免与其他共享变量存储在同一个缓存行。</p><h2 id="什么是跳表"><a class="markdownIt-Anchor" href="#什么是跳表">#</a> 什么是跳表？</h2><p>跳表是一个随机化的数据结构，实质就是一种可以进行<strong>二分</strong>查找的<strong>有序链表</strong>。</p><p>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p><p>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817181502" alt="图片"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 数据节点，典型的单链表结构</span><br><span class="line">   static final class Node&lt;K,V&gt; &#123;</span><br><span class="line">       final K key;</span><br><span class="line">       // 注意：这里value的类型是Object，而不是V</span><br><span class="line">       // 在删除元素的时候value会指向当前元素本身</span><br><span class="line">       volatile Object value;</span><br><span class="line">       volatile Node&lt;K,V&gt; next;</span><br><span class="line">   </span><br><span class="line">       Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.key = key;</span><br><span class="line">           this.value = value;</span><br><span class="line">           this.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       Node(Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.key = null;</span><br><span class="line">           this.value = this; // 当前元素本身(marker)</span><br><span class="line">           this.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 索引节点，存储着对应的node值，及向下和向右的索引指针</span><br><span class="line">   static class Index&lt;K,V&gt; &#123;</span><br><span class="line">       final Node&lt;K,V&gt; node;</span><br><span class="line">       final Index&lt;K,V&gt; down;</span><br><span class="line">       volatile Index&lt;K,V&gt; right;</span><br><span class="line">   </span><br><span class="line">       Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123;</span><br><span class="line">           this.node = node;</span><br><span class="line">           this.down = down;</span><br><span class="line">           this.right = right;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 头索引节点，继承自Index，并扩展一个level字段，用于记录索引的层级</span><br><span class="line">   static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123;</span><br><span class="line">       final int level;</span><br><span class="line">   </span><br><span class="line">       HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123;</span><br><span class="line">           super(node, down, right);</span><br><span class="line">           this.level = level;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）Node，数据节点，存储数据的节点，典型的单链表结构；</p><p>（2）Index，索引节点，存储着对应的 node 值，及向下和向右的索引指针；</p><p>（3）HeadIndex，头索引节点，继承自 Index，并扩展一个 level 字段，用于记录索引的层级；</p><h2 id="concurrentskiplist是有序的吗"><a class="markdownIt-Anchor" href="#concurrentskiplist是有序的吗">#</a> ConcurrentSkipList 是有序的吗？</h2><p>ConcurrentSkipListMap 的 key 是有序的。</p><h2 id="concurrentskiplist是如何保证线程安全的"><a class="markdownIt-Anchor" href="#concurrentskiplist是如何保证线程安全的">#</a> ConcurrentSkipList 是如何保证线程安全的？</h2><h2 id="concurrentskiplist插入-删除-查询元素的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#concurrentskiplist插入-删除-查询元素的时间复杂度各是多少">#</a> ConcurrentSkipList 插入、删除、查询元素的时间复杂度各是多少？</h2><p>跳表查询、插入、删除的时间复杂度为 O (log n)，与平衡二叉树接近；</p><h3 id="添加"><a class="markdownIt-Anchor" href="#添加">#</a> 添加</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        // 不能存储value为null的元素</span><br><span class="line">        // 因为value为null标记该元素被删除（后面会看到）</span><br><span class="line">        if (value == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">    </span><br><span class="line">        // 调用doPut()方法添加元素</span><br><span class="line">        return doPut(key, value, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private V doPut(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        // 添加元素后存储在z中</span><br><span class="line">        Node&lt;K,V&gt; z;             // added node</span><br><span class="line">        // key也不能为null</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">    </span><br><span class="line">        // Part I：找到目标节点的位置并插入</span><br><span class="line">        // 这里的目标节点是数据节点，也就是最底层的那条链</span><br><span class="line">        // 自旋</span><br><span class="line">        outer: for (;;) &#123;</span><br><span class="line">            // 寻找目标节点之前最近的一个索引对应的数据节点，存储在b中，b=before</span><br><span class="line">            // 并把b的下一个数据节点存储在n中，n=next</span><br><span class="line">            // 为了便于描述，我这里把b叫做当前节点，n叫做下一个节点</span><br><span class="line">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                // 如果下一个节点不为空</span><br><span class="line">                // 就拿其key与目标节点的key比较，找到目标节点应该插入的位置</span><br><span class="line">                if (n != null) &#123;</span><br><span class="line">                    // v=value，存储节点value值</span><br><span class="line">                    // c=compare，存储两个节点比较的大小</span><br><span class="line">                    Object v; int c;</span><br><span class="line">                    // n的下一个数据节点，也就是b的下一个节点的下一个节点（孙子节点）</span><br><span class="line">                    Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                    // 如果n不为b的下一个节点</span><br><span class="line">                    // 说明有其它线程修改了数据，则跳出内层循环</span><br><span class="line">                    // 也就是回到了外层循环自旋的位置，从头来过</span><br><span class="line">                    if (n != b.next)               // inconsistent read</span><br><span class="line">                        break;</span><br><span class="line">                    // 如果n的value值为空，说明该节点已删除，协助删除节点</span><br><span class="line">                    if ((v = n.value) == null) &#123;   // n is deleted</span><br><span class="line">                        // todo 这里为啥会协助删除？后面讲</span><br><span class="line">                        n.helpDelete(b, f);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果b的值为空或者v等于n，说明b已被删除</span><br><span class="line">                    // 这时候n就是marker节点，那b就是被删除的那个</span><br><span class="line">                    if (b.value == null || v == n) // b is deleted</span><br><span class="line">                        break;</span><br><span class="line">                    // 如果目标key与下一个节点的key大</span><br><span class="line">                    // 说明目标元素所在的位置还在下一个节点的后面</span><br><span class="line">                    if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123;</span><br><span class="line">                        // 就把当前节点往后移一位</span><br><span class="line">                        // 同样的下一个节点也往后移一位</span><br><span class="line">                        // 再重新检查新n是否为空，它与目标key的关系</span><br><span class="line">                        b = n;</span><br><span class="line">                        n = f;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果比较时发现下一个节点的key与目标key相同</span><br><span class="line">                    // 说明链表中本身就存在目标节点</span><br><span class="line">                    if (c == 0) &#123;</span><br><span class="line">                        // 则用新值替换旧值，并返回旧值（onlyIfAbsent=false）</span><br><span class="line">                        if (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                            @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                            return vv;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 如果替换旧值时失败，说明其它线程先一步修改了值，从头来过</span><br><span class="line">                        break; // restart if lost race to replace value</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果c&lt;0，就往下走，也就是找到了目标节点的位置</span><br><span class="line">                    // else c &lt; 0; fall through</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                // 有两种情况会到这里</span><br><span class="line">                // 一是到链表尾部了，也就是n为null了</span><br><span class="line">                // 二是找到了目标节点的位置，也就是上面的c&lt;0</span><br><span class="line">    </span><br><span class="line">                // 新建目标节点，并赋值给z</span><br><span class="line">                // 这里把n作为新节点的next</span><br><span class="line">                // 如果到链表尾部了，n为null，这毫无疑问</span><br><span class="line">                // 如果c&lt;0，则n的key比目标key大，相妆于在b和n之间插入目标节点z</span><br><span class="line">                z = new Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">                // 原子更新b的下一个节点为目标节点z</span><br><span class="line">                if (!b.casNext(n, z))</span><br><span class="line">                    // 如果更新失败，说明其它线程先一步修改了值，从头来过</span><br><span class="line">                    break;         // restart if lost race to append to b</span><br><span class="line">                // 如果更新成功，跳出自旋状态</span><br><span class="line">                break outer;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 经过Part I，目标节点已经插入到有序链表中了</span><br><span class="line">    </span><br><span class="line">        // Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引</span><br><span class="line">    </span><br><span class="line">        // 取个随机数</span><br><span class="line">        int rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">        // 0x80000001展开为二进制为10000000000000000000000000000001</span><br><span class="line">        // 只有两头是1</span><br><span class="line">        // 这里(rnd &amp; 0x80000001) == 0</span><br><span class="line">        // 相当于排除了负数（负数最高位是1），排除了奇数（奇数最低位是1）</span><br><span class="line">        // 只有最高位最低位都不为1的数跟0x80000001做&amp;操作才会为0</span><br><span class="line">        // 也就是正偶数</span><br><span class="line">        if ((rnd &amp; 0x80000001) == 0) &#123; // test highest and lowest bits</span><br><span class="line">            // 默认level为1，也就是只要到这里了就会至少建立一层索引</span><br><span class="line">            int level = 1, max;</span><br><span class="line">            // 随机数从最低位的第二位开始，有几个连续的1则level就加几</span><br><span class="line">            // 因为最低位肯定是0，正偶数嘛</span><br><span class="line">            // 比如，1100110，level就加2</span><br><span class="line">            while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</span><br><span class="line">                ++level;</span><br><span class="line">    </span><br><span class="line">            // 用于记录目标节点建立的最高的那层索引节点</span><br><span class="line">            Index&lt;K,V&gt; idx = null;</span><br><span class="line">            // 取头索引节点（这是最高层的头索引节点）</span><br><span class="line">            HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">            // 如果生成的层数小于等于当前最高层的层级</span><br><span class="line">            // 也就是跳表的高度不会超过现有高度</span><br><span class="line">            if (level &lt;= (max = h.level)) &#123;</span><br><span class="line">                // 从第一层开始建立一条竖直的索引链表</span><br><span class="line">                // 这条链表使用down指针连接起来</span><br><span class="line">                // 每个索引节点里面都存储着目标节点这个数据节点</span><br><span class="line">                // 最后idx存储的是这条索引链表的最高层节点</span><br><span class="line">                for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                    idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123; // try to grow by one level</span><br><span class="line">                // 如果新的层数超过了现有跳表的高度</span><br><span class="line">                // 则最多只增加一层</span><br><span class="line">                // 比如现在只有一层索引，那下一次最多增加到两层索引，增加多了也没有意义</span><br><span class="line">                level = max + 1; // hold in array and later pick the one to use</span><br><span class="line">                // idxs用于存储目标节点建立的竖起索引的所有索引节点</span><br><span class="line">                // 其实这里直接使用idx这个最高节点也是可以完成的</span><br><span class="line">                // 只是用一个数组存储所有节点要方便一些</span><br><span class="line">                // 注意，这里数组0号位是没有使用的</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)Index&lt;K,V&gt;[] idxs =</span><br><span class="line">                        (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];</span><br><span class="line">                // 从第一层开始建立一条竖的索引链表（跟上面一样，只是这里顺便把索引节点放到数组里面了）</span><br><span class="line">                for (int i = 1; i &lt;= level; ++i)</span><br><span class="line">                    idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);</span><br><span class="line">    </span><br><span class="line">                // 自旋</span><br><span class="line">                for (;;) &#123;</span><br><span class="line">                    // 旧的最高层头索引节点</span><br><span class="line">                    h = head;</span><br><span class="line">                    // 旧的最高层级</span><br><span class="line">                    int oldLevel = h.level;</span><br><span class="line">                    // 再次检查，如果旧的最高层级已经不比新层级矮了</span><br><span class="line">                    // 说明有其它线程先一步修改了值，从头来过</span><br><span class="line">                    if (level &lt;= oldLevel) // lost race to add level</span><br><span class="line">                        break;</span><br><span class="line">                    // 新的最高层头索引节点</span><br><span class="line">                    HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                    // 头节点指向的数据节点</span><br><span class="line">                    Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                    // 超出的部分建立新的头索引节点</span><br><span class="line">                    for (int j = oldLevel+1; j &lt;= level; ++j)</span><br><span class="line">                        newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                    // 原子更新头索引节点</span><br><span class="line">                    if (casHead(h, newh)) &#123;</span><br><span class="line">                        // h指向新的最高层头索引节点</span><br><span class="line">                        h = newh;</span><br><span class="line">                        // 把level赋值为旧的最高层级的</span><br><span class="line">                        // idx指向的不是最高的索引节点了</span><br><span class="line">                        // 而是与旧最高层平齐的索引节点</span><br><span class="line">                        idx = idxs[level = oldLevel];</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 经过上面的步骤，有两种情况</span><br><span class="line">            // 一是没有超出高度，新建一条目标节点的索引节点链</span><br><span class="line">            // 二是超出了高度，新建一条目标节点的索引节点链，同时最高层头索引节点同样往上长</span><br><span class="line">    </span><br><span class="line">            // Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起</span><br><span class="line">    </span><br><span class="line">            // 这时level是等于旧的最高层级的，自旋</span><br><span class="line">            splice: for (int insertionLevel = level;;) &#123;</span><br><span class="line">                // h为最高头索引节点</span><br><span class="line">                int j = h.level;</span><br><span class="line">    </span><br><span class="line">                // 从头索引节点开始遍历</span><br><span class="line">                // 为了方便，这里叫q为当前节点，r为右节点，d为下节点，t为目标节点相应层级的索引</span><br><span class="line">                for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">                    // 如果遍历到了最右边，或者最下边，</span><br><span class="line">                    // 也就是遍历到头了，则退出外层循环</span><br><span class="line">                    if (q == null || t == null)</span><br><span class="line">                        break splice;</span><br><span class="line">                    // 如果右节点不为空</span><br><span class="line">                    if (r != null) &#123;</span><br><span class="line">                        // n是右节点的数据节点，为了方便，这里直接叫右节点的值</span><br><span class="line">                        Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                        // 比较目标key与右节点的值</span><br><span class="line">                        int c = cpr(cmp, key, n.key);</span><br><span class="line">                        // 如果右节点的值为空了，则表示此节点已删除</span><br><span class="line">                        if (n.value == null) &#123;</span><br><span class="line">                            // 则把右节点删除</span><br><span class="line">                            if (!q.unlink(r))</span><br><span class="line">                                // 如果删除失败，说明有其它线程先一步修改了，从头来过</span><br><span class="line">                                break;</span><br><span class="line">                            // 删除成功后重新取右节点</span><br><span class="line">                            r = q.right;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 如果比较c&gt;0，表示目标节点还要往右</span><br><span class="line">                        if (c &gt; 0) &#123;</span><br><span class="line">                            // 则把当前节点和右节点分别右移</span><br><span class="line">                            q = r;</span><br><span class="line">                            r = r.right;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    // 到这里说明已经到当前层级的最右边了</span><br><span class="line">                    // 这里实际是会先走第二个if</span><br><span class="line">    </span><br><span class="line">                    // 第一个if</span><br><span class="line">                    // j与insertionLevel相等了</span><br><span class="line">                    // 实际是先走的第二个if，j自减后应该与insertionLevel相等</span><br><span class="line">                    if (j == insertionLevel) &#123;</span><br><span class="line">                        // 这里是真正连右指针的地方</span><br><span class="line">                        if (!q.link(r, t))</span><br><span class="line">                            // 连接失败，从头来过</span><br><span class="line">                            break; // restart</span><br><span class="line">                        // t节点的值为空，可能是其它线程删除了这个元素</span><br><span class="line">                        if (t.node.value == null) &#123;</span><br><span class="line">                            // 这里会去协助删除元素</span><br><span class="line">                            findNode(key);</span><br><span class="line">                            break splice;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 当前层级右指针连接完毕，向下移一层继续连接</span><br><span class="line">                        // 如果移到了最下面一层，则说明都连接完成了，退出外层循环</span><br><span class="line">                        if (--insertionLevel == 0)</span><br><span class="line">                            break splice;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    // 第二个if</span><br><span class="line">                    // j先自减1，再与两个level比较</span><br><span class="line">                    // j、insertionLevel和t(idx)三者是对应的，都是还未把右指针连好的那个层级</span><br><span class="line">                    if (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                        // t往下移</span><br><span class="line">                        t = t.down;</span><br><span class="line">    </span><br><span class="line">                    // 当前层级到最右边了</span><br><span class="line">                    // 那只能往下一层级去走了</span><br><span class="line">                    // 当前节点下移</span><br><span class="line">                    // 再取相应的右节点</span><br><span class="line">                    q = q.down;</span><br><span class="line">                    r = q.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 寻找目标节点之前最近的一个索引对应的数据节点</span><br><span class="line">    private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) &#123;</span><br><span class="line">        // key不能为空</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException(); // don&#x27;t postpone errors</span><br><span class="line">        // 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 从最高层头索引节点开始查找，先向右，再向下</span><br><span class="line">            // 直到找到目标位置之前的那个索引</span><br><span class="line">            for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">                // 如果右节点不为空</span><br><span class="line">                if (r != null) &#123;</span><br><span class="line">                    // 右节点对应的数据节点，为了方便，我们叫右节点的值</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    K k = n.key;</span><br><span class="line">                    // 如果右节点的value为空</span><br><span class="line">                    // 说明其它线程把这个节点标记为删除了</span><br><span class="line">                    // 则协助删除</span><br><span class="line">                    if (n.value == null) &#123;</span><br><span class="line">                        if (!q.unlink(r))</span><br><span class="line">                            // 如果删除失败</span><br><span class="line">                            // 说明其它线程先删除了，从头来过</span><br><span class="line">                            break;           // restart</span><br><span class="line">                        // 删除之后重新读取右节点</span><br><span class="line">                        r = q.right;         // reread r</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果目标key比右节点还大，继续向右寻找</span><br><span class="line">                    if (cpr(cmp, key, k) &gt; 0) &#123;</span><br><span class="line">                        // 往右移</span><br><span class="line">                        q = r;</span><br><span class="line">                        // 重新取右节点</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果c&lt;0，说明不能再往右了</span><br><span class="line">                &#125;</span><br><span class="line">                // 到这里说明当前层级已经到最右了</span><br><span class="line">                // 两种情况：一是r==null，二是c&lt;0</span><br><span class="line">                // 再从下一级开始找</span><br><span class="line">    </span><br><span class="line">                // 如果没有下一级了，就返回这个索引对应的数据节点</span><br><span class="line">                if ((d = q.down) == null)</span><br><span class="line">                    return q.node;</span><br><span class="line">    </span><br><span class="line">                // 往下移</span><br><span class="line">                q = d;</span><br><span class="line">                // 重新取右节点</span><br><span class="line">                r = d.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Node.class中的方法，协助删除元素</span><br><span class="line">    void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        /*</span><br><span class="line">         * Rechecking links and then doing only one of the</span><br><span class="line">         * help-out stages per call tends to minimize CAS</span><br><span class="line">         * interference among helping threads.</span><br><span class="line">         */</span><br><span class="line">        // 这里的调用者this==n，三者关系是b-&gt;n-&gt;f</span><br><span class="line">        if (f == next &amp;&amp; this == b.next) &#123;</span><br><span class="line">            // 将n的值设置为null后，会先把n的下个节点设置为marker节点</span><br><span class="line">            // 这个marker节点的值是它自己</span><br><span class="line">            // 这里如果不是它自己说明marker失败了，重新marker</span><br><span class="line">            if (f == null || f.value != f) // not already marked</span><br><span class="line">                casNext(f, new Node&lt;K,V&gt;(f));</span><br><span class="line">            else</span><br><span class="line">                // marker过了，就把b的下个节点指向marker的下个节点</span><br><span class="line">                b.casNext(this, f.next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Index.class中的方法，删除succ节点</span><br><span class="line">    final boolean unlink(Index&lt;K,V&gt; succ) &#123;</span><br><span class="line">        // 原子更新当前节点指向下一个节点的下一个节点</span><br><span class="line">        // 也就是删除下一个节点</span><br><span class="line">        return node.value != null &amp;&amp; casRight(succ, succ.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Index.class中的方法，在当前节点与succ之间插入newSucc节点</span><br><span class="line">    final boolean link(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc) &#123;</span><br><span class="line">        // 在当前节点与下一个节点中间插入一个节点</span><br><span class="line">        Node&lt;K,V&gt; n = node;</span><br><span class="line">        // 新节点指向当前节点的下一个节点</span><br><span class="line">        newSucc.right = succ;</span><br><span class="line">        // 原子更新当前节点的下一个节点指向新节点</span><br><span class="line">        return n.value != null &amp;&amp; casRight(succ, newSucc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们这里把整个插入过程分成三个部分：</p><p>Part I：找到目标节点的位置并插入</p><p>（1）这里的目标节点是数据节点，也就是最底层的那条链；</p><p>（2）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p><p>（3）从这个数据节点开始往后遍历，直到找到目标节点应该插入的位置；</p><p>（4）如果这个位置有元素，就更新其值（onlyIfAbsent=false）；</p><p>（5）如果这个位置没有元素，就把目标节点插入；</p><p>（6）至此，目标节点已经插入到最底层的数据节点链表中了；</p><p>Part II：随机决定是否需要建立索引及其层次，如果需要则建立自上而下的索引</p><p>（1）取个随机数 rnd，计算 (rnd &amp; 0x80000001)；</p><p>（2）如果不等于 0，结束插入过程，也就是不需要创建索引，返回；</p><p>（3）如果等于 0，才进入创建索引的过程（只要正偶数才会等于 0）；</p><p>（4）计算 <code>while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)</code> ，决定层级数，level 从 1 开始；</p><p>（5）如果算出来的层级不高于现有最高层级，则直接建立一条竖直的索引链表（只有 down 有值），并结束 Part II；</p><p>（6）如果算出来的层级高于现有最高层级，则新的层级只能比现有最高层级多 1；</p><p>（7）同样建立一条竖直的索引链表（只有 down 有值）；</p><p>（8）将头索引也向上增加到相应的高度，结束 Part II；</p><p>（9）也就是说，如果层级不超过现有高度，只建立一条索引链，否则还要额外增加头索引链的高度（脑补一下，后面举例说明）；</p><p>Part III：将新建的索引节点（包含头索引节点）与其它索引节点通过右指针连接在一起（补上 right 指针）</p><p>（1）从最高层级的头索引节点开始，向右遍历，找到目标索引节点的位置；</p><p>（2）如果当前层有目标索引，则把目标索引插入到这个位置，并把目标索引前一个索引向下移一个层级；</p><p>（3）如果当前层没有目标索引，则把目标索引位置前一个索引向下移一个层级；</p><p>（4）同样地，再向右遍历，寻找新的层级中目标索引的位置，回到第（2）步；</p><p>（5）依次循环找到所有层级目标索引的位置并把它们插入到横向的索引链表中；</p><p>总结起来，一共就是三大步：</p><p>（1）插入目标节点到数据节点链表中；</p><p>（2）建立竖直的 down 链表；</p><p>（3）建立横向的 right 链表；</p><h3 id="删除"><a class="markdownIt-Anchor" href="#删除">#</a> 删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">        return doRemove(key, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    final V doRemove(Object key, Object value) &#123;</span><br><span class="line">        // key不为空</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">        // 自旋</span><br><span class="line">        outer: for (;;) &#123;</span><br><span class="line">            // 寻找目标节点之前的最近的索引节点对应的数据节点</span><br><span class="line">            // 为了方便，这里叫b为当前节点，n为下一个节点，f为下下个节点</span><br><span class="line">            for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">                Object v; int c;</span><br><span class="line">                // 整个链表都遍历完了也没找到目标节点，退出外层循环</span><br><span class="line">                if (n == null)</span><br><span class="line">                    break outer;</span><br><span class="line">                // 下下个节点</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                // 再次检查</span><br><span class="line">                // 如果n不是b的下一个节点了</span><br><span class="line">                // 说明有其它线程先一步修改了，从头来过</span><br><span class="line">                if (n != b.next)                    // inconsistent read</span><br><span class="line">                    break;</span><br><span class="line">                // 如果下个节点的值奕为null了</span><br><span class="line">                // 说明有其它线程标记该元素为删除状态了</span><br><span class="line">                if ((v = n.value) == null) &#123;        // n is deleted</span><br><span class="line">                    // 协助删除</span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果b的值为空或者v等于n，说明b已被删除</span><br><span class="line">                // 这时候n就是marker节点，那b就是被删除的那个</span><br><span class="line">                if (b.value == null || v == n)      // b is deleted</span><br><span class="line">                    break;</span><br><span class="line">                // 如果c&lt;0，说明没找到元素，退出外层循环</span><br><span class="line">                if ((c = cpr(cmp, key, n.key)) &lt; 0)</span><br><span class="line">                    break outer;</span><br><span class="line">                // 如果c&gt;0，说明还没找到，继续向右找</span><br><span class="line">                if (c &gt; 0) &#123;</span><br><span class="line">                    // 当前节点往后移</span><br><span class="line">                    b = n;</span><br><span class="line">                    // 下一个节点往后移</span><br><span class="line">                    n = f;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                // c=0，说明n就是要找的元素</span><br><span class="line">                // 如果value不为空且不等于找到元素的value，不需要删除，退出外层循环</span><br><span class="line">                if (value != null &amp;&amp; !value.equals(v))</span><br><span class="line">                    break outer;</span><br><span class="line">                // 如果value为空，或者相等</span><br><span class="line">                // 原子标记n的value值为空</span><br><span class="line">                if (!n.casValue(v, null))</span><br><span class="line">                    // 如果删除失败，说明其它线程先一步修改了，从头来过</span><br><span class="line">                    break;</span><br><span class="line">    </span><br><span class="line">                // P.S.到了这里n的值肯定是设置成null了</span><br><span class="line">    </span><br><span class="line">                // 关键！！！！</span><br><span class="line">                // 让n的下一个节点指向一个market节点</span><br><span class="line">                // 这个market节点的key为null，value为marker自己，next为n的下个节点f</span><br><span class="line">                // 或者让b的下一个节点指向下下个节点</span><br><span class="line">                // 注意：这里是或者||，因为两个CAS不能保证都成功，只能一个一个去尝试</span><br><span class="line">                // 这里有两层意思：</span><br><span class="line">                // 一是如果标记market成功，再尝试将b的下个节点指向下下个节点，如果第二步失败了，进入条件，如果成功了就不用进入条件了</span><br><span class="line">                // 二是如果标记market失败了，直接进入条件</span><br><span class="line">                if (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                    // 通过findNode()重试删除（里面有个helpDelete()方法）</span><br><span class="line">                    findNode(key);                  // retry via findNode</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 上面两步操作都成功了，才会进入这里，不太好理解，上面两个条件都有非&quot;!&quot;操作</span><br><span class="line">                    // 说明节点已经删除了，通过findPredecessor()方法删除索引节点</span><br><span class="line">                    // findPredecessor()里面有unlink()操作</span><br><span class="line">                    findPredecessor(key, cmp);      // clean index</span><br><span class="line">                    // 如果最高层头索引节点没有右节点，则跳表的高度降级</span><br><span class="line">                    if (head.right == null)</span><br><span class="line">                        tryReduceLevel();</span><br><span class="line">                &#125;</span><br><span class="line">                // 返回删除的元素值</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                return vv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p><p>（2）从这个数据节点开始往后遍历，直到找到目标节点的位置；</p><p>（3）如果这个位置没有元素，直接返回 null，表示没有要删除的元素；</p><p>（4）如果这个位置有元素，先通过 <code>n.casValue(v, null)</code>  原子更新把其 value 设置为 null；</p><p>（5）通过 <code>n.appendMarker(f)</code>  在当前元素后面添加一个 marker 元素标记当前元素是要删除的元素；</p><p>（6）通过 <code>b.casNext(n, f)</code>  尝试删除元素；</p><p>（7）如果上面两步中的任意一步失败了都通过 <code>findNode(key)</code>  中的 <code>n.helpDelete(b, f)</code>  再去不断尝试删除；</p><p>（8）如果上面两步都成功了，再通过 <code>findPredecessor(key, cmp)</code>  中的 <code>q.unlink(r)</code>  删除索引节点；</p><p>（9）如果 head 的 right 指针指向了 null，则跳表高度降级；</p><h3 id="查询"><a class="markdownIt-Anchor" href="#查询">#</a> 查询</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">       return doGet(key);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private V doGet(Object key) &#123;</span><br><span class="line">       // key不为空</span><br><span class="line">       if (key == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       Comparator&lt;? super K&gt; cmp = comparator;</span><br><span class="line">       // 自旋</span><br><span class="line">       outer: for (;;) &#123;</span><br><span class="line">           // 寻找目标节点之前最近的索引对应的数据节点</span><br><span class="line">           // 为了方便，这里叫b为当前节点，n为下个节点，f为下下个节点</span><br><span class="line">           for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">               Object v; int c;</span><br><span class="line">               // 如果链表到头还没找到元素，则跳出外层循环</span><br><span class="line">               if (n == null)</span><br><span class="line">                   break outer;</span><br><span class="line">               // 下下个节点</span><br><span class="line">               Node&lt;K,V&gt; f = n.next;</span><br><span class="line">               // 如果不一致读，从头来过</span><br><span class="line">               if (n != b.next)                // inconsistent read</span><br><span class="line">                   break;</span><br><span class="line">               // 如果n的值为空，说明节点已被其它线程标记为删除</span><br><span class="line">               if ((v = n.value) == null) &#123;    // n is deleted</span><br><span class="line">                   // 协助删除，再重试</span><br><span class="line">                   n.helpDelete(b, f);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">               // 如果b的值为空或者v等于n，说明b已被删除</span><br><span class="line">               // 这时候n就是marker节点，那b就是被删除的那个</span><br><span class="line">               if (b.value == null || v == n)  // b is deleted</span><br><span class="line">                   break;</span><br><span class="line">               // 如果c==0，说明找到了元素，就返回元素值</span><br><span class="line">               if ((c = cpr(cmp, key, n.key)) == 0) &#123;</span><br><span class="line">                   @SuppressWarnings(&quot;unchecked&quot;) V vv = (V)v;</span><br><span class="line">                   return vv;</span><br><span class="line">               &#125;</span><br><span class="line">               // 如果c&lt;0，说明没找到元素</span><br><span class="line">               if (c &lt; 0)</span><br><span class="line">                   break outer;</span><br><span class="line">               // 如果c&gt;0，说明还没找到，继续寻找</span><br><span class="line">               // 当前节点往后移</span><br><span class="line">               b = n;</span><br><span class="line">               // 下一个节点往后移</span><br><span class="line">               n = f;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）寻找目标节点之前最近的一个索引对应的数据节点（数据节点都是在最底层的链表上）；</p><p>（2）从这个数据节点开始往后遍历，直到找到目标节点的位置；</p><p>（3）如果这个位置没有元素，直接返回 null，表示没有找到元素；</p><p>（4）如果这个位置有元素，返回元素的 value 值；</p><h2 id="concurrentskiplist的索引具有什么特性"><a class="markdownIt-Anchor" href="#concurrentskiplist的索引具有什么特性">#</a> ConcurrentSkipList 的索引具有什么特性？</h2><p>ConcurrentSkipListMap 提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中 Node 表示最底层的单链表有序节点、Index 表示为基于 Node 的索引层，HeadIndex 用来维护索引层次。到这里我们可以这样说 ConcurrentSkipListMap 是通过 HeadIndex 维护索引层次，通过 Index 从最上层开始往下层查找，一步一步缩小查询范围，最后到达最底层 Node 时，就只需要比较很小一部分数据了。<br>Index 提供了一个基于 Node 节点的索引 Node，一个指向下一个 Index 的 right，一个指向下层的 down 节点。</p><h2 id="为什么redis选择使用跳表而不是红黑树来实现有序集合"><a class="markdownIt-Anchor" href="#为什么redis选择使用跳表而不是红黑树来实现有序集合">#</a> 为什么 Redis 选择使用跳表而不是红黑树来实现有序集合？</h2><p>首先，我们来分析下 Redis 的有序集合支持的操作：</p><p>1）插入元素</p><p>2）删除元素</p><p>3）查找元素</p><p>4）有序输出所有元素</p><p>5）查找区间内所有元素</p><p>其中，前 4 项红黑树都可以完成，且时间复杂度与跳表一致。</p><p>但是，最后一项，红黑树的效率就没有跳表高了。</p><p>在跳表中，要查找区间的元素，我们只要定位到两个区间端点在最低层级的位置，然后按顺序遍历元素就可以了，非常高效。</p><p>而红黑树只能定位到端点后，再从首位置开始每次都要查找后继节点，相对来说是比较耗时的。</p><p>此外，跳表实现起来很容易且易读，红黑树实现起来相对困难，所以 Redis 选择使用跳表来实现有序集合。</p><h2 id="hashset怎么保证添加元素不重复"><a class="markdownIt-Anchor" href="#hashset怎么保证添加元素不重复">#</a> HashSet 怎么保证添加元素不重复？</h2><p>HashSet 内部使用 HashMap 的 key 存储元素，以此来保证元素不重复；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 内部使用HashMap</span><br><span class="line">private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line">// 虚拟对象，用来作为value放到map中</span><br><span class="line">private static final Object PRESENT = new Object();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hashset是有序的吗"><a class="markdownIt-Anchor" href="#hashset是有序的吗">#</a> HashSet 是有序的吗？</h2><p>HashSet 是无序的，因为 HashMap 的 key 是无序的；</p><h2 id="hashset是否允许null元素"><a class="markdownIt-Anchor" href="#hashset是否允许null元素">#</a> HashSet 是否允许 null 元素？</h2><p>HashSet 中允许有一个 null 元素，因为 HashMap 允许 key 为 null；</p><h2 id="set是否有get方法"><a class="markdownIt-Anchor" href="#set是否有get方法">#</a> Set 是否有 get () 方法？</h2><p>HashSet 是没有 get () 方法的，，因为 get 似乎没有意义，不像 List 那样可以按 index 获取元素。</p><p>这里只要一个检查元素是否存在的方法 contains ()，直接调用 map 的 containsKey () 方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">        return map.containsKey(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="hashset源码"><a class="markdownIt-Anchor" href="#hashset源码">#</a> HashSet 源码？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> package java.util;</span><br><span class="line">    </span><br><span class="line">import java.io.InvalidObjectException;</span><br><span class="line">import sun.misc.SharedSecrets;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">public class HashSet&lt;E&gt;</span><br><span class="line">        extends AbstractSet&lt;E&gt;</span><br><span class="line">        implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">    &#123;</span><br><span class="line">        static final long serialVersionUID = -5024744406713321676L;</span><br><span class="line">    </span><br><span class="line">        // 内部元素存储在HashMap中</span><br><span class="line">        private transient HashMap&lt;E,Object&gt; map;</span><br><span class="line">    </span><br><span class="line">        // 虚拟元素，用来存到map元素的value中的，没有实际意义</span><br><span class="line">        private static final Object PRESENT = new Object();</span><br><span class="line">    </span><br><span class="line">        // 空构造方法</span><br><span class="line">        public HashSet() &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 把另一个集合的元素全都添加到当前Set中</span><br><span class="line">        // 注意，这里初始化map的时候是计算了它的初始容量的</span><br><span class="line">        public HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 指定初始容量和装载因子</span><br><span class="line">        public HashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 只指定初始容量</span><br><span class="line">        public HashSet(int initialCapacity) &#123;</span><br><span class="line">            map = new HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // LinkedHashSet专用的方法</span><br><span class="line">        // dummy是没有实际意义的, 只是为了跟上上面那个操持方法签名不同而已</span><br><span class="line">        HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">            map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 迭代器</span><br><span class="line">        public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">            return map.keySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 元素个数</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return map.size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否为空</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            return map.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否包含某个元素</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return map.containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 添加元素</span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            return map.put(e, PRESENT)==null;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 删除元素</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return map.remove(o)==PRESENT;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 清空所有元素</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 克隆方法</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public Object clone() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();</span><br><span class="line">                newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">                return newSet;</span><br><span class="line">            &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">                throw new InternalError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 序列化写出方法</span><br><span class="line">        private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">            throws java.io.IOException &#123;</span><br><span class="line">            // 写出非static非transient属性</span><br><span class="line">            s.defaultWriteObject();</span><br><span class="line">    </span><br><span class="line">            // 写出map的容量和装载因子</span><br><span class="line">            s.writeInt(map.capacity());</span><br><span class="line">            s.writeFloat(map.loadFactor());</span><br><span class="line">    </span><br><span class="line">            // 写出元素个数</span><br><span class="line">            s.writeInt(map.size());</span><br><span class="line">    </span><br><span class="line">            // 遍历写出所有元素</span><br><span class="line">            for (E e : map.keySet())</span><br><span class="line">                s.writeObject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 序列化读入方法</span><br><span class="line">        private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">            throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">            // 读入非static非transient属性</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">    </span><br><span class="line">            // 读入容量, 并检查不能小于0</span><br><span class="line">            int capacity = s.readInt();</span><br><span class="line">            if (capacity &lt; 0) &#123;</span><br><span class="line">                throw new InvalidObjectException(&quot;Illegal capacity: &quot; +</span><br><span class="line">                                                 capacity);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 读入装载因子, 并检查不能小于等于0或者是NaN(Not a Number)</span><br><span class="line">            // java.lang.Float.NaN = 0.0f / 0.0f;</span><br><span class="line">            float loadFactor = s.readFloat();</span><br><span class="line">            if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">                throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                                 loadFactor);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 读入元素个数并检查不能小于0</span><br><span class="line">            int size = s.readInt();</span><br><span class="line">            if (size &lt; 0) &#123;</span><br><span class="line">                throw new InvalidObjectException(&quot;Illegal size: &quot; +</span><br><span class="line">                                                 size);</span><br><span class="line">            &#125;</span><br><span class="line">            // 根据元素个数重新设置容量</span><br><span class="line">            // 这是为了保证map有足够的容量容纳所有元素, 防止无意义的扩容</span><br><span class="line">            capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f),</span><br><span class="line">                    HashMap.MAXIMUM_CAPACITY);</span><br><span class="line">    </span><br><span class="line">            // 再次检查某些东西, 不重要的代码忽视掉</span><br><span class="line">            SharedSecrets.getJavaOISAccess()</span><br><span class="line">                         .checkArray(s, Map.Entry[].class, HashMap.tableSizeFor(capacity));</span><br><span class="line">    </span><br><span class="line">            // 创建map, 检查是不是LinkedHashSet类型</span><br><span class="line">            map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?</span><br><span class="line">                   new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">                   new HashMap&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line">    </span><br><span class="line">            // 读入所有元素, 并放入map中</span><br><span class="line">            for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    E e = (E) s.readObject();</span><br><span class="line">                map.put(e, PRESENT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 可分割的迭代器, 主要用于多线程并行迭代处理时使用</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            return new HashMap.KeySpliterator&lt;E,Object&gt;(map, 0, -1, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="linkedhashset的底层使用什么存储元素"><a class="markdownIt-Anchor" href="#linkedhashset的底层使用什么存储元素">#</a> LinkedHashSet 的底层使用什么存储元素？</h2><p>LinkedHashSet 的底层使用 LinkedHashMap 存储元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> package java.util;</span><br><span class="line">    </span><br><span class="line">// LinkedHashSet继承自HashSet</span><br><span class="line"> public class LinkedHashSet&lt;E&gt;</span><br><span class="line">        extends HashSet&lt;E&gt;</span><br><span class="line">        implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">        private static final long serialVersionUID = -2851667679971038690L;</span><br><span class="line">    </span><br><span class="line">        // 传入容量和装载因子</span><br><span class="line">        public LinkedHashSet(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">            super(initialCapacity, loadFactor, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 只传入容量, 装载因子默认为0.75</span><br><span class="line">        public LinkedHashSet(int initialCapacity) &#123;</span><br><span class="line">            super(initialCapacity, .75f, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 使用默认容量16, 默认装载因子0.75</span><br><span class="line">        public LinkedHashSet() &#123;</span><br><span class="line">            super(16, .75f, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 将集合c中的所有元素添加到LinkedHashSet中</span><br><span class="line">        // 好奇怪, 这里计算容量的方式又变了</span><br><span class="line">        // HashSet中使用的是Math.max((int) (c.size()/.75f) + 1, 16)</span><br><span class="line">        // 这一点有点不得其解, 是作者偷懒？</span><br><span class="line">        public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            super(Math.max(2*c.size(), 11), .75f, true);</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 可分割的迭代器, 主要用于多线程并行迭代处理时使用</span><br><span class="line">        @Override</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            return Spliterators.spliterator(this, Spliterator.DISTINCT | Spliterator.ORDERED);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="linkedhashset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#linkedhashset是有序的吗怎么个有序法">#</a> LinkedHashSet 是有序的吗？怎么个有序法？</h2><p>LinkedHashSet 是有序的，它是按照插入的顺序排序的。</p><h2 id="linkedhashset支持按元素访问顺序排序吗"><a class="markdownIt-Anchor" href="#linkedhashset支持按元素访问顺序排序吗">#</a> LinkedHashSet 支持按元素访问顺序排序吗？</h2><p>不支持</p><p>首先，LinkedHashSet 所有的构造方法都是调用 HashSet 的同一个构造方法，如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// HashSet的构造方法</span><br><span class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">            map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，通过调用 LinkedHashMap 的构造方法初始化 map，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public LinkedHashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">            super(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，这里把 accessOrder 写死为 false 了。</p><p>所以，LinkedHashSet 是不支持按访问顺序对元素排序的，只能按插入顺序排序。</p><h2 id="treeset真的是使用treemap来存储元素的吗"><a class="markdownIt-Anchor" href="#treeset真的是使用treemap来存储元素的吗">#</a> TreeSet 真的是使用 TreeMap 来存储元素的吗？</h2><p>通过源码分析我们知道 TreeSet 里面实际上是使用的 NavigableMap 来存储元素，虽然大部分时候这个 map 确实是 TreeMap，但不是所有时候都是 TreeMap。</p><p>因为有一个构造方法是 <code>TreeSet(NavigableMap&lt;E,Object&gt; m)</code> ，而且这是一个非 public 方法，通过调用关系我们可以发现这个构造方法都是在自己类中使用的，比如下面这个：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123;</span><br><span class="line">            return new TreeSet&lt;&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而这个 m 我们姑且认为它是 TreeMap，也就是调用 TreeMap 的 tailMap () 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) &#123;</span><br><span class="line">            return new AscendingSubMap&lt;&gt;(this,</span><br><span class="line">                                         false, fromKey, inclusive,</span><br><span class="line">                                         true,  null,    true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，返回的是 AscendingSubMap 对象，这个类的继承链是怎么样的呢？</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817183810.png" alt="202105091520593461.png"></p><p>可以看到，这个类并没有继承 TreeMap，不过通过源码分析也可以看出来这个类是组合了 TreeMap，也算和 TreeMap 有点关系，只是不是继承关系。</p><p>所以，TreeSet 的底层不完全是使用 TreeMap 来实现的，更准确地说，应该是 NavigableMap。</p><h2 id="treeset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#treeset是有序的吗怎么个有序法">#</a> TreeSet 是有序的吗？怎么个有序法？</h2><p>有序的，TreeSet 实现了 SortedSet 接口，它的有序性主要依赖于 NavigableMap 的有序性，而 NavigableMap 又继承自 SortedMap，这个接口的有序性是指按照 key 的自然排序保证的有序性，而 key 的自然排序又有两种实现方式，一种是 key 实现 Comparable 接口，一种是构造方法传入 Comparator 比较器。</p><h2 id="treeset和linkedhashset有何不同"><a class="markdownIt-Anchor" href="#treeset和linkedhashset有何不同">#</a> TreeSet 和 LinkedHashSet 有何不同？</h2><p>LinkedHashSet 并没有实现 SortedSet 接口，它的有序性主要依赖于 LinkedHashMap 的有序性，所以它的有序性是指按照插入顺序保证的有序性；</p><p>而 TreeSet 实现了 SortedSet 接口，它的有序性主要依赖于 NavigableMap 的有序性，而 NavigableMap 又继承自 SortedMap，这个接口的有序性是指按照 key 的自然排序保证的有序性，而 key 的自然排序又有两种实现方式，一种是 key 实现 Comparable 接口，一种是构造方法传入 Comparator 比较器。</p><h2 id="treeset和sortedset有什么区别和联系"><a class="markdownIt-Anchor" href="#treeset和sortedset有什么区别和联系">#</a> TreeSet 和 SortedSet 有什么区别和联系？</h2><p>TreeSet 实现了 NavigableSet 接口，而 NavigableSet 继承自 SortedSet 接口；TreeSet 实现了 SortedSet 接口；</p><h2 id="copyonwritearrayset是用map实现的吗"><a class="markdownIt-Anchor" href="#copyonwritearrayset是用map实现的吗">#</a> CopyOnWriteArraySet 是用 Map 实现的吗？</h2><p>CopyOnWriteArraySet 底层是使用 CopyOnWriteArrayList 存储元素的，所以它并不是使用 Map 来存储元素的。</p><h2 id="copyonwritearrayset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#copyonwritearrayset是有序的吗怎么个有序法">#</a> CopyOnWriteArraySet 是有序的吗？怎么个有序法？</h2><p>有序，因为底层是 CopyOnWriteArrayList 存储元素的，所以是个数组。</p><h2 id="copyonwritearrayset怎么保证并发安全"><a class="markdownIt-Anchor" href="#copyonwritearrayset怎么保证并发安全">#</a> CopyOnWriteArraySet 怎么保证并发安全？</h2><p>CopyOnWriteArraySet 是并发安全的，而且实现了读写分离；因为底层是 CopyOnWriteArrayList 存储元素的，所以见 CopyOnWriteArrayList 是如何实现并发安全的。</p><h2 id="copyonwritearrayset以何种方式保证元素不重复"><a class="markdownIt-Anchor" href="#copyonwritearrayset以何种方式保证元素不重复">#</a> CopyOnWriteArraySet 以何种方式保证元素不重复？</h2><p>在添加元素时调用了 CopyOnWriteArrayList 的 addIfAbsent () 方法来保证元素不重复。</p><p>CopyOnWriteArraySet 通过调用 CopyOnWriteArrayList 的 addIfAbsent () 方法来保证元素不重复</p><p>具体的见前文</p><h2 id="如何比较两个set中的元素是否完全一致"><a class="markdownIt-Anchor" href="#如何比较两个set中的元素是否完全一致">#</a> 如何比较两个 Set 中的元素是否完全一致？</h2><p>假设有两个 Set，一个是 A，一个是 B。</p><p>最简单的方式就是判断是否 A 中的元素都在 B 中，B 中的元素是否都在 A 中，也就是两次两层循环。</p><p>其实，并不需要。</p><p>因为 Set 中的元素并不重复，所以只要先比较两个 Set 的元素个数是否相等，再作一次两层循环就可以了，需要仔细体味。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class CopyOnWriteArraySetTest &#123;</span><br><span class="line">    </span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set1 = new CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line">            set1.add(1);</span><br><span class="line">            set1.add(5);</span><br><span class="line">            set1.add(2);</span><br><span class="line">            set1.add(7);</span><br><span class="line">    //        set1.add(3);</span><br><span class="line">            set1.add(4);</span><br><span class="line">    </span><br><span class="line">            Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;();</span><br><span class="line">            set2.add(1);</span><br><span class="line">            set2.add(5);</span><br><span class="line">            set2.add(2);</span><br><span class="line">            set2.add(7);</span><br><span class="line">            set2.add(3);</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(set1, set2));</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(set2, set1));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private static &lt;T&gt; boolean eq(Set&lt;T&gt; set1, Set&lt;T&gt; set2) &#123;</span><br><span class="line">            if (set1.size() != set2.size()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            for (T t : set1) &#123;</span><br><span class="line">                // contains相当于一层for循环</span><br><span class="line">                if (!set2.contains(t)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何比较两个list中的元素是否完全相等呢"><a class="markdownIt-Anchor" href="#如何比较两个list中的元素是否完全相等呢">#</a> 如何比较两个 List 中的元素是否完全相等呢？</h2><p>我们知道，List 中元素是可以重复的，那是不是要做两次两层循环呢？</p><p>其实，也不需要做两次两层遍历，一次也可以搞定，设定一个标记数组，标记某个位置的元素是否找到过，请仔细体味。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ListEqTest &#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">            list1.add(1);</span><br><span class="line">            list1.add(3);</span><br><span class="line">            list1.add(6);</span><br><span class="line">            list1.add(3);</span><br><span class="line">            list1.add(8);</span><br><span class="line">            list1.add(5);</span><br><span class="line">    </span><br><span class="line">            List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">            list2.add(3);</span><br><span class="line">            list2.add(1);</span><br><span class="line">            list2.add(3);</span><br><span class="line">            list2.add(8);</span><br><span class="line">            list2.add(5);</span><br><span class="line">            list2.add(6);</span><br><span class="line">    </span><br><span class="line">            System.out.println(eq(list1, list2));</span><br><span class="line">            System.out.println(eq(list2, list1));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        private static &lt;T&gt; boolean eq(List&lt;T&gt; list1, List&lt;T&gt; list2) &#123;</span><br><span class="line">            if (list1.size() != list2.size()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 标记某个元素是否找到过，防止重复</span><br><span class="line">            boolean matched[] = new boolean[list2.size()];</span><br><span class="line">    </span><br><span class="line">            outer: for (T t : list1) &#123;</span><br><span class="line">                for (int i = 0; i &lt; list2.size(); i++) &#123;</span><br><span class="line">                    // i这个位置没找到过才比较大小</span><br><span class="line">                    if (!matched[i] &amp;&amp; list2.get(i).equals(t)) &#123;</span><br><span class="line">                        matched[i] = true;</span><br><span class="line">                        continue outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="concurrentskiplistset的底层是concurrentskiplistmap吗"><a class="markdownIt-Anchor" href="#concurrentskiplistset的底层是concurrentskiplistmap吗">#</a> ConcurrentSkipListSet 的底层是 ConcurrentSkipListMap 吗？</h2><p>ConcurrentSkipListSet 底层是通过 ConcurrentNavigableMap 来实现的，它是一个有序的线程安全的集合。</p><h2 id="concurrentskiplistset是有序的吗怎么个有序法"><a class="markdownIt-Anchor" href="#concurrentskiplistset是有序的吗怎么个有序法">#</a> ConcurrentSkipListSet 是有序的吗？怎么个有序法？</h2><p>ConcurrentSkipListSet 有序的，基于元素的自然排序或者通过比较器确定的顺序；</p><h2 id="concurrentskiplistset源码"><a class="markdownIt-Anchor" href="#concurrentskiplistset源码">#</a> ConcurrentSkipListSet 源码？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 实现了NavigableSet接口，并没有所谓的ConcurrentNavigableSet接口</span><br><span class="line">public class ConcurrentSkipListSet&lt;E&gt;</span><br><span class="line">        extends AbstractSet&lt;E&gt;</span><br><span class="line">        implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">        private static final long serialVersionUID = -2479143111061671589L;</span><br><span class="line">    </span><br><span class="line">        // 存储使用的map</span><br><span class="line">        private final ConcurrentNavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    </span><br><span class="line">        // 初始化</span><br><span class="line">        public ConcurrentSkipListSet() &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 传入比较器</span><br><span class="line">        public ConcurrentSkipListSet(Comparator&lt;? super E&gt; comparator) &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;(comparator);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 使用ConcurrentSkipListMap初始化map</span><br><span class="line">        // 并将集合c中所有元素放入到map中</span><br><span class="line">        public ConcurrentSkipListSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;();</span><br><span class="line">            addAll(c);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 使用ConcurrentSkipListMap初始化map</span><br><span class="line">        // 并将有序Set中所有元素放入到map中</span><br><span class="line">        public ConcurrentSkipListSet(SortedSet&lt;E&gt; s) &#123;</span><br><span class="line">            m = new ConcurrentSkipListMap&lt;E,Object&gt;(s.comparator());</span><br><span class="line">            addAll(s);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // ConcurrentSkipListSet类内部返回子set时使用的</span><br><span class="line">        ConcurrentSkipListSet(ConcurrentNavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">            this.m = m;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 克隆方法</span><br><span class="line">        public ConcurrentSkipListSet&lt;E&gt; clone() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                ConcurrentSkipListSet&lt;E&gt; clone =</span><br><span class="line">                    (ConcurrentSkipListSet&lt;E&gt;) super.clone();</span><br><span class="line">                clone.setMap(new ConcurrentSkipListMap&lt;E,Object&gt;(m));</span><br><span class="line">                return clone;</span><br><span class="line">            &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">                throw new InternalError();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /* ---------------- Set operations -------------- */</span><br><span class="line">        // 返回元素个数</span><br><span class="line">        public int size() &#123;</span><br><span class="line">            return m.size();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否为空</span><br><span class="line">        public boolean isEmpty() &#123;</span><br><span class="line">            return m.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 检查是否包含某个元素</span><br><span class="line">        public boolean contains(Object o) &#123;</span><br><span class="line">            return m.containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 添加一个元素</span><br><span class="line">        // 调用map的putIfAbsent()方法</span><br><span class="line">        public boolean add(E e) &#123;</span><br><span class="line">            return m.putIfAbsent(e, Boolean.TRUE) == null;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 移除一个元素</span><br><span class="line">        public boolean remove(Object o) &#123;</span><br><span class="line">            return m.remove(o, Boolean.TRUE);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 清空所有元素</span><br><span class="line">        public void clear() &#123;</span><br><span class="line">            m.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 迭代器</span><br><span class="line">        public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">            return m.navigableKeySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 降序迭代器</span><br><span class="line">        public Iterator&lt;E&gt; descendingIterator() &#123;</span><br><span class="line">            return m.descendingKeySet().iterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        /* ---------------- AbstractSet Overrides -------------- */</span><br><span class="line">        // 比较相等方法</span><br><span class="line">        public boolean equals(Object o) &#123;</span><br><span class="line">            // Override AbstractSet version to avoid calling size()</span><br><span class="line">            if (o == this)</span><br><span class="line">                return true;</span><br><span class="line">            if (!(o instanceof Set))</span><br><span class="line">                return false;</span><br><span class="line">            Collection&lt;?&gt; c = (Collection&lt;?&gt;) o;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 这里是通过两次两层for循环来比较</span><br><span class="line">                // 这里是有很大优化空间的，参考上篇文章CopyOnWriteArraySet中的彩蛋</span><br><span class="line">                return containsAll(c) &amp;&amp; c.containsAll(this);</span><br><span class="line">            &#125; catch (ClassCastException unused) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; catch (NullPointerException unused) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 移除集合c中所有元素</span><br><span class="line">        public boolean removeAll(Collection&lt;?&gt; c) &#123;</span><br><span class="line">            // Override AbstractSet version to avoid unnecessary call to size()</span><br><span class="line">            boolean modified = false;</span><br><span class="line">            for (Object e : c)</span><br><span class="line">                if (remove(e))</span><br><span class="line">                    modified = true;</span><br><span class="line">            return modified;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /* ---------------- Relational operations -------------- */</span><br><span class="line">    </span><br><span class="line">        // 小于e的最大元素</span><br><span class="line">        public E lower(E e) &#123;</span><br><span class="line">            return m.lowerKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 小于等于e的最大元素</span><br><span class="line">        public E floor(E e) &#123;</span><br><span class="line">            return m.floorKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 大于等于e的最小元素</span><br><span class="line">        public E ceiling(E e) &#123;</span><br><span class="line">            return m.ceilingKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 大于e的最小元素</span><br><span class="line">        public E higher(E e) &#123;</span><br><span class="line">            return m.higherKey(e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 弹出最小的元素</span><br><span class="line">        public E pollFirst() &#123;</span><br><span class="line">            Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry();</span><br><span class="line">            return (e == null) ? null : e.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 弹出最大的元素</span><br><span class="line">        public E pollLast() &#123;</span><br><span class="line">            Map.Entry&lt;E,Object&gt; e = m.pollLastEntry();</span><br><span class="line">            return (e == null) ? null : e.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        /* ---------------- SortedSet operations -------------- */</span><br><span class="line">    </span><br><span class="line">        // 取比较器</span><br><span class="line">        public Comparator&lt;? super E&gt; comparator() &#123;</span><br><span class="line">            return m.comparator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 最小的元素</span><br><span class="line">        public E first() &#123;</span><br><span class="line">            return m.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 最大的元素</span><br><span class="line">        public E last() &#123;</span><br><span class="line">            return m.lastKey();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取两个元素之间的子set</span><br><span class="line">        public NavigableSet&lt;E&gt; subSet(E fromElement,</span><br><span class="line">                                      boolean fromInclusive,</span><br><span class="line">                                      E toElement,</span><br><span class="line">                                      boolean toInclusive) &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;</span><br><span class="line">                (m.subMap(fromElement, fromInclusive,</span><br><span class="line">                          toElement,   toInclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取头子set</span><br><span class="line">        public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;(m.headMap(toElement, inclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取尾子set</span><br><span class="line">        public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;(m.tailMap(fromElement, inclusive));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取子set，包含from，不包含to</span><br><span class="line">        public NavigableSet&lt;E&gt; subSet(E fromElement, E toElement) &#123;</span><br><span class="line">            return subSet(fromElement, true, toElement, false);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取头子set，不包含to</span><br><span class="line">        public NavigableSet&lt;E&gt; headSet(E toElement) &#123;</span><br><span class="line">            return headSet(toElement, false);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 取尾子set，包含from</span><br><span class="line">        public NavigableSet&lt;E&gt; tailSet(E fromElement) &#123;</span><br><span class="line">            return tailSet(fromElement, true);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 降序set</span><br><span class="line">        public NavigableSet&lt;E&gt; descendingSet() &#123;</span><br><span class="line">            return new ConcurrentSkipListSet&lt;E&gt;(m.descendingMap());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 可分割的迭代器</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public Spliterator&lt;E&gt; spliterator() &#123;</span><br><span class="line">            if (m instanceof ConcurrentSkipListMap)</span><br><span class="line">                return ((ConcurrentSkipListMap&lt;E,?&gt;)m).keySpliterator();</span><br><span class="line">            else</span><br><span class="line">                return (Spliterator&lt;E&gt;)((ConcurrentSkipListMap.SubMap&lt;E,?&gt;)m).keyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 原子更新map，给clone方法使用</span><br><span class="line">        private void setMap(ConcurrentNavigableMap&lt;E,Object&gt; map) &#123;</span><br><span class="line">            UNSAFE.putObjectVolatile(this, mapOffset, map);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        // 原子操作相关内容</span><br><span class="line">        private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">        private static final long mapOffset;</span><br><span class="line">        static &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = ConcurrentSkipListSet.class;</span><br><span class="line">                mapOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(&quot;m&quot;));</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="什么是堆什么是堆化"><a class="markdownIt-Anchor" href="#什么是堆什么是堆化">#</a> 什么是堆？什么是堆化？</h2><p>堆是一种特殊的树，只要满足下面两个条件，它就是一个堆：</p><p>（1）堆是一颗完全二叉树；</p><p>（2）堆中某个节点的值总是不大于（或不小于）其父节点的值。</p><p>其中，我们把根节点最大的堆叫做大顶堆，根节点最小的堆叫做小顶堆。</p><p>堆化（向下调整）、向上调整的前提都是：在二叉树中，只有一个位置不满足堆的性质，其它位置都满足堆的性质。<br>向下调整 是让调整的结点与其孩子节点进行比较<br>向上调整 是让调整的结点与其父亲结点进行比较</p><h2 id="什么是优先级队列"><a class="markdownIt-Anchor" href="#什么是优先级队列">#</a> 什么是优先级队列？</h2><h2 id="priorityqueue是怎么实现的"><a class="markdownIt-Anchor" href="#priorityqueue是怎么实现的">#</a> PriorityQueue 是怎么实现的？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> // 默认容量</span><br><span class="line">private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br><span class="line">// 存储元素的地方</span><br><span class="line">transient Object[] queue; // non-private to simplify nested class access</span><br><span class="line">// 元素个数</span><br><span class="line">private int size = 0;</span><br><span class="line">// 比较器</span><br><span class="line">private final Comparator&lt;? super E&gt; comparator;</span><br><span class="line">// 修改次数</span><br><span class="line">transient int modCount = 0; // non-private to simplify nested class access</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PriorityQueue 是一个小顶堆；</p><h2 id="priorityqueue是有序的吗"><a class="markdownIt-Anchor" href="#priorityqueue是有序的吗">#</a> PriorityQueue 是有序的吗？</h2><p>PriorityQueue 不是有序的，只有堆顶存储着最小的元素；</p><h2 id="priorityqueue入队-出队的时间复杂度各是多少"><a class="markdownIt-Anchor" href="#priorityqueue入队-出队的时间复杂度各是多少">#</a> PriorityQueue 入队、出队的时间复杂度各是多少？</h2><p>建堆的时间复杂度是 O (n)；</p><p>堆的插入、删除元素的时间复杂度都是 O (log n)；</p><p>入队有两个方法，add (E e) 和 offer (E e)，两者是一致的，add (E e) 也是调用的 offer (E e)。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        // 不支持null元素</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        modCount++;</span><br><span class="line">        // 取size</span><br><span class="line">        int i = size;</span><br><span class="line">        // 元素个数达到最大容量了，扩容</span><br><span class="line">        if (i &gt;= queue.length)</span><br><span class="line">            grow(i + 1);</span><br><span class="line">        // 元素个数加1</span><br><span class="line">        size = i + 1;</span><br><span class="line">        // 如果还没有元素</span><br><span class="line">        // 直接插入到数组第一个位置</span><br><span class="line">        // 这里跟我们之前讲堆不一样了</span><br><span class="line">        // java里面是从0开始的</span><br><span class="line">        // 我们说的堆是从1开始的</span><br><span class="line">        if (i == 0)</span><br><span class="line">            queue[0] = e;</span><br><span class="line">        else</span><br><span class="line">            // 否则，插入元素到数组size的位置，也就是最后一个元素的下一位</span><br><span class="line">            // 注意这里的size不是数组大小，而是元素个数</span><br><span class="line">            // 然后，再做自下而上的堆化</span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void siftUp(int k, E x) &#123;</span><br><span class="line">        // 根据是否有比较器，使用不同的方法</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftUpUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftUpComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private void siftUpComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            // 找到父节点的位置</span><br><span class="line">            // 因为元素是从0开始的，所以减1之后再除以2</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            // 父节点的值</span><br><span class="line">            Object e = queue[parent];</span><br><span class="line">            // 比较插入的元素与父节点的值</span><br><span class="line">            // 如果比父节点大，则跳出循环</span><br><span class="line">            // 否则交换位置</span><br><span class="line">            if (key.compareTo((E) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 与父节点交换位置</span><br><span class="line">            queue[k] = e;</span><br><span class="line">            // 现在插入的元素位置移到了父节点的位置</span><br><span class="line">            // 继续与父节点再比较</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        // 最后找到应该插入的位置，放入元素</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）入队不允许 null 元素；</p><p>（2）如果数组不够用了，先扩容；</p><p>（3）如果还没有元素，就插入下标 0 的位置；</p><p>（4）如果有元素了，就插入到最后一个元素往后的一个位置（实际并没有插入哈）；</p><p>（5）自下而上堆化，一直往上跟父节点比较；</p><p>（6）如果比父节点小，就与父节点交换位置，直到出现比父节点大为止；</p><p>（7）由此可见，PriorityQueue 是一个小顶堆。</p><p>出队有两个方法，remove () 和 poll ()，remove () 也是调用的 poll ()，只是没有元素的时候抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        // 调用poll弹出队首元素</span><br><span class="line">        E x = poll();</span><br><span class="line">        if (x != null)</span><br><span class="line">            // 有元素就返回弹出的元素</span><br><span class="line">            return x;</span><br><span class="line">        else</span><br><span class="line">            // 没有元素就抛出异常</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E poll() &#123;</span><br><span class="line">        // 如果size为0，说明没有元素</span><br><span class="line">        if (size == 0)</span><br><span class="line">            return null;</span><br><span class="line">        // 弹出元素，元素个数减1</span><br><span class="line">        int s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">        // 队列首元素</span><br><span class="line">        E result = (E) queue[0];</span><br><span class="line">        // 队列末元素</span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        // 将队列末元素删除</span><br><span class="line">        queue[s] = null;</span><br><span class="line">        // 如果弹出元素后还有元素</span><br><span class="line">        if (s != 0)</span><br><span class="line">            // 将队列末元素移到队列首</span><br><span class="line">            // 再做自上而下的堆化</span><br><span class="line">            siftDown(0, x);</span><br><span class="line">        // 返回弹出的元素</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void siftDown(int k, E x) &#123;</span><br><span class="line">        // 根据是否有比较器，选择不同的方法</span><br><span class="line">        if (comparator != null)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        else</span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    private void siftDownComparable(int k, E x) &#123;</span><br><span class="line">        Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x;</span><br><span class="line">        // 只需要比较一半就行了，因为叶子节点占了一半的元素</span><br><span class="line">        int half = size &gt;&gt;&gt; 1;        // loop while a non-leaf</span><br><span class="line">        while (k &lt; half) &#123;</span><br><span class="line">            // 寻找子节点的位置，这里加1是因为元素从0号位置开始</span><br><span class="line">            int child = (k &lt;&lt; 1) + 1; // assume left child is least</span><br><span class="line">            // 左子节点的值</span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            // 右子节点的位置</span><br><span class="line">            int right = child + 1;</span><br><span class="line">            if (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0)</span><br><span class="line">                // 左右节点取其小者</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            // 如果比子节点都小，则结束</span><br><span class="line">            if (key.compareTo((E) c) &lt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 如果比最小的子节点大，则交换位置</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            // 指针移到最小子节点的位置继续往下比较</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到正确的位置，放入元素</span><br><span class="line">        queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）将队列首元素弹出；</p><p>（2）将队列末元素移到队列首；</p><p>（3）自上而下堆化，一直往下与最小的子节点比较；</p><p>（4）如果比最小的子节点大，就交换位置，再继续与最小的子节点比较；</p><p>（5）如果比最小的子节点小，就不用交换位置了，堆化结束；</p><p>（6）这就是堆中的删除堆顶元素；</p><h2 id="priorityqueue是否需要扩容扩容规则呢"><a class="markdownIt-Anchor" href="#priorityqueue是否需要扩容扩容规则呢">#</a> PriorityQueue 是否需要扩容？扩容规则呢？</h2><p>会因为 PriorityQueue 是无限增长的队列，元素不够用了会扩容，所以添加元素不会失败。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">        // 旧容量</span><br><span class="line">        int oldCapacity = queue.length;</span><br><span class="line">        // Double size if small; else grow by 50%</span><br><span class="line">        // 旧容量小于64时，容量翻倍</span><br><span class="line">        // 旧容量大于等于64，容量只增加旧容量的一半</span><br><span class="line">        int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ?</span><br><span class="line">                                         (oldCapacity + 2) :</span><br><span class="line">                                         (oldCapacity &gt;&gt; 1));</span><br><span class="line">        // overflow-conscious code</span><br><span class="line">        // 检查是否溢出</span><br><span class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    </span><br><span class="line">        // 创建出一个新容量大小的新数组并把旧数组元素拷贝过去</span><br><span class="line">        queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">        if (minCapacity &lt; 0) // overflow</span><br><span class="line">            throw new OutOfMemoryError();</span><br><span class="line">        return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）当数组比较小（小于 64）的时候每次扩容容量翻倍；</p><p>（2）当数组比较大的时候每次扩容只增加一半的容量；</p><h2 id="arrayblockingqueue的实现方式"><a class="markdownIt-Anchor" href="#arrayblockingqueue的实现方式">#</a> ArrayBlockingQueue 的实现方式？</h2><p>ArrayBlockingQueue 是 java 并发包下一个以数组实现的阻塞队列。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 使用数组存储元素</span><br><span class="line">    final Object[] items;</span><br><span class="line">    </span><br><span class="line">    // 取元素的指针</span><br><span class="line">    int takeIndex;</span><br><span class="line">    </span><br><span class="line">    // 放元素的指针</span><br><span class="line">    int putIndex;</span><br><span class="line">    </span><br><span class="line">    // 元素数量</span><br><span class="line">    int count;</span><br><span class="line">    </span><br><span class="line">    // 保证并发访问的锁</span><br><span class="line">    final ReentrantLock lock;</span><br><span class="line">    </span><br><span class="line">    // 非空条件</span><br><span class="line">    private final Condition notEmpty;</span><br><span class="line">    </span><br><span class="line">    // 非满条件</span><br><span class="line">    private final Condition notFull;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="arrayblockingqueue是否需要扩容"><a class="markdownIt-Anchor" href="#arrayblockingqueue是否需要扩容">#</a> ArrayBlockingQueue 是否需要扩容？</h2><p>ArrayBlockingQueue 不需要扩容，因为是初始化时指定容量，并循环利用数组；</p><p>ArrayBlockingQueue 利用 takeIndex 和 putIndex 循环利用数组</p><h2 id="arrayblockingqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#arrayblockingqueue怎么保证线程安全">#</a> ArrayBlockingQueue 怎么保证线程安全？</h2><p>利用重入锁和两个条件保证并发安全</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public ArrayBlockingQueue(int capacity) &#123;</span><br><span class="line">      this(capacity, false);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">      if (capacity &lt;= 0)</span><br><span class="line">          throw new IllegalArgumentException();</span><br><span class="line">      // 初始化数组</span><br><span class="line">      this.items = new Object[capacity];</span><br><span class="line">      // 创建重入锁及两个条件</span><br><span class="line">      lock = new ReentrantLock(fair);</span><br><span class="line">      notEmpty = lock.newCondition();</span><br><span class="line">      notFull =  lock.newCondition();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>入队有四个方法，它们分别是 add (E e)、offer (E e)、put (E e)、offer (E e, long timeout, TimeUnit unit)，它们有什么区别呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        // 调用父类的add(e)方法</span><br><span class="line">        return super.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // super.add(e)</span><br><span class="line">    public boolean add(E e) &#123;</span><br><span class="line">        // 调用offer(e)如果成功返回true，如果失败抛出异常</span><br><span class="line">        if (offer(e))</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            throw new IllegalStateException(&quot;Queue full&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        // 元素不可为空</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (count == items.length)</span><br><span class="line">                // 如果数组满了就返回false</span><br><span class="line">                return false;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 如果数组没满就调用入队方法并返回true</span><br><span class="line">                enqueue(e);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁，如果线程中断了抛出异常</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果数组满了，使用notFull等待</span><br><span class="line">            // notFull等待的意思是说现在队列满了</span><br><span class="line">            // 只有取走一个元素后，队列才不满</span><br><span class="line">            // 然后唤醒notFull，然后继续现在的逻辑</span><br><span class="line">            // 这里之所以使用while而不是if</span><br><span class="line">            // 是因为有可能多个线程阻塞在lock上</span><br><span class="line">            // 即使唤醒了可能其它线程先一步修改了队列又变成满的了</span><br><span class="line">            // 这时候需要再次等待</span><br><span class="line">            while (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            // 入队</span><br><span class="line">            enqueue(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e, long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        long nanos = unit.toNanos(timeout);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果数组满了，就阻塞nanos纳秒</span><br><span class="line">            // 如果唤醒这个线程时依然没有空间且时间到了就返回false</span><br><span class="line">            while (count == items.length) &#123;</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return false;</span><br><span class="line">                nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            // 入队</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void enqueue(E x) &#123;</span><br><span class="line">        final Object[] items = this.items;</span><br><span class="line">        // 把元素直接放在放指针的位置上</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        // 如果放指针到数组尽头了，就返回头部</span><br><span class="line">        if (++putIndex == items.length)</span><br><span class="line">            putIndex = 0;</span><br><span class="line">        // 数量加1</span><br><span class="line">        count++;</span><br><span class="line">        // 唤醒notEmpty，因为入队了一个元素，所以肯定不为空了</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）add (e) 时如果队列满了则抛出异常；</p><p>（2）offer (e) 时如果队列满了则返回 false；</p><p>（3）put (e) 时如果队列满了则使用 notFull 等待；</p><p>（4）offer (e, timeout, unit) 时如果队列满了则等待一段时间后如果队列依然满就返回 false；</p><p>（5）利用放指针循环使用数组来存储元素；</p><p>出队有四个方法，它们分别是 remove ()、poll ()、take ()、poll (long timeout, TimeUnit unit)，它们有什么区别呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        // 调用poll()方法出队</span><br><span class="line">        E x = poll();</span><br><span class="line">        if (x != null)</span><br><span class="line">            // 如果有元素出队就返回这个元素</span><br><span class="line">            return x;</span><br><span class="line">        else</span><br><span class="line">            // 如果没有元素出队就抛出异常</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E poll() &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列没有元素则返回null，否则出队</span><br><span class="line">            return (count == 0) ? null : dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列无元素，则阻塞等待在条件notEmpty上</span><br><span class="line">            while (count == 0)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            // 有元素了再出队</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        long nanos = unit.toNanos(timeout);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 如果队列无元素，则阻塞等待nanos纳秒</span><br><span class="line">            // 如果下一次这个线程获得了锁但队列依然无元素且已超时就返回null</span><br><span class="line">            while (count == 0) &#123;</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private E dequeue() &#123;</span><br><span class="line">        final Object[] items = this.items;</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        // 取取指针位置的元素</span><br><span class="line">        E x = (E) items[takeIndex];</span><br><span class="line">        // 把取指针位置设为null</span><br><span class="line">        items[takeIndex] = null;</span><br><span class="line">        // 取指针前移，如果数组到头了就返回数组前端循环利用</span><br><span class="line">        if (++takeIndex == items.length)</span><br><span class="line">            takeIndex = 0;</span><br><span class="line">        // 元素数量减1</span><br><span class="line">        count--;</span><br><span class="line">        if (itrs != null)</span><br><span class="line">            itrs.elementDequeued();</span><br><span class="line">        // 唤醒notFull条件</span><br><span class="line">        notFull.signal();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）remove () 时如果队列为空则抛出异常；</p><p>（2）poll () 时如果队列为空则返回 null；</p><p>（3）take () 时如果队列为空则阻塞等待在条件 notEmpty 上；</p><p>（4）poll (timeout, unit) 时如果队列为空则阻塞等待一段时间后如果还为空就返回 null；</p><p>（5）利用取指针循环从数组中取元素；</p><h2 id="arrayblockingqueue有什么缺点"><a class="markdownIt-Anchor" href="#arrayblockingqueue有什么缺点">#</a> ArrayBlockingQueue 有什么缺点？</h2><p>a）队列长度固定且必须在初始化时指定，所以使用之前一定要慎重考虑好容量；</p><p>b）如果消费速度跟不上入队速度，则会导致提供者线程一直阻塞，且越阻塞越多，非常危险；</p><p>c）只使用了一个锁来控制入队出队，效率较低。</p><h2 id="linkedblockingqueue的实现方式"><a class="markdownIt-Anchor" href="#linkedblockingqueue的实现方式">#</a> LinkedBlockingQueue 的实现方式？</h2><p>LinkedBlockingQueue 采用单链表的形式实现；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">    </span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">    </span><br><span class="line">        Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="linkedblockingqueue是有界的还是无界的队列"><a class="markdownIt-Anchor" href="#linkedblockingqueue是有界的还是无界的队列">#</a> LinkedBlockingQueue 是有界的还是无界的队列？</h2><p>LinkedBlockingQueue 是有界队列，不传入容量时默认为最大 int 值；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public LinkedBlockingQueue() &#123;</span><br><span class="line">        // 如果没传容量，就使用最大int值初始化其容量</span><br><span class="line">        this(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LinkedBlockingQueue(int capacity) &#123;</span><br><span class="line">        if (capacity &lt;= 0) throw new IllegalArgumentException();</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        // 初始化head和last指针为空值节点</span><br><span class="line">        last = head = new Node&lt;E&gt;(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="linkedblockingqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#linkedblockingqueue怎么保证线程安全">#</a> LinkedBlockingQueue 怎么保证线程安全？</h2><p>LinkedBlockingQueue 采用两把锁的锁分离技术实现入队出队互不阻塞；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 容量</span><br><span class="line">    private final int capacity;</span><br><span class="line">    </span><br><span class="line">    // 元素数量</span><br><span class="line">    private final AtomicInteger count = new AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    // 链表头</span><br><span class="line">    transient Node&lt;E&gt; head;</span><br><span class="line">    </span><br><span class="line">    // 链表尾</span><br><span class="line">    private transient Node&lt;E&gt; last;</span><br><span class="line">    </span><br><span class="line">    // take锁</span><br><span class="line">    private final ReentrantLock takeLock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    // notEmpty条件</span><br><span class="line">    // 当队列无元素时，take锁会阻塞在notEmpty条件上，等待其它线程唤醒</span><br><span class="line">    private final Condition notEmpty = takeLock.newCondition();</span><br><span class="line">    </span><br><span class="line">    // 放锁</span><br><span class="line">    private final ReentrantLock putLock = new ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    // notFull条件</span><br><span class="line">    // 当队列满了时，put锁会会阻塞在notFull上，等待其它线程唤醒</span><br><span class="line">    private final Condition notFull = putLock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="linkedblockingqueue与arrayblockingqueue对比"><a class="markdownIt-Anchor" href="#linkedblockingqueue与arrayblockingqueue对比">#</a> LinkedBlockingQueue 与 ArrayBlockingQueue 对比？</h2><p>a）后者入队出队采用一把锁，导致入队出队相互阻塞，效率低下；</p><p>b）前才入队出队采用两把锁，入队出队互不干扰，效率较高；</p><p>c）二者都是有界队列，如果长度相等且出队速度跟不上入队速度，都会导致大量线程阻塞；</p><p>d）前者如果初始化不传入初始容量，则使用最大 int 值，如果出队速度跟不上入队速度，会导致队列特别长，占用大量内存；</p><h2 id="synchronousqueue的实现方式"><a class="markdownIt-Anchor" href="#synchronousqueue的实现方式">#</a> SynchronousQueue 的实现方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// Transferer抽象类，主要定义了一个transfer方法用来传输元素</span><br><span class="line">   abstract static class Transferer&lt;E&gt; &#123;</span><br><span class="line">       abstract E transfer(E e, boolean timed, long nanos);</span><br><span class="line">   &#125;</span><br><span class="line">   // 以栈方式实现的Transferer</span><br><span class="line">   static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123;</span><br><span class="line">       // 栈中节点的几种类型：</span><br><span class="line">       // 1. 消费者（请求数据的）</span><br><span class="line">       static final int REQUEST    = 0;</span><br><span class="line">       // 2. 生产者（提供数据的）</span><br><span class="line">       static final int DATA       = 1;</span><br><span class="line">       // 3. 二者正在撮合中</span><br><span class="line">       static final int FULFILLING = 2;</span><br><span class="line">   </span><br><span class="line">       // 栈中的节点</span><br><span class="line">       static final class SNode &#123;</span><br><span class="line">           // 下一个节点</span><br><span class="line">           volatile SNode next;        // next node in stack</span><br><span class="line">           // 匹配者</span><br><span class="line">           volatile SNode match;       // the node matched to this</span><br><span class="line">           // 等待着的线程</span><br><span class="line">           volatile Thread waiter;     // to control park/unpark</span><br><span class="line">           // 元素</span><br><span class="line">           Object item;                // data; or null for REQUESTs</span><br><span class="line">           // 模式，也就是节点的类型，是消费者，是生产者，还是正在撮合中</span><br><span class="line">           int mode;</span><br><span class="line">       &#125;</span><br><span class="line">       // 栈的头节点</span><br><span class="line">       volatile SNode head;</span><br><span class="line">   &#125;</span><br><span class="line">   // 以队列方式实现的Transferer</span><br><span class="line">   static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; &#123;</span><br><span class="line">       // 队列中的节点</span><br><span class="line">       static final class QNode &#123;</span><br><span class="line">           // 下一个节点</span><br><span class="line">           volatile QNode next;          // next node in queue</span><br><span class="line">           // 存储的元素</span><br><span class="line">           volatile Object item;         // CAS&#x27;ed to or from null</span><br><span class="line">           // 等待着的线程</span><br><span class="line">           volatile Thread waiter;       // to control park/unpark</span><br><span class="line">           // 是否是数据节点</span><br><span class="line">           final boolean isData;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 队列的头节点</span><br><span class="line">       transient volatile QNode head;</span><br><span class="line">       // 队列的尾节点</span><br><span class="line">       transient volatile QNode tail;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）定义了一个抽象类 Transferer，里面定义了一个传输元素的方法；</p><p>（2）有两种传输元素的方法，一种是栈，一种是队列；</p><p>（3）栈的特点是后进先出，队列的特点是先进行出；</p><p>（4）栈只需要保存一个头节点就可以了，因为存取元素都是操作头节点；</p><p>（5）队列需要保存一个头节点一个尾节点，因为存元素操作尾节点，取元素操作头节点；</p><p>（6）每个节点中保存着存储的元素、等待着的线程，以及下一个节点；</p><h2 id="synchronousqueue真的是无缓冲的吗"><a class="markdownIt-Anchor" href="#synchronousqueue真的是无缓冲的吗">#</a> SynchronousQueue 真的是无缓冲的吗？</h2><p>通过源码分析，我们可以发现其实 SynchronousQueue 内部或者使用栈或者使用队列来存储包含线程和元素值的节点，如果同一个模式的节点过多的话，它们都会存储进来，且都会阻塞着，所以，严格上来说，SynchronousQueue 并不能算是一个无缓冲队列。</p><h2 id="synchronousqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#synchronousqueue怎么保证线程安全">#</a> SynchronousQueue 怎么保证线程安全？</h2><p>我们这里主要介绍以栈方式实现的传输模式，以 put (E e) 方法为例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">        // 元素不可为空</span><br><span class="line">        if (e == null) throw new NullPointerException();</span><br><span class="line">        // 直接调用传输器的transfer()方法</span><br><span class="line">        // 三个参数分别是：传输的元素，是否需要超时，超时的时间</span><br><span class="line">        if (transferer.transfer(e, false, 0) == null) &#123;</span><br><span class="line">            // 如果传输失败，直接让线程中断并抛出中断异常</span><br><span class="line">            Thread.interrupted();</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用 transferer 的 transfer () 方法，传入元素 e，说明是生产者</p><p>我们这里主要介绍以栈方式实现的传输模式，以 take () 方法为例。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">       // 直接调用传输器的transfer()方法</span><br><span class="line">       // 三个参数分别是：null，是否需要超时，超时的时间</span><br><span class="line">       // 第一个参数为null表示是消费者，要取元素</span><br><span class="line">       E e = transferer.transfer(null, false, 0);</span><br><span class="line">       // 如果取到了元素就返回</span><br><span class="line">       if (e != null)</span><br><span class="line">           return e;</span><br><span class="line">       // 否则让线程中断并抛出中断异常</span><br><span class="line">       Thread.interrupted();</span><br><span class="line">       throw new InterruptedException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用 transferer 的 transfer () 方法，传入 null，说明是消费者。</p><h3 id="transfer方法"><a class="markdownIt-Anchor" href="#transfer方法">#</a> transfer () 方法</h3><p>transfer () 方法同时实现了取元素和放元素的功能，下面我再来看看这个 transfer () 方法里究竟干了什么。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// TransferStack.transfer()方法</span><br><span class="line">    E transfer(E e, boolean timed, long nanos) &#123;</span><br><span class="line">        SNode s = null; // constructed/reused as needed</span><br><span class="line">        // 根据e是否为null决定是生产者还是消费者</span><br><span class="line">        int mode = (e == null) ? REQUEST : DATA;</span><br><span class="line">        // 自旋+CAS，熟悉的套路，熟悉的味道</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 栈顶元素</span><br><span class="line">            SNode h = head;</span><br><span class="line">            // 栈顶没有元素，或者栈顶元素跟当前元素是一个模式的</span><br><span class="line">            // 也就是都是生产者节点或者都是消费者节点</span><br><span class="line">            if (h == null || h.mode == mode) &#123;  // empty or same-mode</span><br><span class="line">                // 如果有超时而且已到期</span><br><span class="line">                if (timed &amp;&amp; nanos &lt;= 0) &#123;      // can&#x27;t wait</span><br><span class="line">                    // 如果头节点不为空且是取消状态</span><br><span class="line">                    if (h != null &amp;&amp; h.isCancelled())</span><br><span class="line">                        // 就把头节点弹出，并进入下一次循环</span><br><span class="line">                        casHead(h, h.next);     // pop cancelled node</span><br><span class="line">                    else</span><br><span class="line">                        // 否则，直接返回null（超时返回null）</span><br><span class="line">                        return null;</span><br><span class="line">                &#125; else if (casHead(h, s = snode(s, e, h, mode))) &#123;</span><br><span class="line">                    // 入栈成功（因为是模式相同的，所以只能入栈）</span><br><span class="line">                    // 调用awaitFulfill()方法自旋+阻塞当前入栈的线程并等待被匹配到</span><br><span class="line">                    SNode m = awaitFulfill(s, timed, nanos);</span><br><span class="line">                    // 如果m等于s，说明取消了，那么就把它清除掉，并返回null</span><br><span class="line">                    if (m == s) &#123;               // wait was cancelled</span><br><span class="line">                        clean(s);</span><br><span class="line">                        // 被取消了返回null</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">    </span><br><span class="line">                    // 到这里说明匹配到元素了</span><br><span class="line">                    // 因为从awaitFulfill()里面出来要不被取消了要不就匹配到了</span><br><span class="line">    </span><br><span class="line">                    // 如果头节点不为空，并且头节点的下一个节点是s</span><br><span class="line">                    // 就把头节点换成s的下一个节点</span><br><span class="line">                    // 也就是把h和s都弹出了</span><br><span class="line">                    // 也就是把栈顶两个元素都弹出了</span><br><span class="line">                    if ((h = head) != null &amp;&amp; h.next == s)</span><br><span class="line">                        casHead(h, s.next);     // help s&#x27;s fulfiller</span><br><span class="line">                    // 根据当前节点的模式判断返回m还是s中的值</span><br><span class="line">                    return (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!isFulfilling(h.mode)) &#123; // try to fulfill</span><br><span class="line">                // 到这里说明头节点和当前节点模式不一样</span><br><span class="line">                // 如果头节点不是正在撮合中</span><br><span class="line">    </span><br><span class="line">                // 如果头节点已经取消了，就把它弹出栈</span><br><span class="line">                if (h.isCancelled())            // already cancelled</span><br><span class="line">                    casHead(h, h.next);         // pop and retry</span><br><span class="line">                else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;</span><br><span class="line">                    // 头节点没有在撮合中，就让当前节点先入队，再让他们尝试匹配</span><br><span class="line">                    // 且s成为了新的头节点，它的状态是正在撮合中</span><br><span class="line">                    for (;;) &#123; // loop until matched or waiters disappear</span><br><span class="line">                        SNode m = s.next;       // m is s&#x27;s match</span><br><span class="line">                        // 如果m为null，说明除了s节点外的节点都被其它线程先一步撮合掉了</span><br><span class="line">                        // 就清空栈并跳出内部循环，到外部循环再重新入栈判断</span><br><span class="line">                        if (m == null) &#123;        // all waiters are gone</span><br><span class="line">                            casHead(s, null);   // pop fulfill node</span><br><span class="line">                            s = null;           // use new node next time</span><br><span class="line">                            break;              // restart main loop</span><br><span class="line">                        &#125;</span><br><span class="line">                        SNode mn = m.next;</span><br><span class="line">                        // 如果m和s尝试撮合成功，就弹出栈顶的两个元素m和s</span><br><span class="line">                        if (m.tryMatch(s)) &#123;</span><br><span class="line">                            casHead(s, mn);     // pop both s and m</span><br><span class="line">                            // 返回撮合结果</span><br><span class="line">                            return (E) ((mode == REQUEST) ? m.item : s.item);</span><br><span class="line">                        &#125; else                  // lost match</span><br><span class="line">                            // 尝试撮合失败，说明m已经先一步被其它线程撮合了</span><br><span class="line">                            // 就协助清除它</span><br><span class="line">                            s.casNext(m, mn);   // help unlink</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;                            // help a fulfiller</span><br><span class="line">                // 到这里说明当前节点和头节点模式不一样</span><br><span class="line">                // 且头节点是正在撮合中</span><br><span class="line">    </span><br><span class="line">                SNode m = h.next;               // m is h&#x27;s match</span><br><span class="line">                if (m == null)                  // waiter is gone</span><br><span class="line">                    // 如果m为null，说明m已经被其它线程先一步撮合了</span><br><span class="line">                    casHead(h, null);           // pop fulfilling node</span><br><span class="line">                else &#123;</span><br><span class="line">                    SNode mn = m.next;</span><br><span class="line">                    // 协助匹配，如果m和s尝试撮合成功，就弹出栈顶的两个元素m和s</span><br><span class="line">                    if (m.tryMatch(h))          // help match</span><br><span class="line">                        // 将栈顶的两个元素弹出后，再让s重新入栈</span><br><span class="line">                        casHead(h, mn);         // pop both h and m</span><br><span class="line">                    else                        // lost match</span><br><span class="line">                        // 尝试撮合失败，说明m已经先一步被其它线程撮合了</span><br><span class="line">                        // 就协助清除它</span><br><span class="line">                        h.casNext(m, mn);       // help unlink</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 三个参数：需要等待的节点，是否需要超时，超时时间</span><br><span class="line">    SNode awaitFulfill(SNode s, boolean timed, long nanos) &#123;</span><br><span class="line">        // 到期时间</span><br><span class="line">        final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">        // 当前线程</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        // 自旋次数</span><br><span class="line">        int spins = (shouldSpin(s) ?</span><br><span class="line">                     (timed ? maxTimedSpins : maxUntimedSpins) : 0);</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 当前线程中断了，尝试清除s</span><br><span class="line">            if (w.isInterrupted())</span><br><span class="line">                s.tryCancel();</span><br><span class="line">    </span><br><span class="line">            // 检查s是否匹配到了元素m（有可能是其它线程的m匹配到当前线程的s）</span><br><span class="line">            SNode m = s.match;</span><br><span class="line">            // 如果匹配到了，直接返回m</span><br><span class="line">            if (m != null)</span><br><span class="line">                return m;</span><br><span class="line">    </span><br><span class="line">            // 如果需要超时</span><br><span class="line">            if (timed) &#123;</span><br><span class="line">                // 检查超时时间如果小于0了，尝试清除s</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                if (nanos &lt;= 0L) &#123;</span><br><span class="line">                    s.tryCancel();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (spins &gt; 0)</span><br><span class="line">                // 如果还有自旋次数，自旋次数减一，并进入下一次自旋</span><br><span class="line">                spins = shouldSpin(s) ? (spins-1) : 0;</span><br><span class="line">    </span><br><span class="line">            // 后面的elseif都是自旋次数没有了</span><br><span class="line">            else if (s.waiter == null)</span><br><span class="line">                // 如果s的waiter为null，把当前线程注入进去，并进入下一次自旋</span><br><span class="line">                s.waiter = w; // establish waiter so can park next iter</span><br><span class="line">            else if (!timed)</span><br><span class="line">                // 如果不允许超时，直接阻塞，并等待被其它线程唤醒，唤醒后继续自旋并查看是否匹配到了元素</span><br><span class="line">                LockSupport.park(this);</span><br><span class="line">            else if (nanos &gt; spinForTimeoutThreshold)</span><br><span class="line">                // 如果允许超时且还有剩余时间，就阻塞相应时间</span><br><span class="line">                LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        // SNode里面的方向，调用者m是s的下一个节点</span><br><span class="line">        // 这时候m节点的线程应该是阻塞状态的</span><br><span class="line"> boolean tryMatch(SNode s) &#123;</span><br><span class="line">            // 如果m还没有匹配者，就把s作为它的匹配者</span><br><span class="line">            if (match == null &amp;&amp;</span><br><span class="line">                UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123;</span><br><span class="line">                Thread w = waiter;</span><br><span class="line">                if (w != null) &#123;    // waiters need at most one unpark</span><br><span class="line">                    waiter = null;</span><br><span class="line">                    // 唤醒m中的线程，两者匹配完毕</span><br><span class="line">                    LockSupport.unpark(w);</span><br><span class="line">                &#125;</span><br><span class="line">                // 匹配到了返回true</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            // 可能其它线程先一步匹配了m，返回其是否是s</span><br><span class="line">            return match == s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>整个逻辑比较复杂，这里为了简单起见，屏蔽掉多线程处理的细节，只描述正常业务场景下的逻辑：</p><p>（1）如果栈中没有元素，或者栈顶元素跟将要入栈的元素模式一样，就入栈；</p><p>（2）入栈后自旋等待一会看有没有其它线程匹配到它，自旋完了还没匹配到元素就阻塞等待；</p><p>（3）阻塞等待被唤醒了说明其它线程匹配到了当前的元素，就返回匹配到的元素；</p><p>（4）如果两者模式不一样，且头节点没有在匹配中，就拿当前节点跟它匹配，匹配成功了就返回匹配到的元素；</p><p>（5）如果两者模式不一样，且头节点正在匹配中，当前线程就协助去匹配，匹配完成了再让当前节点重新入栈重新匹配；</p><h2 id="synchronousqueue的公平模式和非公平模式有什么区别"><a class="markdownIt-Anchor" href="#synchronousqueue的公平模式和非公平模式有什么区别">#</a> SynchronousQueue 的公平模式和非公平模式有什么区别？</h2><p>SynchronousQueue 有两种实现方式，一种是公平（队列）方式，一种是非公平（栈）方式；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public SynchronousQueue() &#123;</span><br><span class="line">       // 默认非公平模式</span><br><span class="line">       this(false);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public SynchronousQueue(boolean fair) &#123;</span><br><span class="line">       // 如果是公平模式就使用队列，如果是非公平模式就使用栈</span><br><span class="line">       transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="synchronousqueue在高并发情景下会有什么问题"><a class="markdownIt-Anchor" href="#synchronousqueue在高并发情景下会有什么问题">#</a> SynchronousQueue 在高并发情景下会有什么问题？</h2><p>试想一下，如果有多个生产者，但只有一个消费者，如果消费者处理不过来，是不是生产者都会阻塞起来？反之亦然。</p><p>这是一件很危险的事，所以，SynchronousQueue 一般用于生产、消费的速度大致相当的情况，这样才不会导致系统中过多的线程处于阻塞状态。</p><h2 id="priorityblockingqueue的实现方式"><a class="markdownIt-Anchor" href="#priorityblockingqueue的实现方式">#</a> PriorityBlockingQueue 的实现方式？</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 默认容量为11</span><br><span class="line">private static final int DEFAULT_INITIAL_CAPACITY = 11;</span><br><span class="line">// 最大数组大小</span><br><span class="line">private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br><span class="line">// 存储元素的地方</span><br><span class="line">private transient Object[] queue;</span><br><span class="line">// 元素个数</span><br><span class="line">private transient int size;</span><br><span class="line">// 比较器</span><br><span class="line">private transient Comparator&lt;? super E&gt; comparator;</span><br><span class="line">// 重入锁</span><br><span class="line">private final ReentrantLock lock;</span><br><span class="line">// 非空条件</span><br><span class="line">private final Condition notEmpty;</span><br><span class="line">// 扩容的时候使用的控制变量，CAS更新这个值，谁更新成功了谁扩容，其它线程让出CPU</span><br><span class="line">private transient volatile int allocationSpinLock;</span><br><span class="line">// 不阻塞的优先级队列，非存储元素的地方，仅用于序列化/反序列化时</span><br><span class="line">private PriorityQueue&lt;E&gt; q;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）依然是使用一个数组来使用元素；</p><p>（2）使用一个锁加一个 notEmpty 条件来保证并发安全；</p><p>（3）使用一个变量的 CAS 操作来控制扩容；</p><h2 id="priorityblockingqueue是否需要扩容"><a class="markdownIt-Anchor" href="#priorityblockingqueue是否需要扩容">#</a> PriorityBlockingQueue 是否需要扩容？</h2><p>PriorityBlockingQueue 扩容时使用一个单独变量的 CAS 操作来控制只有一个线程进行扩容；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private void tryGrow(Object[] array, int oldCap) &#123;</span><br><span class="line">       // 先释放锁，因为是从offer()方法的锁内部过来的</span><br><span class="line">       // 这里先释放锁，使用allocationSpinLock变量控制扩容的过程</span><br><span class="line">       // 防止阻塞的线程过多</span><br><span class="line">       lock.unlock(); // must release and then re-acquire main lock</span><br><span class="line">       Object[] newArray = null;</span><br><span class="line">       // CAS更新allocationSpinLock变量为1的线程获得扩容资格</span><br><span class="line">       if (allocationSpinLock == 0 &amp;&amp;</span><br><span class="line">           UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,</span><br><span class="line">                                    0, 1)) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 旧容量小于64则翻倍，旧容量大于64则增加一半</span><br><span class="line">               int newCap = oldCap + ((oldCap &lt; 64) ?</span><br><span class="line">                                      (oldCap + 2) : // grow faster if small</span><br><span class="line">                                      (oldCap &gt;&gt; 1));</span><br><span class="line">               // 判断新容量是否溢出</span><br><span class="line">               if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123;    // possible overflow</span><br><span class="line">                   int minCap = oldCap + 1;</span><br><span class="line">                   if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                       throw new OutOfMemoryError();</span><br><span class="line">                   newCap = MAX_ARRAY_SIZE;</span><br><span class="line">               &#125;</span><br><span class="line">               // 创建新数组</span><br><span class="line">               if (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                   newArray = new Object[newCap];</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               // 相当于解锁</span><br><span class="line">               allocationSpinLock = 0;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 只有进入了上面条件的才会满足这个条件</span><br><span class="line">       // 意思是让其它线程让出CPU</span><br><span class="line">       if (newArray == null) // back off if another thread is allocating</span><br><span class="line">           Thread.yield();</span><br><span class="line">       // 再次加锁</span><br><span class="line">       lock.lock();</span><br><span class="line">       // 判断新数组创建成功并且旧数组没有被替换过</span><br><span class="line">       if (newArray != null &amp;&amp; queue == array) &#123;</span><br><span class="line">           // 队列赋值为新数组</span><br><span class="line">           queue = newArray;</span><br><span class="line">           // 并拷贝旧数组元素到新数组中</span><br><span class="line">           System.arraycopy(array, 0, newArray, 0, oldCap);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（1）解锁，解除 offer () 方法中加的锁；</p><p>（2）使用 allocationSpinLock 变量的 CAS 操作来控制扩容的过程；</p><p>（3）旧容量小于 64 则翻倍，旧容量大于 64 则增加一半；</p><p>（4）创建新数组；</p><p>（5）修改 allocationSpinLock 为 0，相当于解锁；</p><p>（6）其它线程在扩容的过程中要让出 CPU；</p><p>（7）再次加锁；</p><p>（8）新数组创建成功，把旧数组元素拷贝过来，并返回到 offer () 方法中继续添加元素操作；</p><h2 id="priorityblockingqueue怎么保证线程安全"><a class="markdownIt-Anchor" href="#priorityblockingqueue怎么保证线程安全">#</a> PriorityBlockingQueue 怎么保证线程安全？</h2><p>PriorityBlockingQueue 使用一个锁 + 一个 notEmpty 条件控制并发安全；</p><p>每个阻塞队列都有四个方法，我们这里只分析一个 offer (E e) 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">        // 元素不能为空</span><br><span class="line">        if (e == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lock();</span><br><span class="line">        int n, cap;</span><br><span class="line">        Object[] array;</span><br><span class="line">        // 判断是否需要扩容，即元素个数达到了数组容量</span><br><span class="line">        while ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">            tryGrow(array, cap);</span><br><span class="line">        try &#123;</span><br><span class="line">            Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">            // 根据是否有比较器选择不同的方法</span><br><span class="line">            if (cmp == null)</span><br><span class="line">                siftUpComparable(n, e, array);</span><br><span class="line">            else</span><br><span class="line">                siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">            // 插入元素完毕，元素个数加1            </span><br><span class="line">            size = n + 1;</span><br><span class="line">            // 唤醒notEmpty条件</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123;</span><br><span class="line">        Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x;</span><br><span class="line">        while (k &gt; 0) &#123;</span><br><span class="line">            // 取父节点</span><br><span class="line">            int parent = (k - 1) &gt;&gt;&gt; 1;</span><br><span class="line">            // 父节点的元素值</span><br><span class="line">            Object e = array[parent];</span><br><span class="line">            // 如果key大于父节点，堆化结束</span><br><span class="line">            if (key.compareTo((T) e) &gt;= 0)</span><br><span class="line">                break;</span><br><span class="line">            // 否则，交换二者的位置，继续下一轮比较</span><br><span class="line">            array[k] = e;</span><br><span class="line">            k = parent;</span><br><span class="line">        &#125;</span><br><span class="line">        // 找到了应该放的位置，放入元素</span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>入队的整个操作跟 PriorityQueue 几乎一致：</p><p>（1）加锁；</p><p>（2）判断是否需要扩容；</p><p>（3）添加元素并做自下而上的堆化；</p><p>（4）元素个数加 1 并唤醒 notEmpty 条件，唤醒取元素的线程；</p><p>（5）解锁；</p><p>阻塞队列的出队方法也有四个，我们这里只分析一个 take () 方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        // 加锁</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        E result;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 队列没有元素，就阻塞在notEmpty条件上</span><br><span class="line">            // 出队成功，就跳出这个循环</span><br><span class="line">            while ( (result = dequeue()) == null)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 解锁</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回出队的元素</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private E dequeue() &#123;</span><br><span class="line">        // 元素个数减1</span><br><span class="line">        int n = size - 1;</span><br><span class="line">        if (n &lt; 0)</span><br><span class="line">            // 数组元素不足，返回null</span><br><span class="line">            return null;</span><br><span class="line">        else &#123;</span><br><span class="line">            Object[] array = queue;</span><br><span class="line">            // 弹出堆顶元素</span><br><span class="line">            E result = (E) array[0];</span><br><span class="line">            // 把堆尾元素拿到堆顶</span><br><span class="line">            E x = (E) array[n];</span><br><span class="line">            array[n] = null;</span><br><span class="line">            Comparator&lt;? super E&gt; cmp = comparator;</span><br><span class="line">            // 并做自上而下的堆化</span><br><span class="line">            if (cmp == null)</span><br><span class="line">                siftDownComparable(0, x, array, n);</span><br><span class="line">            else</span><br><span class="line">                siftDownUsingComparator(0, x, array, n, cmp);</span><br><span class="line">            // 修改size</span><br><span class="line">            size = n;</span><br><span class="line">            // 返回出队的元素</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array,</span><br><span class="line">                                               int n) &#123;</span><br><span class="line">        if (n &gt; 0) &#123;</span><br><span class="line">            Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x;</span><br><span class="line">            int half = n &gt;&gt;&gt; 1;           // loop while a non-leaf</span><br><span class="line">            // 只需要遍历到叶子节点就够了</span><br><span class="line">            while (k &lt; half) &#123;</span><br><span class="line">                // 左子节点</span><br><span class="line">                int child = (k &lt;&lt; 1) + 1; // assume left child is least</span><br><span class="line">                // 左子节点的值</span><br><span class="line">                Object c = array[child];</span><br><span class="line">                // 右子节点</span><br><span class="line">                int right = child + 1;</span><br><span class="line">                // 取左右子节点中最小的值</span><br><span class="line">                if (right &lt; n &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0)</span><br><span class="line">                    c = array[child = right];</span><br><span class="line">                // key如果比左右子节点都小，则堆化结束</span><br><span class="line">                if (key.compareTo((T) c) &lt;= 0)</span><br><span class="line">                    break;</span><br><span class="line">                // 否则，交换key与左右子节点中最小的节点的位置</span><br><span class="line">                array[k] = c;</span><br><span class="line">                k = child;</span><br><span class="line">            &#125;</span><br><span class="line">            // 找到了放元素的位置，放置元素</span><br><span class="line">            array[k] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出队的过程与 PriorityQueue 基本类似：</p><p>（1）加锁；</p><p>（2）判断是否出队成功，未成功就阻塞在 notEmpty 条件上；</p><p>（3）出队时弹出堆顶元素，并把堆尾元素拿到堆顶；</p><p>（4）再做自上而下的堆化；</p><p>（5）解锁；</p><h2 id="priorityblockingqueue为什么不需要notfull条件"><a class="markdownIt-Anchor" href="#priorityblockingqueue为什么不需要notfull条件">#</a> PriorityBlockingQueue 为什么不需要 notFull 条件？</h2><p>因为 PriorityBlockingQueue 在入队的时候如果没有空间了是会自动扩容的，也就不存在队列满了的状态，也就是不需要等待通知队列不满了可以放元素了，所以也就不需要 notFull 条件了</p><h2 id="什么是双重队列"><a class="markdownIt-Anchor" href="#什么是双重队列">#</a> 什么是双重队列？</h2><p>放取元素使用同一个队列，队列中的节点具有两种模式，一种是数据节点，一种是非数据节点。</p><p>放元素时先跟队列头节点对比，如果头节点是非数据节点，就让他们匹配，如果头节点是数据节点，就生成一个数据节点放在队列尾端（入队）。</p><p>取元素时也是先跟队列头节点对比，如果头节点是数据节点，就让他们匹配，如果头节点是非数据节点，就生成一个非数据节点放在队列尾端（入队）。</p><p>用图形来表示就是下面这样：</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817204016.png" alt="202105091521058242.png"></p><h2 id="linkedtransferqueue是怎么实现阻塞队列的"><a class="markdownIt-Anchor" href="#linkedtransferqueue是怎么实现阻塞队列的">#</a> LinkedTransferQueue 是怎么实现阻塞队列的？</h2><p>LinkedTransferQueue 可以看作 LinkedBlockingQueue、SynchronousQueue（公平模式）、ConcurrentLinkedQueue 三者的集合体；</p><p>LinkedTransferQueue 的实现方式是使用一种叫做 <code>双重队列</code> 的数据结构；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">static final class Node &#123;</span><br><span class="line">        // 是否是数据节点（也就标识了是生产者还是消费者）</span><br><span class="line">        final boolean isData;   // false if this is a request node</span><br><span class="line">        // 元素的值</span><br><span class="line">        volatile Object item;   // initially non-null if isData; CASed to match</span><br><span class="line">        // 下一个节点</span><br><span class="line">        volatile Node next;</span><br><span class="line">        // 持有元素的线程</span><br><span class="line">        volatile Thread waiter; // null until waiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="linkedtransferqueue是怎么控制并发安全的"><a class="markdownIt-Anchor" href="#linkedtransferqueue是怎么控制并发安全的">#</a> LinkedTransferQueue 是怎么控制并发安全的？</h2><p>LinkedTransferQueue 全程都没有使用 synchronized、重入锁等比较重的锁，基本是通过 自旋 + CAS 实现；</p><p>不管是取元素还是放元素都会入队；</p><p>先尝试跟头节点比较，如果二者模式不一样，就匹配它们，组成 CP，然后返回对方的值；</p><p>如果二者模式一样，就入队，并自旋或阻塞等待被唤醒；</p><p>至于是否入队及阻塞有四种模式，NOW、ASYNC、SYNC、TIMED；</p><h3 id="xfer"><a class="markdownIt-Anchor" href="#xfer">#</a> xfer()</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">private E xfer(E e, boolean haveData, int how, long nanos) &#123;</span><br><span class="line">        // 不允许放入空元素</span><br><span class="line">        if (haveData &amp;&amp; (e == null))</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Node s = null;                        // the node to append, if needed</span><br><span class="line">        // 外层循环，自旋，失败就重试</span><br><span class="line">        retry:</span><br><span class="line">        for (;;) &#123;                            // restart on append race</span><br><span class="line">    </span><br><span class="line">            // 下面这个for循环用于控制匹配的过程</span><br><span class="line">            // 同一时刻队列中只会存储一种类型的节点</span><br><span class="line">            // 从头节点开始尝试匹配，如果头节点被其它线程先一步匹配了</span><br><span class="line">            // 就再尝试其下一个，直到匹配到为止，或者到队列中没有元素为止</span><br><span class="line">    </span><br><span class="line">            for (Node h = head, p = h; p != null;) &#123; // find &amp; match first node</span><br><span class="line">                // p节点的模式</span><br><span class="line">                boolean isData = p.isData;</span><br><span class="line">                // p节点的值</span><br><span class="line">                Object item = p.item;</span><br><span class="line">                // p没有被匹配到</span><br><span class="line">                if (item != p &amp;&amp; (item != null) == isData) &#123; // unmatched</span><br><span class="line">                    // 如果两者模式一样，则不能匹配，跳出循环后尝试入队</span><br><span class="line">                    if (isData == haveData)   // can&#x27;t match</span><br><span class="line">                        break;</span><br><span class="line">                    // 如果两者模式不一样，则尝试匹配</span><br><span class="line">                    // 把p的值设置为e（如果是取元素则e是null，如果是放元素则e是元素值）</span><br><span class="line">                    if (p.casItem(item, e)) &#123; // match</span><br><span class="line">                        // 匹配成功</span><br><span class="line">                        // for里面的逻辑比较复杂，用于控制多线程同时放取元素时出现竞争的情况的</span><br><span class="line">                        // 看不懂可以直接跳过</span><br><span class="line">                        for (Node q = p; q != h;) &#123;</span><br><span class="line">                            // 进入到这里可能是头节点已经被匹配，然后p会变成h的下一个节点</span><br><span class="line">                            Node n = q.next;  // update by 2 unless singleton</span><br><span class="line">                            // 如果head还没变，就把它更新成新的节点</span><br><span class="line">                            // 并把它删除（forgetNext()会把它的next设为自己，也就是从单链表中删除了）</span><br><span class="line">                            // 这时为什么要把head设为n呢？因为到这里了，肯定head本身已经被匹配掉了</span><br><span class="line">                            // 而上面的p.casItem()又成功了，说明p也被当前这个元素给匹配掉了</span><br><span class="line">                            // 所以需要把它们俩都出队列，让其它线程可以从真正的头开始，不用重复检查了</span><br><span class="line">                            if (head == h &amp;&amp; casHead(h, n == null ? q : n)) &#123;</span><br><span class="line">                                h.forgetNext();</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;                 // advance and retry</span><br><span class="line">                            // 如果新的头节点为空，或者其next为空，或者其next未匹配，就重试</span><br><span class="line">                            if ((h = head)   == null ||</span><br><span class="line">                                (q = h.next) == null || !q.isMatched())</span><br><span class="line">                                break;        // unless slack &lt; 2</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 唤醒p中等待的线程</span><br><span class="line">                        LockSupport.unpark(p.waiter);</span><br><span class="line">                        // 并返回匹配到的元素</span><br><span class="line">                        return LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // p已经被匹配了或者尝试匹配的时候失败了</span><br><span class="line">                // 也就是其它线程先一步匹配了p</span><br><span class="line">                // 这时候又分两种情况，p的next还没来得及修改，p的next指向了自己</span><br><span class="line">                // 如果p的next已经指向了自己，就重新取head重试，否则就取其next重试</span><br><span class="line">                Node n = p.next;</span><br><span class="line">                p = (p != n) ? n : (h = head); // Use head if p offlist</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 到这里肯定是队列中存储的节点类型和自己一样</span><br><span class="line">            // 或者队列中没有元素了</span><br><span class="line">            // 就入队（不管放元素还是取元素都得入队）</span><br><span class="line">            // 入队又分成四种情况：</span><br><span class="line">            // NOW，立即返回，没有匹配到立即返回，不做入队操作</span><br><span class="line">            // ASYNC，异步，元素入队但当前线程不会阻塞（相当于无界LinkedBlockingQueue的元素入队）</span><br><span class="line">            // SYNC，同步，元素入队后当前线程阻塞，等待被匹配到</span><br><span class="line">            // TIMED，有超时，元素入队后等待一段时间被匹配，时间到了还没匹配到就返回元素本身</span><br><span class="line">    </span><br><span class="line">            // 如果不是立即返回</span><br><span class="line">            if (how != NOW) &#123;                 // No matches available</span><br><span class="line">                // 新建s节点</span><br><span class="line">                if (s == null)</span><br><span class="line">                    s = new Node(e, haveData);</span><br><span class="line">                // 尝试入队</span><br><span class="line">                Node pred = tryAppend(s, haveData);</span><br><span class="line">                // 入队失败，重试</span><br><span class="line">                if (pred == null)</span><br><span class="line">                    continue retry;           // lost race vs opposite mode</span><br><span class="line">                // 如果不是异步（同步或者有超时）</span><br><span class="line">                // 就等待被匹配</span><br><span class="line">                if (how != ASYNC)</span><br><span class="line">                    return awaitMatch(s, pred, e, (how == TIMED), nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            return e; // not waiting</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private Node tryAppend(Node s, boolean haveData) &#123;</span><br><span class="line">        // 从tail开始遍历，把s放到链表尾端</span><br><span class="line">        for (Node t = tail, p = t;;) &#123;        // move p to last node and append</span><br><span class="line">            Node n, u;                        // temps for reads of next &amp; tail</span><br><span class="line">            // 如果首尾都是null，说明链表中还没有元素</span><br><span class="line">            if (p == null &amp;&amp; (p = head) == null) &#123;</span><br><span class="line">                // 就让首节点指向s</span><br><span class="line">                // 注意，这里插入第一个元素的时候tail指针并没有指向s</span><br><span class="line">                if (casHead(null, s))</span><br><span class="line">                    return s;                 // initialize</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p.cannotPrecede(haveData))</span><br><span class="line">                // 如果p无法处理，则返回null</span><br><span class="line">                // 这里无法处理的意思是，p和s节点的类型不一样，不允许s入队</span><br><span class="line">                // 比如，其它线程先入队了一个数据节点，这时候要入队一个非数据节点，就不允许，</span><br><span class="line">                // 队列中所有的元素都要保证是同一种类型的节点</span><br><span class="line">                // 返回null后外面的方法会重新尝试匹配重新入队等</span><br><span class="line">                return null;                  // lost race vs opposite mode</span><br><span class="line">            else if ((n = p.next) != null)    // not last; keep traversing</span><br><span class="line">                // 如果p的next不为空，说明不是最后一个节点</span><br><span class="line">                // 则让p重新指向最后一个节点</span><br><span class="line">                p = p != t &amp;&amp; t != (u = tail) ? (t = u) : // stale tail</span><br><span class="line">                    (p != n) ? n : null;      // restart if off list</span><br><span class="line">            else if (!p.casNext(null, s))</span><br><span class="line">                // 如果CAS更新s为p的next失败</span><br><span class="line">                // 则说明有其它线程先一步更新到p的next了</span><br><span class="line">                // 就让p指向p的next，重新尝试让s入队</span><br><span class="line">                p = p.next;                   // re-read on CAS failure</span><br><span class="line">            else &#123;</span><br><span class="line">                // 到这里说明s成功入队了</span><br><span class="line">                // 如果p不等于t，就更新tail指针</span><br><span class="line">                // 还记得上面插入第一个元素时tail指针并没有指向新元素吗？</span><br><span class="line">                // 这里就是用来更新tail指针的</span><br><span class="line">                if (p != t) &#123;                 // update if slack now &gt;= 2</span><br><span class="line">                    while ((tail != t || !casTail(t, s)) &amp;&amp;</span><br><span class="line">                           (t = tail)   != null &amp;&amp;</span><br><span class="line">                           (s = t.next) != null &amp;&amp; // advance and retry</span><br><span class="line">                           (s = s.next) != null &amp;&amp; s != t);</span><br><span class="line">                &#125;</span><br><span class="line">                // 返回p，即s的前一个元素</span><br><span class="line">                return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) &#123;</span><br><span class="line">        // 如果是有超时的，计算其超时时间</span><br><span class="line">        final long deadline = timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">        // 当前线程</span><br><span class="line">        Thread w = Thread.currentThread();</span><br><span class="line">        // 自旋次数</span><br><span class="line">        int spins = -1; // initialized after first item and cancel checks</span><br><span class="line">        // 随机数，随机让一些自旋的线程让出CPU</span><br><span class="line">        ThreadLocalRandom randomYields = null; // bound if needed</span><br><span class="line">    </span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            Object item = s.item;</span><br><span class="line">            // 如果s元素的值不等于e，说明它被匹配到了</span><br><span class="line">            if (item != e) &#123;                  // matched</span><br><span class="line">                // assert item != s;</span><br><span class="line">                // 把s的item更新为s本身</span><br><span class="line">                // 并把s中的waiter置为空</span><br><span class="line">                s.forgetContents();           // avoid garbage</span><br><span class="line">                // 返回匹配到的元素</span><br><span class="line">                return LinkedTransferQueue.&lt;E&gt;cast(item);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果当前线程中断了，或者有超时的到期了</span><br><span class="line">            // 就更新s的元素值指向s本身</span><br><span class="line">            if ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= 0)) &amp;&amp;</span><br><span class="line">                    s.casItem(e, s)) &#123;        // cancel</span><br><span class="line">                // 尝试解除s与其前一个节点的关系</span><br><span class="line">                // 也就是删除s节点</span><br><span class="line">                unsplice(pred, s);</span><br><span class="line">                // 返回元素的值本身，说明没匹配到</span><br><span class="line">                return e;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            // 如果自旋次数小于0，就计算自旋次数</span><br><span class="line">            if (spins &lt; 0) &#123;                  // establish spins at/near front</span><br><span class="line">                // spinsFor()计算自旋次数</span><br><span class="line">                // 如果前面有节点未被匹配就返回0</span><br><span class="line">                // 如果前面有节点且正在匹配中就返回一定的次数，等待</span><br><span class="line">                if ((spins = spinsFor(pred, s.isData)) &gt; 0)</span><br><span class="line">                    // 初始化随机数</span><br><span class="line">                    randomYields = ThreadLocalRandom.current();</span><br><span class="line">            &#125;</span><br><span class="line">            else if (spins &gt; 0) &#123;             // spin</span><br><span class="line">                // 还有自旋次数就减1</span><br><span class="line">                --spins;</span><br><span class="line">                // 并随机让出CPU</span><br><span class="line">                if (randomYields.nextInt(CHAINED_SPINS) == 0)</span><br><span class="line">                    Thread.yield();           // occasionally yield</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s.waiter == null) &#123;</span><br><span class="line">                // 更新s的waiter为当前线程</span><br><span class="line">                s.waiter = w;                 // request unpark then recheck</span><br><span class="line">            &#125;</span><br><span class="line">            else if (timed) &#123;</span><br><span class="line">                // 如果有超时，计算超时时间，并阻塞一定时间</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                if (nanos &gt; 0L)</span><br><span class="line">                    LockSupport.parkNanos(this, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                // 不是超时的，直接阻塞，等待被唤醒</span><br><span class="line">                // 唤醒后进入下一次循环，走第一个if的逻辑就返回匹配的元素了</span><br><span class="line">                LockSupport.park(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这三个方法里的内容特别复杂，很大一部分代码都是在控制线程安全，各种 CAS，我们这里简单描述一下大致的逻辑：</p><p>（1）来了一个元素，我们先查看队列头的节点，是否与这个元素的模式一样；</p><p>（2）如果模式不一样，就尝试让他们匹配，如果头节点被别的线程先匹配走了，就尝试与头节点的下一个节点匹配，如此一直往后，直到匹配到或到链表尾为止；</p><p>（3）如果模式一样，或者到链表尾了，就尝试入队；</p><p>（4）入队的时候有可能链表尾修改了，那就尾指针后移，再重新尝试入队，依此往复；</p><p>（5）入队成功了，就自旋或阻塞，阻塞了就等待被其它线程匹配到并唤醒；</p><p>（6）唤醒之后进入下一次循环就匹配到元素了，返回匹配到的元素；</p><p>（7）是否需要入队及阻塞有四种情况：</p><p>a）NOW，立即返回，没有匹配到立即返回，不做入队操作<br>对应的方法有：poll ()、tryTransfer (e)<br> b）ASYNC，异步，元素入队但当前线程不会阻塞（相当于无界 LinkedBlockingQueue 的元素入队）<br>对应的方法有：add (e)、offer (e)、put (e)、offer (e, timeout, unit)<br> c）SYNC，同步，元素入队后当前线程阻塞，等待被匹配到<br>对应的方法有：take ()、transfer (e)<br> d）TIMED，有超时，元素入队后等待一段时间被匹配，时间到了还没匹配到就返回元素本身<br>对应的方法有：poll (timeout, unit)、tryTransfer (e, timeout, unit)</p><h2 id="linkedtransferqueue与synchronousqueue有什么异同"><a class="markdownIt-Anchor" href="#linkedtransferqueue与synchronousqueue有什么异同">#</a> LinkedTransferQueue 与 SynchronousQueue 有什么异同？</h2><p>（1）在 java8 中两者的实现方式基本一致，都是使用的双重队列；</p><p>（2）前者完全实现了后者，但比后者更灵活；</p><p>（3）后者不管放元素还是取元素，如果没有可匹配的元素，所在的线程都会阻塞；</p><p>（4）前者可以自己控制放元素是否需要阻塞线程，比如使用四个添加元素的方法就不会阻塞线程，只入队元素，使用 transfer () 会阻塞线程；</p><p>（5）取元素两者基本一样，都会阻塞等待有新的元素进入被匹配到；</p><h2 id="concurrentlinkedqueue是阻塞队列吗"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue是阻塞队列吗">#</a> ConcurrentLinkedQueue 是阻塞队列吗？</h2><p>ConcurrentLinkedQueue 不是阻塞队列；ConcurrentLinkedQueue 只实现了 Queue 接口，并没有实现 BlockingQueue 接口，所以它不是阻塞队列，也不能用于线程池中，但是它是线程安全的，可用于多线程环境中。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817205205.png" alt="image-20210817205204809"></p><h2 id="concurrentlinkedqueue如何保证并发安全"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue如何保证并发安全">#</a> ConcurrentLinkedQueue 如何保证并发安全？</h2><p>能</p><p>因为它不是阻塞队列，所以只有两个入队的方法，add (e) 和 offer (e)。</p><p>因为是无界队列，所以 add (e) 方法也不用抛出异常了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        // 不能添加空元素</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        // 新节点</span><br><span class="line">        final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</span><br><span class="line">    </span><br><span class="line">        // 入队到链表尾</span><br><span class="line">        for (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            // 如果没有next，说明到链表尾部了，就入队</span><br><span class="line">            if (q == null) &#123;</span><br><span class="line">                // CAS更新p的next为新节点</span><br><span class="line">                // 如果成功了，就返回true</span><br><span class="line">                // 如果不成功就重新取next重新尝试</span><br><span class="line">                if (p.casNext(null, newNode)) &#123;</span><br><span class="line">                    // 如果p不等于t，说明有其它线程先一步更新tail</span><br><span class="line">                    // 也就不会走到q==null这个分支了</span><br><span class="line">                    // p取到的可能是t后面的值</span><br><span class="line">                    // 把tail原子更新为新节点</span><br><span class="line">                    if (p != t) // hop two nodes at a time</span><br><span class="line">                        casTail(t, newNode);  // Failure is OK.</span><br><span class="line">                    // 返回入队成功</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (p == q)</span><br><span class="line">                // 如果p的next等于p，说明p已经被删除了（已经出队了）</span><br><span class="line">                // 重新设置p的值</span><br><span class="line">                p = (t != (t = tail)) ? t : head;</span><br><span class="line">            else</span><br><span class="line">                // t后面还有值，重新设置p的值</span><br><span class="line">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>入队整个流程还是比较清晰的，这里有个前提是出队时会把出队的那个节点的 next 设置为节点本身。</p><p>（1）定位到链表尾部，尝试把新节点到后面；</p><p>（2）如果尾部变化了，则重新获取尾部，再重试；</p><p>因为它不是阻塞队列，所以只有两个出队的方法，remove () 和 poll ()。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E remove() &#123;</span><br><span class="line">        E x = poll();</span><br><span class="line">        if (x != null)</span><br><span class="line">            return x;</span><br><span class="line">        else</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public E poll() &#123;</span><br><span class="line">        restartFromHead:</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            // 尝试弹出链表的头节点</span><br><span class="line">            for (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">                E item = p.item;</span><br><span class="line">                // 如果节点的值不为空，并且将其更新为null成功了</span><br><span class="line">                if (item != null &amp;&amp; p.casItem(item, null)) &#123;</span><br><span class="line">                    // 如果头节点变了，则不会走到这个分支</span><br><span class="line">                    // 会先走下面的分支拿到新的头节点</span><br><span class="line">                    // 这时候p就不等于h了，就更新头节点</span><br><span class="line">                    // 在updateHead()中会把head更新为新节点</span><br><span class="line">                    // 并让head的next指向其自己</span><br><span class="line">                    if (p != h) // hop two nodes at a time</span><br><span class="line">                        updateHead(h, ((q = p.next) != null) ? q : p);</span><br><span class="line">                    // 上面的casItem()成功，就可以返回出队的元素了</span><br><span class="line">                    return item;</span><br><span class="line">                &#125;</span><br><span class="line">                // 下面三个分支说明头节点变了</span><br><span class="line">                // 且p的item肯定为null</span><br><span class="line">                else if ((q = p.next) == null) &#123;</span><br><span class="line">                    // 如果p的next为空，说明队列中没有元素了</span><br><span class="line">                    // 更新h为p，也就是空元素的节点</span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    // 返回null</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (p == q)</span><br><span class="line">                    // 如果p等于p的next，说明p已经出队了，重试</span><br><span class="line">                    continue restartFromHead;</span><br><span class="line">                else</span><br><span class="line">                    // 将p设置为p的next</span><br><span class="line">                    p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新头节点的方法</span><br><span class="line">    final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123;</span><br><span class="line">        // 原子更新h为p成功后，延迟更新h的next为它自己</span><br><span class="line">        // 这里用延迟更新是安全的，因为head节点已经变了</span><br><span class="line">        // 只要入队出队的时候检查head有没有变化就行了，跟它的next关系不大</span><br><span class="line">        if (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">            h.lazySetNext(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>出队的整个逻辑也是比较清晰的：</p><p>（1）定位到头节点，尝试更新其值为 null；</p><p>（2）如果成功了，就成功出队；</p><p>（3）如果失败或者头节点变化了，就重新寻找头节点，并重试；</p><p>（4）整个出队过程没有一点阻塞相关的代码，所以出队的时候不会阻塞线程，没找到元素就返回 null；</p><h2 id="concurrentlinkedqueue能用于线程池吗"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue能用于线程池吗">#</a> ConcurrentLinkedQueue 能用于线程池吗？</h2><p>ConcurrentLinkedQueue 不能用在线程池中；因为不是阻塞队列。</p><h2 id="concurrentlinkedqueue与linkedblockingqueue对比"><a class="markdownIt-Anchor" href="#concurrentlinkedqueue与linkedblockingqueue对比">#</a> ConcurrentLinkedQueue 与 LinkedBlockingQueue 对比？</h2><p>（1）两者都是线程安全的队列；</p><p>（2）两者都可以实现取元素时队列为空直接返回 null，后者的 poll () 方法可以实现此功能；</p><p>（3）前者全程无锁，后者全部都是使用重入锁控制的；</p><p>（4）前者效率较高，后者效率较低；</p><p>（5）前者无法实现如果队列为空等待元素到来的操作；</p><p>（6）前者是非阻塞队列，后者是阻塞队列；</p><p>（7）前者无法用在线程池中，后者可以；</p><h2 id="delayqueue是阻塞-队列吗"><a class="markdownIt-Anchor" href="#delayqueue是阻塞-队列吗">#</a> DelayQueue 是阻塞 - 队列吗？</h2><p>从继承体系可以看到，DelayQueue 实现了 BlockingQueue，所以它是一个阻塞队列。</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817205623.png" alt="image-20210817205623249"></p><h2 id="delayqueue的实现方式"><a class="markdownIt-Anchor" href="#delayqueue的实现方式">#</a> DelayQueue 的实现方式？</h2><p>DelayQueue 内部存储结构使用优先级队列；</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 用于控制并发的锁</span><br><span class="line">    private final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    // 优先级队列</span><br><span class="line">    private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();</span><br><span class="line">    // 用于标记当前是否有线程在排队（仅用于取元素时）</span><br><span class="line">    private Thread leader = null;</span><br><span class="line">    // 条件，用于表示现在是否有可取的元素</span><br><span class="line">    private final Condition available = lock.newCondition();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="delayqueue如何保证并发安全"><a class="markdownIt-Anchor" href="#delayqueue如何保证并发安全">#</a> DelayQueue 如何保证并发安全？</h2><p>DelayQueue 使用重入锁和条件来控制并发安全；</p><p>因为 DelayQueue 是阻塞队列，且优先级队列是无界的，所以入队不会阻塞不会超时，因此它的四个入队方法是一样的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(E e) &#123;</span><br><span class="line">        offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        return offer(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean offer(E e) &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            q.offer(e);</span><br><span class="line">            if (q.peek() == e) &#123;</span><br><span class="line">                leader = null;</span><br><span class="line">                available.signal();</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>入队方法比较简单：</p><p>（1）加锁；</p><p>（2）添加元素到优先级队列中；</p><p>（3）如果添加的元素是堆顶元素，就把 leader 置为空，并唤醒等待在条件 available 上的线程；</p><p>（4）解锁；</p><p>因为 DelayQueue 是阻塞队列，所以它的出队有四个不同的方法，有抛出异常的，有阻塞的，有不阻塞的，有超时的。</p><p>我们这里主要分析两个，poll () 和 take () 方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line"> public E poll() &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            if (first == null || first.getDelay(NANOSECONDS) &gt; 0)</span><br><span class="line">                return null;</span><br><span class="line">            else</span><br><span class="line">                return q.poll();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>poll () 方法比较简单：</p><p>（1）加锁；</p><p>（2）检查第一个元素，如果为空或者还没到期，就返回 null；</p><p>（3）如果第一个元素到期了就调用 poll () 弹出第一个元素；</p><p>（4）解锁。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public E take() throws InterruptedException &#123;</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                // 堆顶元素</span><br><span class="line">                E first = q.peek();</span><br><span class="line">                // 如果堆顶元素为空，说明队列中还没有元素，直接阻塞等待</span><br><span class="line">                if (first == null)</span><br><span class="line">                    available.await();</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 堆顶元素的到期时间</span><br><span class="line">                    long delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                    // 如果小于0说明已到期，直接调用poll()方法弹出堆顶元素</span><br><span class="line">                    if (delay &lt;= 0)</span><br><span class="line">                        return q.poll();</span><br><span class="line">    </span><br><span class="line">                    // 如果delay大于0 ，则下面要阻塞了</span><br><span class="line">    </span><br><span class="line">                    // 将first置为空方便gc，因为有可能其它元素弹出了这个元素</span><br><span class="line">                    // 这里还持有着引用不会被清理</span><br><span class="line">                    first = null; // don&#x27;t retain ref while waiting</span><br><span class="line">                    // 如果前面有其它线程在等待，直接进入等待</span><br><span class="line">                    if (leader != null)</span><br><span class="line">                        available.await();</span><br><span class="line">                    else &#123;</span><br><span class="line">                        // 如果leader为null，把当前线程赋值给它</span><br><span class="line">                        Thread thisThread = Thread.currentThread();</span><br><span class="line">                        leader = thisThread;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            // 等待delay时间后自动醒过来</span><br><span class="line">                            // 醒过来后把leader置空并重新进入循环判断堆顶元素是否到期</span><br><span class="line">                            // 这里即使醒过来后也不一定能获取到元素</span><br><span class="line">                            // 因为有可能其它线程先一步获取了锁并弹出了堆顶元素</span><br><span class="line">                            // 条件锁的唤醒分成两步，先从Condition的队列里出队</span><br><span class="line">                            // 再入队到AQS的队列中，当其它线程调用LockSupport.unpark(t)的时候才会真正唤醒</span><br><span class="line">                            // 关于AQS我们后面会讲的^^</span><br><span class="line">                            available.awaitNanos(delay);</span><br><span class="line">                        &#125; finally &#123;</span><br><span class="line">                            // 如果leader还是当前线程就把它置为空，让其它线程有机会获取元素</span><br><span class="line">                            if (leader == thisThread)</span><br><span class="line">                                leader = null;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 成功出队后，如果leader为空且堆顶还有元素，就唤醒下一个等待的线程</span><br><span class="line">            if (leader == null &amp;&amp; q.peek() != null)</span><br><span class="line">                // signal()只是把等待的线程放到AQS的队列里面，并不是真正的唤醒</span><br><span class="line">                available.signal();</span><br><span class="line">            // 解锁，这才是真正的唤醒</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>take () 方法稍微要复杂一些：</p><p>（1）加锁；</p><p>（2）判断堆顶元素是否为空，为空的话直接阻塞等待；</p><p>（3）判断堆顶元素是否到期，到期了直接 poll () 出元素；</p><p>（4）没到期，再判断前面是否有其它线程在等待，有则直接等待；</p><p>（5）前面没有其它线程在等待，则把自己当作第一个线程等待 delay 时间后唤醒，再尝试获取元素；</p><p>（6）获取到元素之后再唤醒下一个等待的线程；</p><p>（7）解锁；</p><h2 id="delayqueue主要用于什么场景"><a class="markdownIt-Anchor" href="#delayqueue主要用于什么场景">#</a> DelayQueue 主要用于什么场景？</h2><p>DelayQueue 常用于定时任务</p><h2 id="java中的线程池实现定时任务是直接用的delayqueue吗"><a class="markdownIt-Anchor" href="#java中的线程池实现定时任务是直接用的delayqueue吗">#</a> java 中的线程池实现定时任务是直接用的 DelayQueue 吗？</h2><p>当然不是，ScheduledThreadPoolExecutor 中使用的是它自己定义的内部类 DelayedWorkQueue，其实里面的实现逻辑基本都是一样的，只不过 DelayedWorkQueue 里面没有使用现在的 PriorityQueue，而是使用数组又实现了一遍优先级队列，本质上没有什么区别。</p><h2 id="什么是双端队列"><a class="markdownIt-Anchor" href="#什么是双端队列">#</a> 什么是双端队列？</h2><p>双端队列是一种特殊的队列，它的两端都可以进出元素，故而得名双端队列。</p><h2 id="arraydeque是怎么实现双端队列的"><a class="markdownIt-Anchor" href="#arraydeque是怎么实现双端队列的">#</a> ArrayDeque 是怎么实现双端队列的？</h2><p>ArrayDeque 是一种以数组方式实现的双端队列，它是非线程安全的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">// 存储元素的数组</span><br><span class="line">    transient Object[] elements; // non-private to simplify nested class access</span><br><span class="line">    // 队列头位置</span><br><span class="line">    transient int head;</span><br><span class="line">    // 队列尾位置</span><br><span class="line">    transient int tail;</span><br><span class="line">    // 最小初始容量</span><br><span class="line">    private static final int MIN_INITIAL_CAPACITY = 8;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="linkedlist与arraydeque的对比"><a class="markdownIt-Anchor" href="#linkedlist与arraydeque的对比">#</a> LinkedList 与 ArrayDeque 的对比？</h2><p>ArrayList、ArrayDeque 内部以数组的形式保存集合中的元素，因此随机访问元素时有较好的性能；而 LinkedList 内部以链表的形式来保存集合中的元素，因此随机访问集合中的元素时虽然性能较差，但在插入、删除元素时性能非常出色（只需要改变指针所指的地址即可）。需要指出的是，虽然 Vector 也是以数组的形式来存储</p><h2 id="双端队列是否可以作为栈使用"><a class="markdownIt-Anchor" href="#双端队列是否可以作为栈使用">#</a> 双端队列是否可以作为栈使用？</h2><p>可以</p><p>ArrayDeque 可以直接作为栈使用；</p><h2 id="linkedlist是list和deque的集合体"><a class="markdownIt-Anchor" href="#linkedlist是list和deque的集合体">#</a> LinkedList 是 List 和 Deque 的集合体？</h2><p>是</p><p>LinkedList 在功能上等于 ArrayList + ArrayDeque；</p><p><img src="https://lvxueyangboke.oss-cn-beijing.aliyuncs.com/images/20210817210645.png" alt="image-20210817210645275"></p><h2 id="集合指定初始容量的好处"><a class="markdownIt-Anchor" href="#集合指定初始容量的好处">#</a> 集合指定初始容量的好处？</h2><p>集合是我们在 Java 编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection 的初始容量也显得异常重要。所以：<strong>对于已知的情景，请为集合指定初始容量。</strong></p><p>如 ArrayList 每次新增一个元素，就会检测 ArrayList 的当前容量是否已经到达临界点，如果到达临界点则会扩容 1.5 倍。然而 ArrayList 的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
